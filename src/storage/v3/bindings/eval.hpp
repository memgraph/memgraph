// Copyright 2022 Memgraph Ltd.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt; by using this file, you agree to be bound by the terms of the Business Source
// License, and you may not use this file except in compliance with the Business Source License.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

#pragma once

#include "storage/v2/property_value.hpp"
#include "storage/v3/bindings/bindings.hpp"

#include "expr/interpret/eval.hpp"
#include "storage/v3/bindings/db_accessor.hpp"
#include "storage/v3/bindings/typed_value.hpp"
#include "storage/v3/conversions.hpp"
#include "storage/v3/id_types.hpp"
#include "storage/v3/property_store.hpp"
#include "storage/v3/property_value.hpp"
#include "storage/v3/view.hpp"
#include "utils/memory.hpp"

namespace memgraph::storage::v3 {

struct PropertyToTypedValueConverter {
  TypedValue operator()(const auto &val) { return memgraph::storage::v3::PropertyToTypedValue<TypedValue>(val); }

  TypedValue operator()(const auto &val, utils::MemoryResource *mem) {
    return memgraph::storage::v3::PropertyToTypedValue<TypedValue>(val, mem);
  }
};

struct Parameters {
 public:
  /**
   * Adds a value to the stripped arguments under a token position.
   *
   * @param position Token position in query of value.
   * @param value
   */
  void Add(int position, const storage::v3::PropertyValue &value) { storage_.emplace_back(position, value); }

  /**
   *  Returns the value found for the given token position.
   *
   *  @param position Token position in query of value.
   *  @return Value for the given token position.
   */
  const storage::v3::PropertyValue &AtTokenPosition(int position) const {
    auto found = std::find_if(storage_.begin(), storage_.end(), [&](const auto &a) { return a.first == position; });
    MG_ASSERT(found != storage_.end(), "Token position must be present in container");
    return found->second;
  }

  /**
   * Returns the position-th stripped value. Asserts that this
   * container has at least (position + 1) elements.
   *
   * @param position Which stripped param is sought.
   * @return Token position and value for sought param.
   */
  const std::pair<int, storage::v3::PropertyValue> &At(int position) const {
    MG_ASSERT(position < static_cast<int>(storage_.size()), "Invalid position");
    return storage_[position];
  }

  /** Returns the number of arguments in this container */
  auto size() const { return storage_.size(); }

  auto begin() const { return storage_.begin(); }
  auto end() const { return storage_.end(); }

 private:
  std::vector<std::pair<int, storage::v3::PropertyValue>> storage_;
};

struct EvaluationContext {
  /// Memory for allocations during evaluation of a *single* Pull call.
  ///
  /// Although the assigned memory may live longer than the duration of a Pull
  /// (e.g. memory is the same as the whole execution memory), you have to treat
  /// it as if the lifetime is only valid during the Pull.
  utils::MemoryResource *memory{utils::NewDeleteResource()};
  int64_t timestamp{-1};
  Parameters parameters;
  /// All properties indexable via PropertyIx
  std::vector<storage::v3::PropertyId> properties;
  /// All labels indexable via LabelIx
  std::vector<storage::v3::LabelId> labels;
  /// All counters generated by `counter` function, mutable because the function
  /// modifies the values
  mutable std::unordered_map<std::string, int64_t> counters;
};

using ExpressionEvaluator =
    memgraph::expr::ExpressionEvaluator<TypedValue, EvaluationContext, DbAccessor, storage::v3::View,
                                        storage::v3::LabelId, storage::v3::PropertyStore, PropertyToTypedValueConverter,
                                        memgraph::storage::v3::Error>;

}  // namespace memgraph::storage::v3
