#>cpp
#pragma once

#include <memory>
#include <unordered_map>
#include <vector>

#include "query/frontend/ast/ast_visitor.hpp"
#include "query/frontend/semantic/symbol.hpp"
#include "query/interpret/awesome_memgraph_functions.hpp"
#include "query/typed_value.hpp"
#include "storage/common/property_value.hpp"
#include "storage/common/types.hpp"

// Hash function for the key in pattern atom property maps.
namespace std {
template <>
struct hash<std::pair<std::string, storage::Property>> {
  size_t operator()(
      const std::pair<std::string, storage::Property> &pair) const {
    return string_hash(pair.first) ^ property_hash(pair.second);
  };

 private:
  std::hash<std::string> string_hash{};
  std::hash<storage::Property> property_hash{};
};
}  // namespace std

namespace database {
class GraphDbAccessor;
}

cpp<#

(lcp:namespace query)
(lcp:capnp-namespace "query")

(lcp:capnp-import 'storage "/storage/distributed/serialization.capnp")
(lcp:capnp-import 'symbol "/query/frontend/semantic/symbol.capnp")
(lcp:capnp-import 'utils "/utils/serialization.capnp")

(lcp:capnp-type-conversion "PropertyValue" "Storage.PropertyValue")
(lcp:capnp-type-conversion "storage::Label" "Storage.Common")
(lcp:capnp-type-conversion "storage::EdgeType" "Storage.Common")
(lcp:capnp-type-conversion "storage::Property" "Storage.Common")
(lcp:capnp-type-conversion "Symbol" "Symbol.Symbol")

(defun save-ast-pointer (builder member capnp-name)
  #>cpp
  if (${member}) {
    auto ${capnp-name}_builder = ${builder}->init${capnp-name}();
    Save(*${member}, &${capnp-name}_builder, saved_uids);
  }
  cpp<#)

(defun load-ast-pointer (type)
  (lambda (reader member capnp-name)
    #>cpp
    if (${reader}.has${capnp-name}()) {
      ${member} = static_cast<${type}>(
          Load(storage, ${reader}.get${capnp-name}(), loaded_uids));
    } else {
      ${member} = nullptr;
    }
    cpp<#))

(defun save-ast-vector (type)
  (lcp:capnp-save-vector "capnp::Tree" type
                         "[saved_uids](auto *builder, const auto &val) {
                            Save(*val, builder, saved_uids);
                          }"))

(defun load-ast-vector (type)
  (lcp:capnp-load-vector "capnp::Tree" type
                         (format
                           nil
                           "[storage, loaded_uids](const auto &reader) {
                              return static_cast<~A>(Load(storage, reader, loaded_uids));
                            }"
                            type)))

(defun save-property-map (builder member capnp-name)
  #>cpp
  auto entries_builder = ${builder}.initEntries(${member}.size());
  size_t i = 0;
  for (const auto &entry : ${member}) {
    auto key_builder = entries_builder[i].initKey();
    key_builder.setFirst(entry.first.first);
    auto prop_id_builder = key_builder.initSecond();
    storage::Save(entry.first.second, &prop_id_builder);
    auto value_builder = entries_builder[i].initValue();
    Save(*entry.second, &value_builder, saved_uids);
    ++i;
  }
  cpp<#)

(defun load-property-map (reader member capnp-name)
  #>cpp
  for (const auto &entry : ${reader}.getEntries()) {
    std::string prop_name = entry.getKey().getFirst();
    storage::Property prop_id;
    storage::Load(&prop_id, entry.getKey().getSecond());
    ${member}.emplace(std::make_pair(prop_name, prop_id),
                      static_cast<Expression *>(Load(storage, entry.getValue(), loaded_uids)));
  }
  cpp<#)

#>cpp
#define CLONE_BINARY_EXPRESSION                                              \
  auto Clone(AstStorage &storage) const->std::remove_const<                  \
      std::remove_pointer<decltype(this)>::type>::type *override {           \
    return storage.Create<                                                   \
        std::remove_cv<std::remove_reference<decltype(*this)>::type>::type>( \
        expression1_->Clone(storage), expression2_->Clone(storage));         \
  }
#define CLONE_UNARY_EXPRESSION                                               \
  auto Clone(AstStorage &storage) const->std::remove_const<                  \
      std::remove_pointer<decltype(this)>::type>::type *override {           \
    return storage.Create<                                                   \
        std::remove_cv<std::remove_reference<decltype(*this)>::type>::type>( \
        expression_->Clone(storage));                                        \
  }

class Context;
class Tree;

// It would be better to call this AstTree, but we already have a class Tree,
// which could be renamed to Node or AstTreeNode, but we also have a class
// called NodeAtom...
class AstStorage {
 public:
  AstStorage() = default;
  AstStorage(const AstStorage &) = delete;
  AstStorage &operator=(const AstStorage &) = delete;
  AstStorage(AstStorage &&) = default;
  AstStorage &operator=(AstStorage &&) = default;

  template <typename T, typename... Args>
  T *Create(Args &&... args) {
    T *ptr = new T(++max_existing_uid_, std::forward<Args>(args)...);
    std::unique_ptr<T> tmp(ptr);
    storage_.emplace_back(std::move(tmp));
    return ptr;
  }

  // Public only for serialization access
  std::vector<std::unique_ptr<Tree>> storage_;
  int max_existing_uid_ = -1;
};
cpp<#

(lcp:define-class tree ("::utils::Visitable<HierarchicalTreeVisitor>"
                        "::utils::Visitable<TreeVisitor<TypedValue>>")
  ((uid :int32_t :scope :public))
  (:abstractp t)
  (:public
    #>cpp
    Tree() = default;

    using ::utils::Visitable<HierarchicalTreeVisitor>::Accept;
    using ::utils::Visitable<TreeVisitor<TypedValue>>::Accept;

    virtual Tree *Clone(AstStorage &storage) const = 0;
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:protected
    #>cpp
    explicit Tree(int uid) : uid_(uid) {}
    cpp<#)
  (:serialize :capnp :base t
              :save-args '((saved-uids "std::vector<int32_t> *"))
              :load-args '((storage "AstStorage *")
                           (loaded-uids "std::vector<int32_t> *"))
              :post-save (lambda (builder)
                           (declare (ignore builder))
                           ;; This is a bit hacky because it relies on the fact that parent class
                           ;; serialization is inlined so we can short-circuit and avoid serializing
                           ;; the derived class.
                           #>cpp
                           if (utils::Contains(*saved_uids, self.uid_)) {
                             return;
                           }
                           saved_uids->push_back(self.uid_);
                           cpp<#)))

(lcp:define-class expression (tree)
  ()
  (:abstractp t)
  (:public
    #>cpp
    Expression() = default;

    Expression *Clone(AstStorage &storage) const override = 0;
    cpp<#)
  (:protected
    #>cpp
    explicit Expression(int uid) : Tree(uid) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class where (tree)
  ((expression "Expression *" :initval "nullptr" :scope :public
               :capnp-type "Tree" :capnp-init nil
               :capnp-save #'save-ast-pointer
               :capnp-load (load-ast-pointer "Expression *")))
  (:public
    #>cpp
    Where() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        expression_->Accept(visitor);
      }
      return visitor.PostVisit(*this);
    }

    Where *Clone(AstStorage &storage) const override {
      return storage.Create<Where>(expression_->Clone(storage));
    }
    cpp<#)
  (:protected
    #>cpp
    explicit Where(int uid) : Tree(uid) {}
    Where(int uid, Expression *expression) : Tree(uid), expression_(expression) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class binary-operator (expression)
  ((expression1 "Expression *" :initval "nullptr" :scope :public
                :capnp-type "Tree" :capnp-init nil
                :capnp-save #'save-ast-pointer
                :capnp-load (load-ast-pointer "Expression *"))
   (expression2 "Expression *" :initval "nullptr" :scope :public
                :capnp-type "Tree" :capnp-init nil
                :capnp-save #'save-ast-pointer
                :capnp-load (load-ast-pointer "Expression *")))
  (:abstractp t)
  (:public
    #>cpp
    BinaryOperator() = default;

    BinaryOperator *Clone(AstStorage &storage) const override = 0;
    cpp<#)
  (:protected
    #>cpp
    explicit BinaryOperator(int uid) : Expression(uid) {}
    BinaryOperator(int uid, Expression *expression1, Expression *expression2)
        : Expression(uid), expression1_(expression1), expression2_(expression2) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class unary-operator (expression)
  ((expression "Expression *" :initval "nullptr" :scope :public
               :capnp-type "Tree" :capnp-init nil
               :capnp-save #'save-ast-pointer
               :capnp-load (load-ast-pointer "Expression *")))
  (:abstractp t)
  (:public
    #>cpp
    UnaryOperator() = default;

    UnaryOperator *Clone(AstStorage &storage) const override = 0;
    cpp<#)
  (:protected
    #>cpp
    explicit UnaryOperator(int uid) : Expression(uid) {}
    UnaryOperator(int uid, Expression *expression)
        : Expression(uid), expression_(expression) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(macrolet ((define-binary-operators ()
             `(lcp:cpp-list
               ,@(loop for op in
                       '(or-operator xor-operator and-operator addition-operator
                         subtraction-operator multiplication-operator division-operator
                         mod-operator not-equal-operator equal-operator less-operator
                         greater-operator less-equal-operator greater-equal-operator
                         in-list-operator subscript-operator)
                       collecting
                       `(lcp:define-class ,op (binary-operator)
                          ()
                          (:public
                            (let ((cpp-name (lcp::cpp-type-name ',op)))
                              #>cpp
                              DEFVISITABLE(TreeVisitor<TypedValue>);
                              bool Accept(HierarchicalTreeVisitor &visitor) override {
                                if (visitor.PreVisit(*this)) {
                                  expression1_->Accept(visitor) && expression2_->Accept(visitor);
                                }
                                return visitor.PostVisit(*this);
                              }
                              CLONE_BINARY_EXPRESSION;
                              cpp<#))
                          (:protected
                            #>cpp
                            using BinaryOperator::BinaryOperator;
                            cpp<#)
                          (:private
                            #>cpp
                            friend class AstStorage;
                            cpp<#)
                          (:serialize :capnp))))))
  (define-binary-operators))

(macrolet ((define-unary-operators ()
             `(lcp:cpp-list
               ,@(loop for op in
                       '(not-operator unary-plus-operator
                         unary-minus-operator is-null-operator)
                       collecting
                       `(lcp:define-class ,op (unary-operator)
                          ()
                          (:public
                            (let ((cpp-name (lcp::cpp-type-name ',op)))
                              #>cpp
                              DEFVISITABLE(TreeVisitor<TypedValue>);
                              bool Accept(HierarchicalTreeVisitor &visitor) override {
                                if (visitor.PreVisit(*this)) {
                                  expression_->Accept(visitor);
                                }
                                return visitor.PostVisit(*this);
                              }
                              CLONE_UNARY_EXPRESSION;
                              cpp<#))
                          (:protected
                            #>cpp
                            using UnaryOperator::UnaryOperator;
                            cpp<#)
                          (:private
                            #>cpp
                            friend class AstStorage;
                            cpp<#)
                          (:serialize :capnp))))))
  (define-unary-operators))

(lcp:define-class aggregation (binary-operator)
  ((op "Op" :scope :public))
  (:public
    (lcp:define-enum op
      (count min max sum avg collect-list collect-map)
      (:serialize :capnp))
    #>cpp
    Aggregation() = default;

    static const constexpr char *const kCount = "COUNT";
    static const constexpr char *const kMin = "MIN";
    static const constexpr char *const kMax = "MAX";
    static const constexpr char *const kSum = "SUM";
    static const constexpr char *const kAvg = "AVG";
    static const constexpr char *const kCollect = "COLLECT";

    static std::string OpToString(Op op) {
      const char *op_strings[] = {kCount, kMin,     kMax,    kSum,
                                  kAvg,   kCollect, kCollect};
      return op_strings[static_cast<int>(op)];
    }

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        if (expression1_) expression1_->Accept(visitor);
        if (expression2_) expression2_->Accept(visitor);
      }
      return visitor.PostVisit(*this);
    }

    Aggregation *Clone(AstStorage &storage) const override {
      return storage.Create<Aggregation>(
          expression1_ ? expression1_->Clone(storage) : nullptr,
          expression2_ ? expression2_->Clone(storage) : nullptr, op_);
    }
    cpp<#)
  (:protected
    #>cpp
    // Use only for serialization.
    Aggregation(int uid, Op op) : BinaryOperator(uid), op_(op) {}

    /// Aggregation's first expression is the value being aggregated. The second
    /// expression is the key used only in COLLECT_MAP.
    Aggregation(int uid, Expression *expression1, Expression *expression2, Op op)
        : BinaryOperator(uid, expression1, expression2), op_(op) {
      // COUNT without expression denotes COUNT(*) in cypher.
      DCHECK(expression1 || op == Aggregation::Op::COUNT)
          << "All aggregations, except COUNT require expression";
      DCHECK((expression2 == nullptr) ^ (op == Aggregation::Op::COLLECT_MAP))
          << "The second expression is obligatory in COLLECT_MAP and "
             "invalid otherwise";
    }
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class list-slicing-operator (expression)
  ((list "Expression *" :initval "nullptr" :scope :public
         :capnp-type "Tree" :capnp-init nil
         :capnp-save #'save-ast-pointer
         :capnp-load (load-ast-pointer "Expression *"))
   (lower-bound "Expression *" :initval "nullptr" :scope :public
                :capnp-type "Tree" :capnp-init nil
                :capnp-save #'save-ast-pointer
                :capnp-load (load-ast-pointer "Expression *"))
   (upper-bound "Expression *" :initval "nullptr" :scope :public
                :capnp-type "Tree" :capnp-init nil
                :capnp-save #'save-ast-pointer
                :capnp-load (load-ast-pointer "Expression *")))
  (:public
    #>cpp
    ListSlicingOperator() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        bool cont = list_->Accept(visitor);
        if (cont && lower_bound_) {
          cont = lower_bound_->Accept(visitor);
        }
        if (cont && upper_bound_) {
          upper_bound_->Accept(visitor);
        }
      }
      return visitor.PostVisit(*this);
    }

    ListSlicingOperator *Clone(AstStorage &storage) const override {
      return storage.Create<ListSlicingOperator>(
          list_->Clone(storage),
          lower_bound_ ? lower_bound_->Clone(storage) : nullptr,
          upper_bound_ ? upper_bound_->Clone(storage) : nullptr);
    }
   cpp<#)
  (:protected
    #>cpp
    ListSlicingOperator(int uid, Expression *list, Expression *lower_bound,
                        Expression *upper_bound)
        : Expression(uid),
          list_(list),
          lower_bound_(lower_bound),
          upper_bound_(upper_bound) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class if-operator (expression)
  ((condition "Expression *" :scope :public
              :capnp-type "Tree" :capnp-init nil
              :capnp-save #'save-ast-pointer
              :capnp-load (load-ast-pointer "Expression *")
              :documentation "None of the expressions should be nullptr. If there is no else_expression, you should make it null PrimitiveLiteral.")
   (then-expression "Expression *" :scope :public
                    :capnp-type "Tree" :capnp-init nil
                    :capnp-save #'save-ast-pointer
                    :capnp-load (load-ast-pointer "Expression *"))
   (else-expression "Expression *" :scope :public
                    :capnp-type "Tree" :capnp-init nil
                    :capnp-save #'save-ast-pointer
                    :capnp-load (load-ast-pointer "Expression *")))
  (:public
    #>cpp
    IfOperator() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        condition_->Accept(visitor) && then_expression_->Accept(visitor) &&
            else_expression_->Accept(visitor);
      }
      return visitor.PostVisit(*this);
    }

    IfOperator *Clone(AstStorage &storage) const override {
      return storage.Create<IfOperator>(condition_->Clone(storage),
                                        then_expression_->Clone(storage),
                                        else_expression_->Clone(storage));
    }
    cpp<#)
  (:protected
    #>cpp
    IfOperator(int uid, Expression *condition, Expression *then_expression,
               Expression *else_expression)
        : Expression(uid),
          condition_(condition),
          then_expression_(then_expression),
          else_expression_(else_expression) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class base-literal (expression)
  ()
  (:abstractp t)
  (:public
    #>cpp
    BaseLiteral() = default;

    BaseLiteral *Clone(AstStorage &storage) const override = 0;
    cpp<#)
  (:protected
    #>cpp
    explicit BaseLiteral(int uid) : Expression(uid) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class primitive-literal (base-literal)
  ((value "PropertyValue" :scope :public
          :capnp-save (lambda (builder member capnp-name)
                        #>cpp
                        storage::SaveCapnpPropertyValue(${member}, &${builder});
                        cpp<#)
          :capnp-load (lambda (reader member capnp-name)
                        #>cpp
                        storage::LoadCapnpPropertyValue(${reader}, &${member});
                        cpp<#))
   (token-position :int32_t :scope :public :initval -1
                   :documentation "This field contains token position of literal used to create PrimitiveLiteral object. If PrimitiveLiteral object is not created from query, leave its value at -1."))
  (:public
    #>cpp
    PrimitiveLiteral() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    DEFVISITABLE(HierarchicalTreeVisitor);

    PrimitiveLiteral *Clone(AstStorage &storage) const override {
      return storage.Create<PrimitiveLiteral>(value_, token_position_);
    }
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:protected
    #>cpp
    explicit PrimitiveLiteral(int uid) : BaseLiteral(uid) {}
    template <typename T>
    PrimitiveLiteral(int uid, T value) : BaseLiteral(uid), value_(value) {}
    template <typename T>
    PrimitiveLiteral(int uid, T value, int token_position)
        : BaseLiteral(uid), value_(value), token_position_(token_position) {}
    cpp<#)
  (:serialize :capnp))

(lcp:define-class list-literal (base-literal)
  ((elements "std::vector<Expression *>"
             :scope :public
             :capnp-type "List(Tree)"
             :capnp-save (save-ast-vector "Expression *")
             :capnp-load (load-ast-vector "Expression *")))
  (:public
    #>cpp
    ListLiteral() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        for (auto expr_ptr : elements_)
          if (!expr_ptr->Accept(visitor)) break;
      }
      return visitor.PostVisit(*this);
    }

    ListLiteral *Clone(AstStorage &storage) const override {
      auto *list = storage.Create<ListLiteral>();
      for (auto *element : elements_) {
        list->elements_.push_back(element->Clone(storage));
      }
      return list;
    }
    cpp<#)
  (:protected
    #>cpp
    explicit ListLiteral(int uid) : BaseLiteral(uid) {}
    ListLiteral(int uid, const std::vector<Expression *> &elements)
        : BaseLiteral(uid), elements_(elements) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class map-literal (base-literal)
  ((elements "std::unordered_map<std::pair<std::string, storage::Property>, Expression *>"
             :capnp-type "Utils.Map(Utils.Pair(Text, Storage.Common), Tree)"
             :capnp-save #'save-property-map
             :capnp-load #'load-property-map
             :scope :public))
  (:public
    #>cpp
    MapLiteral() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        for (auto pair : elements_)
          if (!pair.second->Accept(visitor)) break;
      }
      return visitor.PostVisit(*this);
    }

    MapLiteral *Clone(AstStorage &storage) const override {
      auto *map = storage.Create<MapLiteral>();
      for (auto pair : elements_)
        map->elements_.emplace(pair.first, pair.second->Clone(storage));
      return map;
    }
    cpp<#)
  (:protected
    #>cpp
    explicit MapLiteral(int uid) : BaseLiteral(uid) {}
    MapLiteral(int uid,
               const std::unordered_map<std::pair<std::string, storage::Property>,
                                        Expression *> &elements)
        : BaseLiteral(uid), elements_(elements) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class identifier (expression)
  ((name "std::string" :scope :public)
   (user-declared :bool :initval "true" :scope :public))
  (:public
    #>cpp
    Identifier() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    DEFVISITABLE(HierarchicalTreeVisitor);

    Identifier *Clone(AstStorage &storage) const override {
      return storage.Create<Identifier>(name_, user_declared_);
    }
    cpp<#)
  (:protected
    #>cpp
    Identifier(int uid, const std::string &name) : Expression(uid), name_(name) {}
    Identifier(int uid, const std::string &name, bool user_declared)
        : Expression(uid), name_(name), user_declared_(user_declared) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class property-lookup (expression)
  ((expression "Expression *" :initval "nullptr" :scope :public
               :capnp-type "Tree" :capnp-init nil
               :capnp-save #'save-ast-pointer
               :capnp-load (load-ast-pointer "Expression *"))
   (property-name "std::string" :scope :public)
   (property "storage::Property" :scope :public))
  (:public
    #>cpp
    PropertyLookup() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        expression_->Accept(visitor);
      }
      return visitor.PostVisit(*this);
    }

    PropertyLookup *Clone(AstStorage &storage) const override {
      return storage.Create<PropertyLookup>(expression_->Clone(storage),
                                            property_name_, property_);
    }
    cpp<#)
  (:protected
    #>cpp
    PropertyLookup(int uid, Expression *expression,
                   const std::string &property_name, storage::Property property)
        : Expression(uid),
          expression_(expression),
          property_name_(property_name),
          property_(property) {}
    PropertyLookup(int uid, Expression *expression,
                   const std::pair<std::string, storage::Property> &property)
        : Expression(uid),
          expression_(expression),
          property_name_(property.first),
          property_(property.second) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class labels-test (expression)
  ((expression "Expression *" :initval "nullptr" :scope :public
               :capnp-type "Tree" :capnp-init nil
               :capnp-save #'save-ast-pointer
               :capnp-load (load-ast-pointer "Expression *"))
   (labels "std::vector<storage::Label>" :scope :public
           :capnp-save (lcp:capnp-save-vector
                         "storage::capnp::Common"
                         "storage::Label")
           :capnp-load (lcp:capnp-load-vector
                         "storage::capnp::Common"
                         "storage::Label")))
  (:public
    #>cpp
    LabelsTest() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        expression_->Accept(visitor);
      }
      return visitor.PostVisit(*this);
    }

    LabelsTest *Clone(AstStorage &storage) const override {
      return storage.Create<LabelsTest>(expression_->Clone(storage), labels_);
    }
    cpp<#)
  (:protected
    #>cpp
    LabelsTest(int uid, Expression *expression,
               const std::vector<storage::Label> &labels)
        : Expression(uid), expression_(expression), labels_(labels) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class function (expression)
  ((arguments "std::vector<Expression *>"
              :scope :public
              :capnp-type "List(Tree)"
              :capnp-save (save-ast-vector "Expression *")
              :capnp-load (load-ast-vector "Expression *"))
   (function-name "std::string" :scope :public)
   (function "std::function<TypedValue(TypedValue *, int64_t, const EvaluationContext &, database::GraphDbAccessor *)>"
             :scope :public :capnp-init nil
             :capnp-save :dont-save
             :capnp-load (lambda (reader member capnp-name)
                           #>cpp
                           ${member} = NameToFunction(self->get()->function_name_);
                           cpp<#)))
  (:public
    #>cpp
    Function() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        for (auto *argument : arguments_) {
          if (!argument->Accept(visitor)) break;
        }
      }
      return visitor.PostVisit(*this);
    }

    Function *Clone(AstStorage &storage) const override {
      std::vector<Expression *> arguments;
      for (auto *argument : arguments_) {
        arguments.push_back(argument->Clone(storage));
      }
      return storage.Create<Function>(function_name_, arguments);
    }
    cpp<#)
  (:protected
    #>cpp
    explicit Function(int uid) : Expression(uid) {}

    Function(int uid, const std::string &function_name,
             const std::vector<Expression *> &arguments)
        : Expression(uid),
          arguments_(arguments),
          function_name_(function_name),
          function_(NameToFunction(function_name_)) {
      DCHECK(function_) << "Unexpected missing function: " << function_name_;
    }
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class reduce (expression)
  ((accumulator "Identifier *" :initval "nullptr" :scope :public
                :capnp-type "Tree" :capnp-init nil
                :capnp-save #'save-ast-pointer
                :capnp-load (load-ast-pointer "Identifier *")
                :documentation "Identifier for the accumulating variable")
   (initializer "Expression *" :initval "nullptr" :scope :public
                :capnp-type "Tree" :capnp-init nil
                :capnp-save #'save-ast-pointer
                :capnp-load (load-ast-pointer "Expression *")
                :documentation "Expression which produces the initial accumulator value.")
   (identifier "Identifier *" :initval "nullptr" :scope :public
               :capnp-type "Tree" :capnp-init nil
               :capnp-save #'save-ast-pointer
               :capnp-load (load-ast-pointer "Identifier *")
               :documentation "Identifier for the list element.")
   (list "Expression *" :initval "nullptr" :scope :public
         :capnp-type "Tree" :capnp-init nil
         :capnp-save #'save-ast-pointer
         :capnp-load (load-ast-pointer "Expression *")
         :documentation "Expression which produces a list to be reduced.")
   (expression "Expression *" :initval "nullptr" :scope :public
               :capnp-type "Tree" :capnp-init nil
               :capnp-save #'save-ast-pointer
               :capnp-load (load-ast-pointer "Expression *")
               :documentation "Expression which does the reduction, i.e. produces the new accumulator value."))
  (:public
    #>cpp
    Reduce() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        accumulator_->Accept(visitor) && initializer_->Accept(visitor) &&
            identifier_->Accept(visitor) && list_->Accept(visitor) &&
            expression_->Accept(visitor);
      }
      return visitor.PostVisit(*this);
    }

    Reduce *Clone(AstStorage &storage) const override {
      return storage.Create<Reduce>(
          accumulator_->Clone(storage), initializer_->Clone(storage),
          identifier_->Clone(storage), list_->Clone(storage),
          expression_->Clone(storage));
    }
    cpp<#)
  (:protected
    #>cpp
    Reduce(int uid, Identifier *accumulator, Expression *initializer,
           Identifier *identifier, Expression *list, Expression *expression)
        : Expression(uid),
          accumulator_(accumulator),
          initializer_(initializer),
          identifier_(identifier),
          list_(list),
          expression_(expression) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class extract (expression)
  ((identifier "Identifier *" :initval "nullptr" :scope :public
               :capnp-type "Tree" :capnp-init nil
               :capnp-save #'save-ast-pointer
               :capnp-load (load-ast-pointer "Identifier *")
               :documentation "Identifier for the list element.")
   (list "Expression *" :initval "nullptr" :scope :public
         :capnp-type "Tree" :capnp-init nil
         :capnp-save #'save-ast-pointer
         :capnp-load (load-ast-pointer "Expression *")
         :documentation "Expression which produces a list which will be extracted.")
   (expression "Expression *" :initval "nullptr" :scope :public
               :capnp-type "Tree" :capnp-init nil
               :capnp-save #'save-ast-pointer
               :capnp-load (load-ast-pointer "Expression *")
               :documentation "Expression which produces the new value for list element."))
  (:public
    #>cpp
    Extract() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        identifier_->Accept(visitor) && list_->Accept(visitor) &&
            expression_->Accept(visitor);
      }
      return visitor.PostVisit(*this);
    }

    Extract *Clone(AstStorage &storage) const override {
      return storage.Create<Extract>(identifier_->Clone(storage),
                                     list_->Clone(storage),
                                     expression_->Clone(storage));
    }
    cpp<#)
  (:protected
    #>cpp
    Extract(int uid, Identifier *identifier, Expression *list,
            Expression *expression)
        : Expression(uid),
          identifier_(identifier),
          list_(list),
          expression_(expression) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class all (expression)
  ((identifier "Identifier *" :initval "nullptr" :scope :public
               :capnp-type "Tree" :capnp-init nil
               :capnp-save #'save-ast-pointer
               :capnp-load (load-ast-pointer "Identifier *"))
   (list-expression "Expression *" :initval "nullptr" :scope :public
                    :capnp-type "Tree" :capnp-init nil
                    :capnp-save #'save-ast-pointer
                    :capnp-load (load-ast-pointer "Expression *"))
   (where "Where *" :initval "nullptr" :scope :public
          :capnp-type "Tree" :capnp-init nil
          :capnp-save #'save-ast-pointer
          :capnp-load (load-ast-pointer "Where *")))
  (:public
    #>cpp
    All() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        identifier_->Accept(visitor) && list_expression_->Accept(visitor) &&
            where_->Accept(visitor);
      }
      return visitor.PostVisit(*this);
    }

    All *Clone(AstStorage &storage) const override {
      return storage.Create<All>(identifier_->Clone(storage),
                                 list_expression_->Clone(storage),
                                 where_->Clone(storage));
    }
    cpp<#)
  (:protected
    #>cpp
    All(int uid, Identifier *identifier, Expression *list_expression,
        Where *where)
        : Expression(uid),
          identifier_(identifier),
          list_expression_(list_expression),
          where_(where) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

;;;; TODO: This is pretty much copy pasted from All. Consider merging Reduce,
;;;; All, Any and Single into something like a higher-order function call which
;;;; takes a list argument and a function which is applied on list elements.
(lcp:define-class single (expression)
  ((identifier "Identifier *" :initval "nullptr" :scope :public
               :capnp-type "Tree" :capnp-init nil
               :capnp-save #'save-ast-pointer
               :capnp-load (load-ast-pointer "Identifier *"))
   (list-expression "Expression *" :initval "nullptr" :scope :public
                    :capnp-type "Tree" :capnp-init nil
                    :capnp-save #'save-ast-pointer
                    :capnp-load (load-ast-pointer "Expression *"))
   (where "Where *" :initval "nullptr" :scope :public
          :capnp-type "Tree" :capnp-init nil
          :capnp-save #'save-ast-pointer
          :capnp-load (load-ast-pointer "Where *")))
  (:public
    #>cpp
    Single() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        identifier_->Accept(visitor) && list_expression_->Accept(visitor) &&
            where_->Accept(visitor);
      }
      return visitor.PostVisit(*this);
    }

    Single *Clone(AstStorage &storage) const override {
      return storage.Create<Single>(identifier_->Clone(storage),
                                    list_expression_->Clone(storage),
                                    where_->Clone(storage));
    }
    cpp<#)
  (:protected
    #>cpp
    Single(int uid, Identifier *identifier, Expression *list_expression,
           Where *where)
        : Expression(uid),
          identifier_(identifier),
          list_expression_(list_expression),
          where_(where) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class parameter-lookup (expression)
  ((token-position :int32_t :initval -1 :scope :public
                   :documentation "This field contains token position of *literal* used to create ParameterLookup object. If ParameterLookup object is not created from a literal leave this value at -1."))
  (:public
    #>cpp
    ParameterLookup() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    DEFVISITABLE(HierarchicalTreeVisitor);

    ParameterLookup *Clone(AstStorage &storage) const override {
      return storage.Create<ParameterLookup>(token_position_);
    }
    cpp<#)
  (:protected
    #>cpp
    explicit ParameterLookup(int uid) : Expression(uid) {}
    ParameterLookup(int uid, int token_position)
        : Expression(uid), token_position_(token_position) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class named-expression (tree)
  ((name "std::string" :scope :public)
   (expression "Expression *" :initval "nullptr" :scope :public
               :capnp-type "Tree" :capnp-init nil
               :capnp-save #'save-ast-pointer
               :capnp-load (load-ast-pointer "Expression *"))
   (token-position :int32_t :initval -1 :scope :public
                   :documentation "This field contains token position of first token in named expression used to create name_. If NamedExpression object is not created from query or it is aliased leave this value at -1."))
  (:public
    #>cpp
    NamedExpression() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        expression_->Accept(visitor);
      }
      return visitor.PostVisit(*this);
    }

    NamedExpression *Clone(AstStorage &storage) const override {
      return storage.Create<NamedExpression>(name_, expression_->Clone(storage),
                                             token_position_);
    }
    cpp<#)
  (:protected
    #>cpp
    explicit NamedExpression(int uid) : Tree(uid) {}
    NamedExpression(int uid, const std::string &name) : Tree(uid), name_(name) {}
    NamedExpression(int uid, const std::string &name, Expression *expression)
        : Tree(uid), name_(name), expression_(expression) {}
    NamedExpression(int uid, const std::string &name, Expression *expression,
                    int token_position)
        : Tree(uid),
          name_(name),
          expression_(expression),
          token_position_(token_position) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class pattern-atom (tree)
  ((identifier "Identifier *" :initval "nullptr" :scope :public
               :capnp-type "Tree" :capnp-init nil
               :capnp-save #'save-ast-pointer
               :capnp-load (load-ast-pointer "Identifier *")))
  (:abstractp t)
  (:public
    #>cpp
    PatternAtom() = default;

    PatternAtom *Clone(AstStorage &storage) const override = 0;
    cpp<#)
  (:protected
    #>cpp
    explicit PatternAtom(int uid) : Tree(uid) {}
    PatternAtom(int uid, Identifier *identifier)
        : Tree(uid), identifier_(identifier) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class node-atom (pattern-atom)
  ((labels "std::vector<storage::Label>" :scope :public
           :capnp-save (lcp:capnp-save-vector
                         "storage::capnp::Common"
                         "storage::Label")
           :capnp-load (lcp:capnp-load-vector
                         "storage::capnp::Common"
                         "storage::Label"))
   (properties "std::unordered_map<std::pair<std::string, storage::Property>, Expression *>"
               :capnp-type "Utils.Map(Utils.Pair(Text, Storage.Common), Tree)"
               :capnp-save #'save-property-map
               :capnp-load #'load-property-map
               :scope :public))
  (:public
    #>cpp
    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        bool cont = identifier_->Accept(visitor);
        for (auto &property : properties_) {
          if (cont) {
            cont = property.second->Accept(visitor);
          }
        }
      }
      return visitor.PostVisit(*this);
    }

    NodeAtom *Clone(AstStorage &storage) const override {
      auto *node_atom = storage.Create<NodeAtom>(identifier_->Clone(storage));
      node_atom->labels_ = labels_;
      for (auto property : properties_) {
        node_atom->properties_[property.first] = property.second->Clone(storage);
      }
      return node_atom;
    }
    cpp<#)
  (:protected
    #>cpp
    using PatternAtom::PatternAtom;
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class edge-atom (pattern-atom)
  ((type "Type" :initval "Type::SINGLE" :scope :public)
   (direction "Direction" :initval "Direction::BOTH" :scope :public)
   (edge-types "std::vector<storage::EdgeType>" :scope :public
               :capnp-save (lcp:capnp-save-vector
                             "storage::capnp::Common"
                             "storage::EdgeType")
               :capnp-load (lcp:capnp-load-vector
                             "storage::capnp::Common"
                             "storage::EdgeType"))
   (properties "std::unordered_map<std::pair<std::string, storage::Property>, Expression *>"
               :scope :public
               :capnp-type "Utils.Map(Utils.Pair(Text, Storage.Common), Tree)"
               :capnp-save #'save-property-map
               :capnp-load #'load-property-map)
   (lower-bound "Expression *" :initval "nullptr" :scope :public
                :capnp-type "Tree" :capnp-init nil
                :capnp-save #'save-ast-pointer
                :capnp-load (load-ast-pointer "Expression *")
                :documentation "Evaluates to lower bound in variable length expands.")
   (upper-bound "Expression *" :initval "nullptr" :scope :public
                :capnp-type "Tree" :capnp-init nil
                :capnp-save #'save-ast-pointer
                :capnp-load (load-ast-pointer "Expression *")
                :documentation "Evaluated to upper bound in variable length expands.")
   (filter-lambda "Lambda" :scope :public
                  :documentation "Filter lambda for variable length expands. Can have an empty expression, but identifiers must be valid, because an optimization pass may inline other expressions into this lambda.")
   (weight-lambda "Lambda" :scope :public
                  :documentation "Used in weighted shortest path. It must have valid expressions and identifiers. In all other expand types, it is empty.")
   (total-weight "Identifier *" :initval "nullptr" :scope :public
                 :capnp-type "Tree" :capnp-init nil
                 :capnp-save #'save-ast-pointer
                 :capnp-load (load-ast-pointer "Identifier *")
                 :documentation "Variable where the total weight for weighted shortest path will be stored."))
  (:public
    (lcp:define-enum type
                     (single depth-first breadth-first weighted-shortest-path)
                     (:serialize :capnp))
    (lcp:define-enum direction
                     (in out both)
                     (:serialize :capnp))
    (lcp:define-struct lambda ()
      ((inner-edge "Identifier *" :initval "nullptr"
                   :capnp-type "Tree" :capnp-init nil
                   :capnp-save #'save-ast-pointer
                   :capnp-load (load-ast-pointer "Identifier *")
                   :documentation "Argument identifier for the edge currently being traversed.")
       (inner-node "Identifier *" :initval "nullptr"
                   :capnp-type "Tree" :capnp-init nil
                   :capnp-save #'save-ast-pointer
                   :capnp-load (load-ast-pointer "Identifier *")
                   :documentation "Argument identifier for the destination node of the edge.")
       (expression "Expression *" :initval "nullptr"
                   :capnp-type "Tree" :capnp-init nil
                   :capnp-save #'save-ast-pointer
                   :capnp-load (load-ast-pointer "Expression *")
                   :documentation "Evaluates the result of the lambda."))
      (:documentation "Lambda for use in filtering or weight calculation during variable expand.")
      (:serialize :capnp
                  :save-args '((saved-uids "std::vector<int32_t> *"))
                  :load-args '((storage "AstStorage *")
                               (loaded-uids "std::vector<int32_t> *"))))
    #>cpp
    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        bool cont = identifier_->Accept(visitor);
        for (auto &property : properties_) {
          if (cont) {
            cont = property.second->Accept(visitor);
          }
        }
        if (cont && lower_bound_) {
          cont = lower_bound_->Accept(visitor);
        }
        if (cont && upper_bound_) {
          cont = upper_bound_->Accept(visitor);
        }
        if (cont && total_weight_) {
          total_weight_->Accept(visitor);
        }
      }
      return visitor.PostVisit(*this);
    }

    EdgeAtom *Clone(AstStorage &storage) const override {
      auto *edge_atom = storage.Create<EdgeAtom>(identifier_->Clone(storage));
      edge_atom->direction_ = direction_;
      edge_atom->type_ = type_;
      edge_atom->edge_types_ = edge_types_;
      for (auto property : properties_) {
        edge_atom->properties_[property.first] = property.second->Clone(storage);
      }
      edge_atom->lower_bound_ = CloneOpt(lower_bound_, storage);
      edge_atom->upper_bound_ = CloneOpt(upper_bound_, storage);
      auto clone_lambda = [&storage](const auto &lambda) {
        return Lambda{CloneOpt(lambda.inner_edge, storage),
                      CloneOpt(lambda.inner_node, storage),
                      CloneOpt(lambda.expression, storage)};
      };
      edge_atom->filter_lambda_ = clone_lambda(filter_lambda_);
      edge_atom->weight_lambda_ = clone_lambda(weight_lambda_);
      edge_atom->total_weight_ = CloneOpt(total_weight_, storage);
      return edge_atom;
    }

    bool IsVariable() const {
      switch (type_) {
        case Type::DEPTH_FIRST:
        case Type::BREADTH_FIRST:
        case Type::WEIGHTED_SHORTEST_PATH:
          return true;
        case Type::SINGLE:
          return false;
      }
    }
    cpp<#)
  (:protected
    #>cpp
    using PatternAtom::PatternAtom;
    EdgeAtom(int uid, Identifier *identifier, Type type, Direction direction)
        : PatternAtom(uid, identifier), type_(type), direction_(direction) {}

    // Creates an edge atom for a SINGLE expansion with the given .
    EdgeAtom(int uid, Identifier *identifier, Type type, Direction direction,
             const std::vector<storage::EdgeType> &edge_types)
        : PatternAtom(uid, identifier),
          type_(type),
          direction_(direction),
          edge_types_(edge_types) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;

    template <typename TPtr>
    static TPtr *CloneOpt(TPtr *ptr, AstStorage &storage) {
      return ptr ? ptr->Clone(storage) : nullptr;
    }
    cpp<#)
  (:serialize :capnp))

(lcp:define-class pattern (tree)
  ((identifier "Identifier *" :initval "nullptr" :scope :public
               :capnp-type "Tree" :capnp-init nil
               :capnp-save #'save-ast-pointer
               :capnp-load (load-ast-pointer "Identifier *"))
   (atoms "std::vector<PatternAtom *>"
          :scope :public
          :capnp-type "List(Tree)"
          :capnp-save (save-ast-vector "PatternAtom *")
          :capnp-load (load-ast-vector "PatternAtom *")))
  (:public
    #>cpp
    Pattern() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        bool cont = identifier_->Accept(visitor);
        for (auto &part : atoms_) {
          if (cont) {
            cont = part->Accept(visitor);
          }
        }
      }
      return visitor.PostVisit(*this);
    }

    Pattern *Clone(AstStorage &storage) const override {
      auto *pattern = storage.Create<Pattern>();
      pattern->identifier_ = identifier_->Clone(storage);
      for (auto *atom : atoms_) {
        pattern->atoms_.push_back(atom->Clone(storage));
      }
      return pattern;
    }
    cpp<#)
  (:protected
    #>cpp
    explicit Pattern(int uid) : Tree(uid) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class clause (tree)
  ()
  (:abstractp t)
  (:public
    #>cpp
    Clause() = default;

    Clause *Clone(AstStorage &storage) const override = 0;
    cpp<#)
  (:protected
    #>cpp
    explicit Clause(int uid) : Tree(uid) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class single-query (tree)
  ((clauses "std::vector<Clause *>"
            :scope :public
            :capnp-type "List(Tree)"
            :capnp-save (save-ast-vector "Clause *")
            :capnp-load (load-ast-vector "Clause *")))
  (:public
    #>cpp
    SingleQuery() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        for (auto &clause : clauses_) {
          if (!clause->Accept(visitor)) break;
        }
      }
      return visitor.PostVisit(*this);
    }

    SingleQuery *Clone(AstStorage &storage) const override {
      auto *single_query = storage.Create<SingleQuery>();
      for (auto *clause : clauses_) {
        single_query->clauses_.push_back(clause->Clone(storage));
      }
      return single_query;
    }
    cpp<#)
  (:protected
    #>cpp
    explicit SingleQuery(int uid) : Tree(uid) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class cypher-union (tree)
  ((single-query "SingleQuery *" :initval "nullptr" :scope :public
                 :capnp-type "Tree" :capnp-init nil
                 :capnp-save #'save-ast-pointer
                 :capnp-load (load-ast-pointer "SingleQuery *"))
   (distinct :bool :initval "false" :scope :public)
   (union-symbols "std::vector<Symbol>" :scope :public
                  :documentation "Holds symbols that are created during symbol generation phase. These symbols are used when UNION/UNION ALL combines single query results."))
  (:public
    #>cpp
    CypherUnion() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        single_query_->Accept(visitor);
      }
      return visitor.PostVisit(*this);
    }

    CypherUnion *Clone(AstStorage &storage) const override {
      auto cypher_union = storage.Create<CypherUnion>(distinct_);
      cypher_union->single_query_ = single_query_->Clone(storage);
      cypher_union->union_symbols_ = union_symbols_;
      return cypher_union;
    }
    cpp<#)
  (:protected
    #>cpp
    explicit CypherUnion(int uid) : Tree(uid) {}
    CypherUnion(int uid, bool distinct) : Tree(uid), distinct_(distinct) {}
    CypherUnion(int uid, bool distinct, SingleQuery *single_query,
                std::vector<Symbol> union_symbols)
        : Tree(uid),
          single_query_(single_query),
          distinct_(distinct),
          union_symbols_(union_symbols) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class query (tree)
  ()
  (:abstractp t)
  (:public
    #>cpp
    Query() = default;

    virtual Query *Clone(AstStorage &storage) const = 0;
    cpp<#)
  (:protected
    #>cpp
    explicit Query(int uid) : Tree(uid) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class cypher-query (query)
  ((single-query "SingleQuery *" :initval "nullptr" :scope :public
                 :capnp-type "Tree" :capnp-init nil
                 :capnp-save #'save-ast-pointer
                 :capnp-load (load-ast-pointer "SingleQuery *")
                 :documentation "First and potentially only query.")
   (cypher-unions "std::vector<CypherUnion *>"
                  :scope :public
                  :capnp-type "List(Tree)"
                  :capnp-save (save-ast-vector "CypherUnion *")
                  :capnp-load (load-ast-vector "CypherUnion *")
                  :documentation "Contains remaining queries that should form and union with `single_query_`."))
  (:public
    #>cpp
    CypherQuery() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        bool should_continue = single_query_->Accept(visitor);
        for (auto *cypher_union : cypher_unions_) {
          if (should_continue) {
            should_continue = cypher_union->Accept(visitor);
          }
        }
      }
      return visitor.PostVisit(*this);
    }

    CypherQuery *Clone(AstStorage &storage) const override {
      auto *cypher_query = storage.Create<CypherQuery>();
      cypher_query->single_query_ = single_query_->Clone(storage);
      for (auto *cypher_union : cypher_unions_) {
        cypher_query->cypher_unions_.push_back(cypher_union->Clone(storage));
      }
      return cypher_query;
    }
    cpp<#)
  (:protected
    #>cpp
    explicit CypherQuery(int uid) : Query(uid) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class explain-query (query)
  ((cypher-query "CypherQuery *" :initval "nullptr" :scope :public
                 :capnp-type "Tree" :capnp-init nil
                 :capnp-save #'save-ast-pointer
                 :capnp-load (load-ast-pointer "CypherQuery *")
                 :documentation "CypherQuery to be explained."))
  (:public
    #>cpp
    ExplainQuery() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        cypher_query_->Accept(visitor);
      }
      return visitor.PostVisit(*this);
    }

    ExplainQuery *Clone(AstStorage &storage) const override {
      auto *explain_query = storage.Create<ExplainQuery>();
      explain_query->cypher_query_ = cypher_query_->Clone(storage);
      return explain_query;
    }
    cpp<#)
  (:protected
    #>cpp
    explicit ExplainQuery(int uid) : Query(uid) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class index-query (query)
  ((action "Action" :scope :public)
   (label "storage::Label" :scope :public)
   (properties "std::vector<storage::Property>" :scope :public
               :capnp-save (lcp:capnp-save-vector "storage::capnp::Common" "storage::Property")
               :capnp-load (lcp:capnp-load-vector "storage::capnp::Common" "storage::Property")))
  (:public
   (lcp:define-enum action
       (create create-unique drop)
     (:serialize :capnp))

    #>cpp
    IndexQuery() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    DEFVISITABLE(HierarchicalTreeVisitor);

    IndexQuery *Clone(AstStorage &storage) const override {
      return storage.Create<IndexQuery>(action_, label_, properties_);
    }
  cpp<#)
  (:protected
    #>cpp
    explicit IndexQuery(int uid) : Query(uid) {}
    IndexQuery(int uid, Action action, storage::Label label,
               std::vector<storage::Property> properties)
        : Query(uid), action_(action), label_(label), properties_(properties) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class create (clause)
  ((patterns "std::vector<Pattern *>"
             :scope :public
             :capnp-type "List(Tree)"
             :capnp-save (save-ast-vector "Pattern *")
             :capnp-load (load-ast-vector "Pattern *")))
  (:public
    #>cpp
    Create() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        for (auto &pattern : patterns_) {
          if (!pattern->Accept(visitor)) break;
        }
      }
      return visitor.PostVisit(*this);
    }

    Create *Clone(AstStorage &storage) const override {
      auto *create = storage.Create<Create>();
      for (auto *pattern : patterns_) {
        create->patterns_.push_back(pattern->Clone(storage));
      }
      return create;
    }
    cpp<#)
  (:protected
    #>cpp
    explicit Create(int uid) : Clause(uid) {}
    Create(int uid, std::vector<Pattern *> patterns)
        : Clause(uid), patterns_(patterns) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class match (clause)
  ((patterns "std::vector<Pattern *>"
             :scope :public
             :capnp-type "List(Tree)"
             :capnp-save (save-ast-vector "Pattern *")
             :capnp-load (load-ast-vector "Pattern *"))
   (where "Where *" :initval "nullptr" :scope :public
          :capnp-type "Tree" :capnp-init nil
          :capnp-save #'save-ast-pointer
          :capnp-load (load-ast-pointer "Where *"))
   (optional :bool :initval "false" :scope :public))
  (:public
    #>cpp
    Match() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        bool cont = true;
        for (auto &pattern : patterns_) {
          if (!pattern->Accept(visitor)) {
            cont = false;
            break;
          }
        }
        if (cont && where_) {
          where_->Accept(visitor);
        }
      }
      return visitor.PostVisit(*this);
    }

    Match *Clone(AstStorage &storage) const override {
      auto *match = storage.Create<Match>(optional_);
      for (auto *pattern : patterns_) {
        match->patterns_.push_back(pattern->Clone(storage));
      }
      match->where_ = where_ ? where_->Clone(storage) : nullptr;
      return match;
    }
    cpp<#)
  (:protected
    #>cpp
    explicit Match(int uid) : Clause(uid) {}
    Match(int uid, bool optional) : Clause(uid), optional_(optional) {}
    Match(int uid, bool optional, Where *where, std::vector<Pattern *> patterns)
        : Clause(uid), patterns_(patterns), where_(where), optional_(optional) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-enum ordering
                 (asc desc)
                 (:documentation "Defines the order for sorting values (ascending or descending).")
                 (:serialize :capnp))

(lcp:define-struct sort-item ()
  ((ordering "Ordering")
   (expression "Expression *"
               :capnp-type "Tree" :capnp-init nil
               :capnp-save #'save-ast-pointer
               :capnp-load (load-ast-pointer "Expression *")))
  (:serialize :capnp
              :save-args '((saved-uids "std::vector<int32_t> *"))
              :load-args '((storage "AstStorage *")
                           (loaded-uids "std::vector<int32_t> *"))))

(lcp:define-struct return-body ()
  ((distinct :bool :initval "false"
             :documentation "True if distinct results should be produced.")
   (all-identifiers :bool :initval "false"
                    :documentation "True if asterisk was found in the return body.")
   (named-expressions "std::vector<NamedExpression *>"
                      :capnp-type "List(Tree)"
                      :capnp-save (save-ast-vector "NamedExpression *")
                      :capnp-load (load-ast-vector "NamedExpression *")
                      :documentation "Expressions which are used to produce results.")
   (order-by "std::vector<SortItem>"
             :capnp-save (lcp:capnp-save-vector
                           "capnp::SortItem"
                           "SortItem"
                           "[saved_uids](auto *builder, const auto &val) {
                              Save(val, builder, saved_uids);
                            }")
             :capnp-load (lcp:capnp-load-vector
                           "capnp::SortItem"
                           "SortItem"
                           "[storage, loaded_uids](const auto &reader) {
                             SortItem val;
                             Load(&val, reader, storage, loaded_uids);
                             return val;
                            }")
             :documentation "Expressions used for ordering the results.")
   (skip "Expression *" :initval "nullptr"
         :capnp-type "Tree" :capnp-init nil
         :capnp-save #'save-ast-pointer
         :capnp-load (load-ast-pointer "Expression *")
         :documentation "Optional expression on how many results to skip.")
   (limit "Expression *" :initval "nullptr"
          :capnp-type "Tree" :capnp-init nil
          :capnp-save #'save-ast-pointer
          :capnp-load (load-ast-pointer "Expression *")
          :documentation "Optional expression on how many results to produce."))
  (:documentation "Contents common to @c Return and @c With clauses.")
  (:serialize :capnp
              :save-args '((saved-uids "std::vector<int32_t> *"))
              :load-args '((storage "AstStorage *")
                           (loaded-uids "std::vector<int32_t> *"))))

#>cpp
// Deep copy ReturnBody.
// TODO: Think about turning ReturnBody to class and making this
// function class member.
ReturnBody CloneReturnBody(AstStorage &storage, const ReturnBody &body);
cpp<#

(lcp:define-class return (clause)
  ((body "ReturnBody" :scope :public))
  (:public
    #>cpp
    Return() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        bool cont = true;
        for (auto &expr : body_.named_expressions) {
          if (!expr->Accept(visitor)) {
            cont = false;
            break;
          }
        }
        if (cont) {
          for (auto &order_by : body_.order_by) {
            if (!order_by.expression->Accept(visitor)) {
              cont = false;
              break;
            }
          }
        }
        if (cont && body_.skip) cont = body_.skip->Accept(visitor);
        if (cont && body_.limit) cont = body_.limit->Accept(visitor);
      }
      return visitor.PostVisit(*this);
    }

    Return *Clone(AstStorage &storage) const override {
      auto *ret = storage.Create<Return>();
      ret->body_ = CloneReturnBody(storage, body_);
      return ret;
    }
    cpp<#)
  (:protected
    #>cpp
    explicit Return(int uid) : Clause(uid) {}
    Return(int uid, ReturnBody &body) : Clause(uid), body_(body) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class with (clause)
  ((body "ReturnBody" :scope :public)
   (where "Where *" :initval "nullptr" :scope :public
          :capnp-type "Tree" :capnp-init nil
          :capnp-save #'save-ast-pointer
          :capnp-load (load-ast-pointer "Where *")))
  (:public
    #>cpp
    With() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        bool cont = true;
        for (auto &expr : body_.named_expressions) {
          if (!expr->Accept(visitor)) {
            cont = false;
            break;
          }
        }
        if (cont) {
          for (auto &order_by : body_.order_by) {
            if (!order_by.expression->Accept(visitor)) {
              cont = false;
              break;
            }
          }
        }
        if (cont && where_) cont = where_->Accept(visitor);
        if (cont && body_.skip) cont = body_.skip->Accept(visitor);
        if (cont && body_.limit) cont = body_.limit->Accept(visitor);
      }
      return visitor.PostVisit(*this);
    }

    With *Clone(AstStorage &storage) const override {
      auto *with = storage.Create<With>();
      with->body_ = CloneReturnBody(storage, body_);
      with->where_ = where_ ? where_->Clone(storage) : nullptr;
      return with;
    }
    cpp<#)
  (:protected
    #>cpp
    explicit With(int uid) : Clause(uid) {}
    With(int uid, ReturnBody &body, Where *where)
        : Clause(uid), body_(body), where_(where) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class delete (clause)
  ((expressions "std::vector<Expression *>"
                :capnp-type "List(Tree)"
                :capnp-save (save-ast-vector "Expression *")
                :capnp-load (load-ast-vector "Expression *")
                :scope :public)
   (detach :bool :initval "false" :scope :public))
  (:public
    #>cpp
    Delete() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        for (auto &expr : expressions_) {
          if (!expr->Accept(visitor)) break;
        }
      }
      return visitor.PostVisit(*this);
    }

    Delete *Clone(AstStorage &storage) const override {
      auto *del = storage.Create<Delete>();
      for (auto *expression : expressions_) {
        del->expressions_.push_back(expression->Clone(storage));
      }
      del->detach_ = detach_;
      return del;
    }
    cpp<#)
  (:protected
    #>cpp
    explicit Delete(int uid) : Clause(uid) {}
    Delete(int uid, bool detach, std::vector<Expression *> expressions)
        : Clause(uid), expressions_(expressions), detach_(detach) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class set-property (clause)
  ((property-lookup "PropertyLookup *" :initval "nullptr" :scope :public
                    :capnp-type "Tree" :capnp-init nil
                    :capnp-save #'save-ast-pointer
                    :capnp-load (load-ast-pointer "PropertyLookup *"))
   (expression "Expression *" :initval "nullptr" :scope :public
               :capnp-type "Tree" :capnp-init nil
               :capnp-save #'save-ast-pointer
               :capnp-load (load-ast-pointer "Expression *")))
  (:public
    #>cpp
    SetProperty() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        property_lookup_->Accept(visitor) && expression_->Accept(visitor);
      }
      return visitor.PostVisit(*this);
    }

    SetProperty *Clone(AstStorage &storage) const override {
      return storage.Create<SetProperty>(property_lookup_->Clone(storage),
                                         expression_->Clone(storage));
    }
    cpp<#)
  (:protected
    #>cpp
    explicit SetProperty(int uid) : Clause(uid) {}
    SetProperty(int uid, PropertyLookup *property_lookup, Expression *expression)
        : Clause(uid),
          property_lookup_(property_lookup),
          expression_(expression) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class set-properties (clause)
  ((identifier "Identifier *" :initval "nullptr" :scope :public
               :capnp-type "Tree" :capnp-init nil
               :capnp-save #'save-ast-pointer
               :capnp-load (load-ast-pointer "Identifier *"))
   (expression "Expression *" :initval "nullptr" :scope :public
               :capnp-type "Tree" :capnp-init nil
               :capnp-save #'save-ast-pointer
               :capnp-load (load-ast-pointer "Expression *"))
   (update :bool :initval "false" :scope :public))
  (:public
    #>cpp
    SetProperties() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        identifier_->Accept(visitor) && expression_->Accept(visitor);
      }
      return visitor.PostVisit(*this);
    }

    SetProperties *Clone(AstStorage &storage) const override {
      return storage.Create<SetProperties>(identifier_->Clone(storage),
                                           expression_->Clone(storage), update_);
    }
    cpp<#)
  (:protected
    #>cpp
    explicit SetProperties(int uid) : Clause(uid) {}
    SetProperties(int uid, Identifier *identifier, Expression *expression,
                  bool update = false)
        : Clause(uid),
          identifier_(identifier),
          expression_(expression),
          update_(update) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class set-labels (clause)
  ((identifier "Identifier *" :initval "nullptr" :scope :public
               :capnp-type "Tree" :capnp-init nil
               :capnp-save #'save-ast-pointer
               :capnp-load (load-ast-pointer "Identifier *"))
   (labels "std::vector<storage::Label>" :scope :public
           :capnp-save (lcp:capnp-save-vector
                         "storage::capnp::Common"
                         "storage::Label")
           :capnp-load (lcp:capnp-load-vector
                         "storage::capnp::Common"
                         "storage::Label")))
  (:public
    #>cpp
    SetLabels() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        identifier_->Accept(visitor);
      }
      return visitor.PostVisit(*this);
    }

    SetLabels *Clone(AstStorage &storage) const override {
      return storage.Create<SetLabels>(identifier_->Clone(storage), labels_);
    }
    cpp<#)
  (:protected
    #>cpp
    explicit SetLabels(int uid) : Clause(uid) {}
    SetLabels(int uid, Identifier *identifier,
              const std::vector<storage::Label> &labels)
        : Clause(uid), identifier_(identifier), labels_(labels) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class remove-property (clause)
  ((property-lookup "PropertyLookup *" :initval "nullptr" :scope :public
                    :capnp-type "Tree" :capnp-init nil
                    :capnp-save #'save-ast-pointer
                    :capnp-load (load-ast-pointer "PropertyLookup *")))
  (:public
    #>cpp
    RemoveProperty() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        property_lookup_->Accept(visitor);
      }
      return visitor.PostVisit(*this);
    }

    RemoveProperty *Clone(AstStorage &storage) const override {
      return storage.Create<RemoveProperty>(property_lookup_->Clone(storage));
    }
    cpp<#)
  (:protected
    #>cpp
    explicit RemoveProperty(int uid) : Clause(uid) {}
    RemoveProperty(int uid, PropertyLookup *property_lookup)
        : Clause(uid), property_lookup_(property_lookup) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class remove-labels (clause)
  ((identifier "Identifier *" :initval "nullptr" :scope :public
               :capnp-type "Tree" :capnp-init nil
               :capnp-save #'save-ast-pointer
               :capnp-load (load-ast-pointer "Identifier *"))
   (labels "std::vector<storage::Label>" :scope :public
           :capnp-save (lcp:capnp-save-vector
                         "storage::capnp::Common"
                         "storage::Label")
           :capnp-load (lcp:capnp-load-vector
                         "storage::capnp::Common"
                         "storage::Label")))
  (:public
    #>cpp
    RemoveLabels() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        identifier_->Accept(visitor);
      }
      return visitor.PostVisit(*this);
    }

    RemoveLabels *Clone(AstStorage &storage) const override {
      return storage.Create<RemoveLabels>(identifier_->Clone(storage), labels_);
    }
    cpp<#)
  (:protected
    #>cpp
    explicit RemoveLabels(int uid) : Clause(uid) {}
    RemoveLabels(int uid, Identifier *identifier,
                 const std::vector<storage::Label> &labels)
        : Clause(uid), identifier_(identifier), labels_(labels) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class merge (clause)
  ((pattern "Pattern *" :initval "nullptr" :scope :public
            :capnp-type "Tree" :capnp-init nil
            :capnp-save #'save-ast-pointer
            :capnp-load (load-ast-pointer "Pattern *"))
   (on-match "std::vector<Clause *>"
             :scope :public
             :capnp-type "List(Tree)"
             :capnp-save (save-ast-vector "Clause *")
             :capnp-load (load-ast-vector "Clause *"))
   (on-create "std::vector<Clause *>"
              :scope :public
              :capnp-type "List(Tree)"
              :capnp-save (save-ast-vector "Clause *")
              :capnp-load (load-ast-vector "Clause *")))
  (:public
    #>cpp
    Merge() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        bool cont = pattern_->Accept(visitor);
        if (cont) {
          for (auto &set : on_match_) {
            if (!set->Accept(visitor)) {
              cont = false;
              break;
            }
          }
        }
        if (cont) {
          for (auto &set : on_create_) {
            if (!set->Accept(visitor)) {
              cont = false;
              break;
            }
          }
        }
      }
      return visitor.PostVisit(*this);
    }

    Merge *Clone(AstStorage &storage) const override {
      auto *merge = storage.Create<Merge>();
      merge->pattern_ = pattern_->Clone(storage);
      for (auto *on_match : on_match_) {
        merge->on_match_.push_back(on_match->Clone(storage));
      }
      for (auto *on_create : on_create_) {
        merge->on_create_.push_back(on_create->Clone(storage));
      }
      return merge;
    }
    cpp<#)
  (:protected
    #>cpp
    explicit Merge(int uid) : Clause(uid) {}
    Merge(int uid, Pattern *pattern, std::vector<Clause *> on_match,
          std::vector<Clause *> on_create)
        : Clause(uid),
          pattern_(pattern),
          on_match_(on_match),
          on_create_(on_create) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class unwind (clause)
  ((named-expression "NamedExpression *" :initval "nullptr" :scope :public
                     :capnp-type "Tree" :capnp-init nil
                     :capnp-save #'save-ast-pointer
                     :capnp-load (load-ast-pointer "NamedExpression *")))
  (:public
    #>cpp
    Unwind() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    bool Accept(HierarchicalTreeVisitor &visitor) override {
      if (visitor.PreVisit(*this)) {
        named_expression_->Accept(visitor);
      }
      return visitor.PostVisit(*this);
    }

    Unwind *Clone(AstStorage &storage) const override {
      return storage.Create<Unwind>(named_expression_->Clone(storage));
    }
    cpp<#)
  (:protected
    #>cpp
    explicit Unwind(int uid) : Clause(uid) {}

    Unwind(int uid, NamedExpression *named_expression)
        : Clause(uid), named_expression_(named_expression) {
      DCHECK(named_expression)
          << "Unwind cannot take nullptr for named_expression";
    }
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

(lcp:define-class auth-query (query)
  ((action "Action" :scope :public)
   (user "std::string" :scope :public)
   (role "std::string" :scope :public)
   (user-or-role "std::string" :scope :public)
   (password "Expression *" :initval "nullptr" :scope :public
             :capnp-type "Tree" :capnp-init nil
             :capnp-save #'save-ast-pointer
             :capnp-load (load-ast-pointer "Expression *"))
   (privileges "std::vector<Privilege>" :scope :public))
  (:public
    (lcp:define-enum action
                     (create-role drop-role show-roles create-user
                      set-password drop-user show-users set-role
                      clear-role grant-privilege deny-privilege
                      revoke-privilege show-privileges
                      show-role-for-user show-users-for-role)
                     (:serialize :capnp))
    (lcp:define-enum privilege
                     (create delete match merge set remove index auth stream)
                     (:serialize :capnp))
    #>cpp
    AuthQuery() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    DEFVISITABLE(HierarchicalTreeVisitor);

    AuthQuery *Clone(AstStorage &storage) const override {
      return storage.Create<AuthQuery>(
          action_, user_, role_, user_or_role_,
          password_ ? password_->Clone(storage) : nullptr, privileges_);
    }
    cpp<#)
  (:protected
    #>cpp
    explicit AuthQuery(int uid) : Query(uid) {}

    explicit AuthQuery(int uid, Action action, std::string user, std::string role,
                       std::string user_or_role, Expression *password,
                       std::vector<Privilege> privileges)
        : Query(uid),
          action_(action),
          user_(user),
          role_(role),
          user_or_role_(user_or_role),
          password_(password),
          privileges_(privileges) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

#>cpp
// Constant that holds all available privileges.
const std::vector<AuthQuery::Privilege> kPrivilegesAll = {
    AuthQuery::Privilege::CREATE, AuthQuery::Privilege::DELETE,
    AuthQuery::Privilege::MATCH,  AuthQuery::Privilege::MERGE,
    AuthQuery::Privilege::SET,    AuthQuery::Privilege::REMOVE,
    AuthQuery::Privilege::INDEX,  AuthQuery::Privilege::AUTH,
    AuthQuery::Privilege::STREAM};
cpp<#

(lcp:define-class stream-query (query)
  ((action "Action" :scope :public)
   (stream-name "std::string" :scope :public)
   (stream-uri "Expression *" :scope :public :initval "nullptr"
               :capnp-type "Tree" :capnp-init nil
               :capnp-save #'save-ast-pointer
               :capnp-load (load-ast-pointer "Expression *"))
   (stream-topic "Expression *" :scope :public :initval "nullptr"
                 :capnp-type "Tree" :capnp-init nil
                 :capnp-save #'save-ast-pointer
                 :capnp-load (load-ast-pointer "Expression *"))
   (transform-uri "Expression *" :scope :public :initval "nullptr"
                  :capnp-type "Tree" :capnp-init nil
                  :capnp-save #'save-ast-pointer
                  :capnp-load (load-ast-pointer "Expression *"))
   (batch-interval-in-ms "Expression *" :scope :public :initval "nullptr"
                         :capnp-type "Tree" :capnp-init nil
                         :capnp-save #'save-ast-pointer
                         :capnp-load (load-ast-pointer "Expression *"))
   (batch-size "Expression *" :scope :public :initval "nullptr"
               :capnp-type "Tree" :capnp-init nil
               :capnp-save #'save-ast-pointer
               :capnp-load (load-ast-pointer "Expression *"))
   (limit-batches "Expression *" :scope :public :initval "nullptr"
                  :capnp-type "Tree" :capnp-init nil
                  :capnp-save #'save-ast-pointer
                  :capnp-load (load-ast-pointer "Expression *")))
  (:public
    (lcp:define-enum action (create-stream drop-stream show-streams start-stream
                             stop-stream start-all-streams stop-all-streams test-stream)
                     (:serialize :capnp))

    #>cpp
    StreamQuery() = default;

    DEFVISITABLE(TreeVisitor<TypedValue>);
    DEFVISITABLE(HierarchicalTreeVisitor);

    StreamQuery *Clone(AstStorage &storage) const override {
      auto *stream_uri = stream_uri_ ? stream_uri_->Clone(storage) : nullptr;
      auto *stream_topic = stream_topic_ ? stream_topic_->Clone(storage) : nullptr;
      auto *transform_uri =
          transform_uri_ ? transform_uri_->Clone(storage) : nullptr;
      auto *batch_interval_in_ms =
          batch_interval_in_ms_ ? batch_interval_in_ms_->Clone(storage) : nullptr;
      auto *batch_size = batch_size_ ? batch_size_->Clone(storage) : nullptr;
      auto *limit_batches =
          limit_batches_ ? limit_batches_->Clone(storage) : nullptr;
      return storage.Create<StreamQuery>(
          action_, stream_name_, stream_uri, stream_topic, transform_uri,
          batch_interval_in_ms, batch_size, limit_batches);
    }
    cpp<#)
  (:protected
    #>cpp
    StreamQuery(int uid) : Query(uid) {}
    StreamQuery(int uid, Action action, std::string stream_name,
                Expression *stream_uri, Expression *stream_topic,
                Expression *transform_uri, Expression *batch_interval_in_ms,
                Expression *batch_size, Expression *limit_batches)
        : Query(uid),
          action_(action),
          stream_name_(std::move(stream_name)),
          stream_uri_(stream_uri),
          stream_topic_(stream_topic),
          transform_uri_(transform_uri),
          batch_interval_in_ms_(batch_interval_in_ms),
          batch_size_(batch_size),
          limit_batches_(limit_batches) {}
    cpp<#)
  (:private
    #>cpp
    friend class AstStorage;
    cpp<#)
  (:serialize :capnp))

#>cpp
#undef CLONE_BINARY_EXPRESSION
#undef CLONE_UNARY_EXPRESSION
cpp<#

(lcp:pop-namespace) ;; namespace query
