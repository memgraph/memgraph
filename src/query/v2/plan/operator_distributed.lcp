;; Copyright 2022 Memgraph Ltd.
;;
;; Use of this software is governed by the Business Source License
;; included in the file licenses/BSL.txt; by using this file, you agree to be bound by the terms of the Business Source
;; License, and you may not use this file except in compliance with the Business Source License.
;;
;; As of the Change Date specified in that file, in accordance with
;; the Business Source License, use of this software will be governed
;; by the Apache License, Version 2.0, included in the file
;; licenses/APL.txt.

#>cpp
/** @file */

#pragma once

#include <algorithm>
#include <vector>

#include "query/v2/common.hpp"
cpp<#

(lcp:namespace memgraph)
(lcp:namespace query)
(lcp:namespace v2)
#>cpp
struct ExecutionContext;
class ExpressionEvaluator;
class MultiFrame;
class SymbolTable;
cpp<#

(lcp:pop-namespace) ;; v2
(lcp:pop-namespace) ;; query
(lcp:pop-namespace) ;; memgraph

(lcp:namespace memgraph)
(lcp:namespace query)
(lcp:namespace v2)
(lcp:namespace plan)
(lcp:namespace distributed)

#>cpp

/// Base class for iteration cursors of @c LogicalOperator classes.
///
/// Each @c LogicalOperator must produce a concrete @c Cursor, which provides
/// the iteration mechanism.
class Cursor {
 public:
  /// Run an iteration of a @c LogicalOperator.
  ///
  /// Since operators may be chained, the iteration may pull results from
  /// multiple operators.
  ///
  /// @param Frame May be read from or written to while performing the
  ///     iteration.
  /// @param ExecutionContext Used to get the position of symbols in frame and
  ///     other information.
  ///
  /// @throws QueryRuntimeException if something went wrong with execution
  virtual bool Pull(MultiFrame &, ExecutionContext &) = 0;

  /// Resets the Cursor to its initial state.
  virtual void Reset() = 0;

  /// Perform cleanup which may throw an exception
  virtual void Shutdown() = 0;

  virtual ~Cursor() {}
};

/// unique_ptr to Cursor managed with a custom deleter.
/// This allows us to use utils::MemoryResource for allocation.
using UniqueCursorPtr = std::unique_ptr<Cursor, std::function<void(Cursor *)>>;

class Once;
class ScanAll;
class ScanAllByLabel;
class ScanAllByLabelPropertyValue;
class ScanAllById;
class Expand;
class Distinct;
class Produce;
class Unwind;
class Filter;

using LogicalOperatorCompositeVisitor =
    utils::CompositeVisitor<Once, ScanAll, ScanAllByLabel, ScanAllByLabelPropertyValue, ScanAllById, Expand, Distinct, Filter, Produce, Unwind>;

using LogicalOperatorLeafVisitor = utils::LeafVisitor<Once>;

/**
 * @brief Base class for hierarhical visitors of @c LogicalOperator class
 * hierarchy.
 */
class HierarchicalLogicalOperatorVisitor
    : public LogicalOperatorCompositeVisitor,
      public LogicalOperatorLeafVisitor {
 public:
  using LogicalOperatorCompositeVisitor::PostVisit;
  using LogicalOperatorCompositeVisitor::PreVisit;
  using LogicalOperatorLeafVisitor::Visit;
  using typename LogicalOperatorLeafVisitor::ReturnType;
};
cpp<#

(lcp:define-class logical-operator ("utils::Visitable<HierarchicalLogicalOperatorVisitor>")
  ()
  (:abstractp t)
  (:documentation
   "Base class for logical operators.

Each operator describes an operation, which is to be performed on the
database. Operators are iterated over using a @c Cursor. Various operators
can serve as inputs to others and thus a sequence of operations is formed.")
  (:public
   #>cpp
   virtual ~LogicalOperator() {}

   /** Construct a @c Cursor which is used to run this operator.
    *
    * @param utils::MemoryResource Memory resource used for allocations during
    *     the lifetime of the returned Cursor.
    */
   virtual UniqueCursorPtr MakeCursor(utils::MemoryResource *) const = 0;

   /** Return @c Symbol vector where the query results will be stored.
    *
    * Currently, output symbols are generated in @c Produce @c Union and
    * @c CallProcedure operators. @c Skip, @c Limit, @c OrderBy and @c Distinct
    * propagate the symbols from @c Produce (if it exists as input operator).
    *
    *  @param SymbolTable used to find symbols for expressions.
    *  @return std::vector<Symbol> used for results.
    */
   virtual std::vector<Symbol> OutputSymbols(const SymbolTable &) const {
     return std::vector<Symbol>();
   }

   /**
    * Symbol vector whose values are modified by this operator sub-tree.
    *
    * This is different than @c OutputSymbols, because it returns all of the
    * modified symbols, including those that may not be returned as the
    * result of the query. Note that the modified symbols will not contain
    * those that should not be read after the operator is processed.
    *
    * For example, `MATCH (n)-[e]-(m) RETURN n AS l` will generate `ScanAll (n) >
    * Expand (e, m) > Produce (l)`. The modified symbols on Produce sub-tree will
    * be `l`, the same as output symbols, because it isn't valid to read `n`, `e`
    * nor `m` after Produce. On the other hand, modified symbols from Expand
    * contain `e` and `m`, as well as `n`, while output symbols are empty.
    * Modified symbols from ScanAll contain only `n`, while output symbols are
    * also empty.
    */
   virtual std::vector<Symbol> ModifiedSymbols(const SymbolTable &) const = 0;

   /**
    * Returns true if the operator takes only one input operator.
    * NOTE: When this method returns true, you may use `input` and `set_input`
    * methods.
    */
   virtual bool HasSingleInput() const = 0;

   /**
    * Returns the input operator if it has any.
    * NOTE: This should only be called if `HasSingleInput() == true`.
    */
   virtual std::shared_ptr<LogicalOperator> input() const = 0;
   /**
    * Set a different input on this operator.
    * NOTE: This should only be called if `HasSingleInput() == true`.
    */
   virtual void set_input(std::shared_ptr<LogicalOperator>) = 0;

   struct SaveHelper {
     std::vector<LogicalOperator *> saved_ops;
   };

   struct LoadHelper {
     AstStorage ast_storage;
     std::vector<std::pair<uint64_t, std::shared_ptr<LogicalOperator>>>
         loaded_ops;
   };

   struct SlkLoadHelper {
     AstStorage ast_storage;
     std::vector<std::shared_ptr<LogicalOperator>> loaded_ops;
   };

   virtual void PerformFullEnumeration() {
    if (HasSingleInput()) {
      input()->PerformFullEnumeration();
      }
    } // #NoCommit =0 by default? only temporary so peers can work: all operators should implement it, perhaps it's not only about ScanAll
   cpp<#)
  (:serialize
   (:slk :base t
         :save-args '((helper "query::v2::plan::LogicalOperator::SaveHelper *"))
         :load-args '((helper "query::v2::plan::LogicalOperator::SlkLoadHelper *"))))
  (:type-info :base t)
  (:clone :args '((storage "AstStorage *"))
          :base t))

(defun slk-save-ast-pointer (member)
  #>cpp
  query::v2::SaveAstPointer(self.${member}, builder);
  cpp<#)

(defun slk-load-ast-pointer (type)
  (lambda (member)
    #>cpp
    self->${member} = query::v2::LoadAstPointer<query::v2::${type}>(
        &helper->ast_storage, reader);
    cpp<#))

(defun slk-save-ast-vector (member)
  #>cpp
  size_t size = self.${member}.size();
  slk::Save(size, builder);
  for (const auto *val : self.${member}) {
    query::v2::SaveAstPointer(val, builder);
  }
  cpp<#)

(defun slk-load-ast-vector (type)
  (lambda (member)
    #>cpp
    size_t size = 0;
    slk::Load(&size, reader);
    self->${member}.resize(size);
    for (size_t i = 0;
         i < size;
         ++i) {
      self->${member}[i] = query::v2::LoadAstPointer<query::v2::${type}>(
          &helper->ast_storage, reader);
    }
    cpp<#))

(defun slk-save-operator-pointer (member)
  #>cpp
  slk::Save<query::v2::plan::LogicalOperator>(self.${member}, builder,
                                          &helper->saved_ops,
                                          [&helper](const auto &val,
                                                    auto *builder) {
                                            slk::Save(val, builder, helper);
                                          });
  cpp<#)

(defun slk-load-operator-pointer (member)
  #>cpp
  slk::Load<query::v2::plan::LogicalOperator>(&self->${member}, reader, &helper->loaded_ops,
      [&helper](auto *op, auto *reader) {
        slk::ConstructAndLoad(op, reader, helper);
      });
  cpp<#)

(lcp:define-class once (logical-operator)
  ((symbols "std::vector<Symbol>" :scope :public))
  (:documentation
   "A logical operator whose Cursor returns true on the first Pull
and false on every following Pull.")
  (:public
   #>cpp
   Once(std::vector<Symbol> symbols = {}) : symbols_{std::move(symbols)} {}
   DEFVISITABLE(HierarchicalLogicalOperatorVisitor);
   UniqueCursorPtr MakeCursor(utils::MemoryResource *) const override;
   std::vector<Symbol> ModifiedSymbols(const SymbolTable &) const override {
     return symbols_;
   }

   bool HasSingleInput() const override;
   std::shared_ptr<LogicalOperator> input() const override;
   void set_input(std::shared_ptr<LogicalOperator>) override;
   cpp<#)
  (:private
   #>cpp
   class OnceCursor : public Cursor {
    public:
     OnceCursor() {}
     bool Pull(MultiFrame &, ExecutionContext &) override;
     void Shutdown() override;
     void Reset() override;

    private:
     bool did_pull_{false};
   };
   cpp<#)
  (:serialize (:slk))
  (:clone))

(defun slk-save-properties (member)
  #>cpp
  size_t size = self.${member}.size();
  slk::Save(size, builder);
  for (const auto &kv : self.${member}) {
    slk::Save(kv.first, builder);
    query::v2::SaveAstPointer(kv.second, builder);
  }
  cpp<#)

(defun slk-load-properties (member)
  #>cpp
  size_t size = 0;
  slk::Load(&size, reader);
  self->${member}.resize(size);
  for (size_t i = 0; i < size; ++i) {
    storage::v3::PropertyId prop;
    slk::Load(&prop, reader);
    auto *expr = query::v2::LoadAstPointer<query::v2::Expression>(
        &helper->ast_storage, reader);
    self->${member}[i] = {prop, expr};
  }
  cpp<#)

(defun clone-variant-properties (source destination)
  #>cpp
    if (const auto *props = std::get_if<PropertiesMapList>(&${source})) {
      auto &destination_props = std::get<PropertiesMapList>(${destination});
      destination_props.resize(props->size());
      for (auto i0 = 0; i0 < props->size(); ++i0) {
        {
          storage::v3::PropertyId first1 = (*props)[i0].first;
          Expression *second2;
          second2 = (*props)[i0].second ? (*props)[i0].second->Clone(storage) : nullptr;
          destination_props[i0] = std::make_pair(std::move(first1), std::move(second2));
        }
      }
    } else {
      ${destination} = std::get<ParameterLookup *>(${source})->Clone(storage);
    }
  cpp<#)

(lcp:define-class scan-all (logical-operator)
  ((input "std::shared_ptr<LogicalOperator>" :scope :public
          :slk-save #'slk-save-operator-pointer
          :slk-load #'slk-load-operator-pointer)
   (output-symbol "Symbol" :scope :public)
   (view "::storage::v3::View" :scope :public
         :documentation
         "Controls which graph state is used to produce vertices.

If @c storage::v3::View::OLD, @c ScanAll will produce vertices visible in the
previous graph state, before modifications done by current transaction &
command. With @c storage::v3::View::NEW, all vertices will be produced the current
transaction sees along with their modifications.")
    (perform_full_enumeration "bool" :scope :public))

  (:documentation
   "Operator which iterates over all the nodes currently in the database.
When given an input (optional), does a cartesian product.

It accepts an optional input. If provided then this op scans all the nodes
currently in the database for each successful Pull from it's input, thereby
producing a cartesian product of input Pulls and database elements.

ScanAll can either iterate over the previous graph state (state before
the current transacton+command) or over current state. This is controlled
with a constructor argument.

@sa ScanAllByLabel
@sa ScanAllByLabelPropertyRange
@sa ScanAllByLabelPropertyValue")
  (:public
   #>cpp
   ScanAll() {}
   ScanAll(const std::shared_ptr<LogicalOperator> &input, Symbol output_symbol,
           storage::v3::View view = storage::v3::View::OLD);
   bool Accept(HierarchicalLogicalOperatorVisitor &visitor) override;
   UniqueCursorPtr MakeCursor(utils::MemoryResource *) const override;
   std::vector<Symbol> ModifiedSymbols(const SymbolTable &) const override;

   bool HasSingleInput() const override { return true; }
   std::shared_ptr<LogicalOperator> input() const override { return input_; }
   void set_input(std::shared_ptr<LogicalOperator> input) override {
     input_ = input;
   }
   void PerformFullEnumeration() override;
   cpp<#)
  (:serialize (:slk))
  (:clone))

(lcp:define-class scan-all-by-label (scan-all)
  ((label "::storage::v3::LabelId" :scope :public))
  (:documentation
   "Behaves like @c ScanAll, but this operator produces only vertices with
given label.

@sa ScanAll
@sa ScanAllByLabelPropertyRange
@sa ScanAllByLabelPropertyValue")
  (:public
   #>cpp
   ScanAllByLabel() {}
   ScanAllByLabel(const std::shared_ptr<LogicalOperator> &input,
                  Symbol output_symbol, storage::v3::LabelId label,
                  storage::v3::View view = storage::v3::View::OLD);
   bool Accept(HierarchicalLogicalOperatorVisitor &visitor) override;
   UniqueCursorPtr MakeCursor(utils::MemoryResource *) const override;
   cpp<#)
  (:serialize (:slk))
  (:clone))

(defun slk-save-optional-bound (member)
  #>cpp
  slk::Save(static_cast<bool>(self.${member}), builder);
  if (!self.${member}) {
    return;
  }
  uint8_t bound_type;
  const auto &bound = *self.${member};
  switch (bound.type()) {
    case utils::BoundType::INCLUSIVE:
      bound_type = 0;
      break;
    case utils::BoundType::EXCLUSIVE:
      bound_type = 1;
      break;
  }
  slk::Save(bound_type, builder);
  query::v2::SaveAstPointer(bound.value(), builder);
  cpp<#)

(defun slk-load-optional-bound (member)
  #>cpp
  bool has_bound;
  slk::Load(&has_bound, reader);
  if (!has_bound) {
    self->${member} = std::nullopt;
    return;
  }
  uint8_t bound_type_value;
  slk::Load(&bound_type_value, reader);
  utils::BoundType bound_type;
  switch (bound_type_value) {
    case static_cast<uint8_t>(0):
      bound_type = utils::BoundType::INCLUSIVE;
      break;
    case static_cast<uint8_t>(1):
      bound_type = utils::BoundType::EXCLUSIVE;
      break;
    default:
      throw slk::SlkDecodeException("Loading unknown BoundType");
  }
  auto *value = query::v2::LoadAstPointer<query::v2::Expression>(
      &helper->ast_storage, reader);
  self->${member}.emplace(utils::Bound<query::v2::Expression *>(value, bound_type));
  cpp<#)

(defun clone-optional-bound (source dest)
  #>cpp
  if (${source}) {
    ${dest}.emplace(utils::Bound<Expression *>(
                    ${source}->value()->Clone(storage),
                    ${source}->type()));
  } else {
    ${dest} = std::nullopt;
  }
  cpp<#)

(lcp:define-class scan-all-by-label-property-value (scan-all)
  ((label "::storage::v3::LabelId" :scope :public)
   (property "::storage::v3::PropertyId" :scope :public)
   (property-name "std::string" :scope :public)
   (expression-property-value "Expression *" :scope :public
               :slk-save #'slk-save-ast-pointer
               :slk-load (slk-load-ast-pointer "Expression")))
  (:documentation
   "Behaves like @c ScanAll, but produces only vertices with given label and
property value.

@sa ScanAll
@sa ScanAllByLabel
@sa ScanAllByLabelPropertyRange")
  (:public
   #>cpp
   ScanAllByLabelPropertyValue() {}
   /**
    * Constructs the operator for given label and property value.
    *
    * @param input Preceding operator which will serve as the input.
    * @param output_symbol Symbol where the vertices will be stored.
    * @param label Label which the vertex must have.
    * @param property Property from which the value will be looked up from.
    * @param expression Expression producing the value of the vertex property.
    * @param view storage::v3::View used when obtaining vertices.
    */
   ScanAllByLabelPropertyValue(const std::shared_ptr<LogicalOperator> &input,
                               Symbol output_symbol, storage::v3::LabelId label,
                               storage::v3::PropertyId property,
                               const std::string &property_name,
                               Expression *expression_property_value_,
                               storage::v3::View view = storage::v3::View::OLD);

   bool Accept(HierarchicalLogicalOperatorVisitor &visitor) override;
   UniqueCursorPtr MakeCursor(utils::MemoryResource *) const override;
   cpp<#)
  (:serialize (:slk))
  (:clone))

(lcp:define-class scan-all-by-id (scan-all)
  ((expression-id "Expression *" :scope :public
               :slk-save #'slk-save-ast-pointer
               :slk-load (slk-load-ast-pointer "Expression")))
  (:documentation
    "ScanAll producing a single node with ID equal to evaluated expression")
  (:public
    #>cpp
    ScanAllById() {}
    ScanAllById(const std::shared_ptr<LogicalOperator> &input,
                Symbol output_symbol, Expression *expression_id,
                storage::v3::View view = storage::v3::View::OLD);

    bool Accept(HierarchicalLogicalOperatorVisitor &visitor) override;
    UniqueCursorPtr MakeCursor(utils::MemoryResource *) const override;
    cpp<#)
  (:serialize (:slk))
  (:clone))

(lcp:define-struct expand-common ()
  (
   ;; info on what's getting expanded
   (node-symbol "Symbol"
                :documentation "Symbol pointing to the node to be expanded.
This is where the new node will be stored.")
   (edge-symbol "Symbol"
                :documentation "Symbol for the edges to be expanded.
This is where a TypedValue containing a list of expanded edges will be stored.")
   (direction "::EdgeAtom::Direction"
              :documentation "EdgeAtom::Direction determining the direction of edge
expansion. The direction is relative to the starting vertex for each expansion.")
   (edge-types "std::vector<storage::v3::EdgeTypeId>"
               :documentation "storage::v3::EdgeTypeId specifying which edges we want
to expand. If empty, all edges are valid. If not empty, only edges with one of
the given types are valid.")
   (existing-node :bool :documentation "If the given node atom refer to a symbol
that has already been expanded and should be just validated in the frame."))
  (:serialize (:slk)))

(lcp:define-class expand (logical-operator)
  ((input "std::shared_ptr<LogicalOperator>" :scope :public
          :slk-save #'slk-save-operator-pointer
          :slk-load #'slk-load-operator-pointer)
   (input-symbol "Symbol" :scope :public)
   (common "ExpandCommon" :scope :public)
   (view "::storage::v3::View" :scope :public
         :documentation
         "State from which the input node should get expanded."))
  (:documentation
   "Expansion operator. For a node existing in the frame it
expands one edge and one node and places them on the frame.

This class does not handle node/edge filtering based on
properties, labels and edge types. However, it does handle
filtering on existing node / edge.

Filtering on existing means that for a pattern that references
an already declared node or edge (for example in
MATCH (a) MATCH (a)--(b)),
only expansions that match defined equalities are successfully
pulled.")
  (:public
   #>cpp
   /**
    * Creates an expansion. All parameters except input and input_symbol are
    * forwarded to @c ExpandCommon and are documented there.
    *
    * @param input Optional logical operator that preceeds this one.
    * @param input_symbol Symbol that points to a VertexAccessor in the frame
    *    that expansion should emanate from.
    */
   Expand(const std::shared_ptr<LogicalOperator> &input, Symbol input_symbol,
          Symbol node_symbol, Symbol edge_symbol, EdgeAtom::Direction direction,
          const std::vector<storage::v3::EdgeTypeId> &edge_types, bool existing_node,
          storage::v3::View view);

   Expand() {}

   bool Accept(HierarchicalLogicalOperatorVisitor &visitor) override;
   UniqueCursorPtr MakeCursor(utils::MemoryResource *) const override;
   std::vector<Symbol> ModifiedSymbols(const SymbolTable &) const override;

   bool HasSingleInput() const override { return true; }
   std::shared_ptr<LogicalOperator> input() const override { return input_; }
   void set_input(std::shared_ptr<LogicalOperator> input) override {
     input_ = input;
   }

   class ExpandCursor : public Cursor {
    public:
     ExpandCursor(const Expand &, utils::MemoryResource *);
     bool Pull(MultiFrame &, ExecutionContext &) override;
     void Shutdown() override;
     void Reset() override;

    private:
     using InEdgeT = std::remove_reference_t<decltype(
         *std::declval<VertexAccessor>().InEdges(storage::v3::View::OLD))>;
     using InEdgeIteratorT = decltype(std::declval<InEdgeT>().begin());
     using OutEdgeT = std::remove_reference_t<decltype(
         *std::declval<VertexAccessor>().OutEdges(storage::v3::View::OLD))>;
     using OutEdgeIteratorT = decltype(std::declval<OutEdgeT>().begin());

     const Expand &self_;
     const UniqueCursorPtr input_cursor_;

     // The iterable over edges and the current edge iterator are referenced via
     // optional because they can not be initialized in the constructor of
     // this class. They are initialized once for each pull from the input.

    struct InEdge{
      InEdgeT in_edges_;
      InEdgeIteratorT in_edges_it_;
    };
    struct OutEdge{
      OutEdgeT out_edges_;
      OutEdgeIteratorT out_edges_it_;
    };
    struct InOutEdges {
      std::optional<InEdge> in_;
      std::optional<OutEdge> out_;
    };

    std::vector<InOutEdges> in_out_edges; // #NoCommit pmr vector

    bool InitEdges(MultiFrame &, ExecutionContext &);
   };
   cpp<#)
  (:serialize (:slk))
  (:clone))

(lcp:define-class distinct (logical-operator)
  ((input "std::shared_ptr<LogicalOperator>" :scope :public
          :slk-save #'slk-save-operator-pointer
          :slk-load #'slk-load-operator-pointer)
   (value-symbols "std::vector<Symbol>" :scope :public))
  (:documentation
   "Ensures that only distinct rows are yielded.
This implementation accepts a vector of Symbols
which define a row. Only those Symbols are valid
for use in operators following Distinct.

This implementation maintains input ordering.")
  (:public
   #>cpp
   Distinct() {}

   Distinct(const std::shared_ptr<LogicalOperator> &input,
            const std::vector<Symbol> &value_symbols);
   bool Accept(HierarchicalLogicalOperatorVisitor &visitor) override;
   UniqueCursorPtr MakeCursor(utils::MemoryResource *) const override;
   std::vector<Symbol> OutputSymbols(const SymbolTable &) const override;
   std::vector<Symbol> ModifiedSymbols(const SymbolTable &) const override;

   bool HasSingleInput() const override { return true; }
   std::shared_ptr<LogicalOperator> input() const override { return input_; }
   void set_input(std::shared_ptr<LogicalOperator> input) override {
     input_ = input;
   }
   cpp<#)
  (:serialize (:slk))
  (:clone))

(lcp:define-class produce (logical-operator)
  ((input "std::shared_ptr<LogicalOperator>" :scope :public
          :slk-save #'slk-save-operator-pointer
          :slk-load #'slk-load-operator-pointer)
   (named-expressions "std::vector<NamedExpression *>" :scope :public
                      :slk-save #'slk-save-ast-vector
                      :slk-load (slk-load-ast-vector "NamedExpression")))
  (:documentation
   "A logical operator that places an arbitrary number
of named expressions on the frame (the logical operator
for the RETURN clause).

Supports optional input. When the input is provided,
it is Pulled from and the Produce succeeds once for
every input Pull (typically a MATCH/RETURN query).
When the input is not provided (typically a standalone
RETURN clause) the Produce's pull succeeds exactly once.")
  (:public
   #>cpp
   Produce() {}

   Produce(const std::shared_ptr<LogicalOperator> &input,
           const std::vector<NamedExpression *> &named_expressions);
   bool Accept(HierarchicalLogicalOperatorVisitor &visitor) override;
   UniqueCursorPtr MakeCursor(utils::MemoryResource *) const override;
   std::vector<Symbol> OutputSymbols(const SymbolTable &) const override;
   std::vector<Symbol> ModifiedSymbols(const SymbolTable &) const override;

   bool HasSingleInput() const override { return true; }
   std::shared_ptr<LogicalOperator> input() const override { return input_; }
   void set_input(std::shared_ptr<LogicalOperator> input) override {
     input_ = input;
   }
   cpp<#)
  (:private
   #>cpp
   class ProduceCursor : public Cursor {
    public:
     ProduceCursor(const Produce &, utils::MemoryResource *);
     bool Pull(MultiFrame &, ExecutionContext &) override;
     void Shutdown() override;
     void Reset() override;

    private:
     const Produce &self_;
     const UniqueCursorPtr input_cursor_;
   };
   cpp<#)
  (:serialize (:slk))
  (:clone))

(lcp:define-class unwind (logical-operator)
  ((input "std::shared_ptr<LogicalOperator>" :scope :public
          :slk-save #'slk-save-operator-pointer
          :slk-load #'slk-load-operator-pointer)
   (input-expression "Expression *" :scope :public
                     :slk-save #'slk-save-ast-pointer
                     :slk-load (slk-load-ast-pointer "Expression"))
   (output-symbol "Symbol" :scope :public))
  (:documentation
   "Takes a list TypedValue as it's input and yields each
element as it's output.

TODO(gitbuda): Update Unwind operator docs.

Input is optional (unwind can be the first clause in a query).")
  (:public
   #>cpp
   Unwind() {}

   Unwind(const std::shared_ptr<LogicalOperator> &input,
          Expression *input_expression_, Symbol output_symbol);
   bool Accept(HierarchicalLogicalOperatorVisitor &visitor) override;
   UniqueCursorPtr MakeCursor(utils::MemoryResource *) const override;
   std::vector<Symbol> ModifiedSymbols(const SymbolTable &) const override;

   bool HasSingleInput() const override {
  return true; }
   std::shared_ptr<LogicalOperator> input() const override {
  return input_; }
   void set_input(std::shared_ptr<LogicalOperator> input) override {
     input_ = input;
   }
   cpp<#)
  (:serialize (:slk))
  (:clone))

(lcp:define-class filter (logical-operator)
  ((input "std::shared_ptr<LogicalOperator>" :scope :public
          :slk-save #'slk-save-operator-pointer
          :slk-load #'slk-load-operator-pointer)
   (expression "Expression *" :scope :public
               :slk-save #'slk-save-ast-pointer
               :slk-load (slk-load-ast-pointer "Expression")))
  (:documentation
   "Filter whose Pull returns true only when the given expression
evaluates into true.

TODO(gitbuda): Update Filter operator docs.

The given expression is assumed to return either NULL (treated as false) or
a boolean value.")
  (:public
   #>cpp
   Filter() {}

   Filter(const std::shared_ptr<LogicalOperator> &input_,
          Expression *expression_);
   bool Accept(HierarchicalLogicalOperatorVisitor &visitor) override;
   UniqueCursorPtr MakeCursor(utils::MemoryResource *) const override;
   std::vector<Symbol> ModifiedSymbols(const SymbolTable &) const override;

   bool HasSingleInput() const override { return true; }
   std::shared_ptr<LogicalOperator> input() const override { return input_; }
   void set_input(std::shared_ptr<LogicalOperator> input) override {
     input_ = input;
   }
   cpp<#)
  (:private
   #>cpp
   class FilterCursor : public Cursor {
    public:
     FilterCursor(const Filter &, utils::MemoryResource *);
     bool Pull(MultiFrame &, ExecutionContext &) override;
     void Shutdown() override;
     void Reset() override;

    private:
     const Filter &self_;
     const UniqueCursorPtr input_cursor_;
   };
   cpp<#)
  (:serialize (:slk))
  (:clone))

(lcp:pop-namespace) ;; distributed
(lcp:pop-namespace) ;; plan
(lcp:pop-namespace) ;; v2
(lcp:pop-namespace) ;; query
(lcp:pop-namespace) ;; memgraph
