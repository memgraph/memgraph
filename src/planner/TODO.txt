## Core Infrastructure
- [x] UnionFind data structure
- [x] E-node representation
- [x] E-class representation
- [x] E-graph structure with congruence closure
- [x] E-graph fuzzer
- [x] Pattern representation (variables, symbols, wildcards)
- [x] Pattern builder with fluent DSL
- [x] E-matching engine with symbol index
- [x] Cost-based extractor
- [x] Directory restructure (egraph/, pattern/, rewrite/, extract/)

## Rewrite System
- [x] RewriteRule with multi-pattern support
- [x] Hash-join for multi-pattern matching
- [x] Greedy join ordering to minimize Cartesian products
- [x] Rewriter with equality saturation loop
- [x] Configurable limits (iterations, e-nodes, timeout)
- [x] Incremental matcher rebuild
- [x] Buffer reuse (JoinContext, RewriteContext, EMatchContext)
- [x] RuleSet immutable rule collection
- [x] C++23 ranges for join operations

## Integration
- [x] Performance benchmarks (e-matching, rewrite)
- [x] Inline rewrite rule (Identifier inlining)
- [ ] Constant folding (e.g., 1+1 -> 2)
- [ ] Dead store elimination with cost model + extraction (symbol sets)
- [ ] Full plan_v2 pipeline integration
- [ ] Bridge to existing v1 planner
- [ ] Migration strategy

## Query Plan Optimization
- [ ] Match ordering (Match -> Scan transformation)
- [ ] Expansion ordering optimization
- [ ] Symbol usage analysis (used/needed symbols per operator)

## Future Optimizations
- [ ] Analysis-guided rewrites (e-class analysis)
- [ ] Parallel rule application
- [ ] Incremental e-graph rebuild tracking

## E-Matching Performance: O(n²) Chain Pattern Issue

### Problem
For patterns like `Neg(Neg(Neg(...?x...)))` with depth n against a similarly-
structured e-graph, matching takes O(n²) time.

Root cause: Matcher iterates ALL e-classes containing root symbol as candidates.
Each candidate k does O(k) work before failing. Total: 1+2+...+n = O(n²).

Benchmark evidence:
  depth:1   ~0.17 µs (1x)
  depth:10  ~2.2 µs  (13x)
  depth:50  ~43 µs   (250x)
  depth:100 ~169 µs  (1000x)

### Potential Solutions

1. **Grounded subpattern lookup**
   Direct hash lookup for subpatterns where all variables are already bound.
   Helps: `Add(?x, Const(0))` where `Const(0)` is ground.
   Does NOT help chains with variables at leaves.

2. **Inverted parent index**
   Maintain: `child_eclass -> Set<(parent_eclass, symbol)>`
   Enables bottom-up matching: O(n) for depth-n chains.

3. **Generic relational e-matching**
   Treat matching as database join with selectivity-based ordering.
   Most general but significant implementation effort.
