// Copyright 2026 Memgraph Ltd.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt; by using this file, you agree to be bound by the terms of the Business Source
// License, and you may not use this file except in compliance with the Business Source License.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

#include <iostream>

#include <gtest/gtest.h>

#include "planner/pattern/vm/compiler.hpp"
#include "planner/pattern/vm/executor.hpp"
#include "planner/pattern/vm/tracer.hpp"
#include "test_egraph_fixture.hpp"
#include "test_patterns.hpp"

namespace memgraph::planner::core {

using namespace test;
using namespace vm;

// ============================================================================
// Compiler Bytecode Tests
// ============================================================================

class VMCompilerTest : public EGraphTestBase {};

TEST_F(VMCompilerTest, WildcardPattern) {
  // Pattern: _ (wildcard)
  auto builder = TestPattern::Builder{};
  builder.wildcard();
  auto pattern = std::move(builder).build();

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  // Wildcard at root should just yield
  auto code = compiled->code();
  ASSERT_EQ(code.size(), 2);
  EXPECT_EQ(code[0], Instruction::yield());
  EXPECT_EQ(code[1], Instruction::halt());
}

TEST_F(VMCompilerTest, VariablePattern) {
  // Pattern: ?x
  auto pattern = make_var_pattern(kVarX);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  // Variable at root should bind-or-check then yield
  auto code = compiled->code();
  ASSERT_EQ(code.size(), 3);
  EXPECT_EQ(code[0], Instruction::bind_or_check(0, 0, 2));  // slot 0, src reg 0, fail jumps to halt
  EXPECT_EQ(code[1], Instruction::yield());
  EXPECT_EQ(code[2], Instruction::halt());
}

TEST_F(VMCompilerTest, SimpleSymbolPattern) {
  // Pattern: Neg(?x)
  auto pattern = TestPattern::build(Op::Neg, {Var{kVarX}}, kTestRoot);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  // Expected bytecode structure:
  // 0:  IterENodes r1, r0, @halt     ; load first e-node
  // 1:  Jump @check                  ; skip NextENode first time
  // loop:
  // 2:  NextENode r1, @halt          ; advance to next
  // check:
  // 3:  CheckSymbol r1, Neg, @loop
  // 4:  CheckArity r1, 1, @loop
  // 5:  BindSlot slot[root], r0
  // 6:  LoadChild r2, r1, 0
  // 7:  BindOrCheck slot[0], r2, @loop
  // 8:  Yield
  // 9:  Jump @loop
  // 10: Halt

  auto code = compiled->code();

  std::cout << "Generated bytecode:\n" << disassemble<Op>(code, compiled->symbols()) << std::endl;

  ASSERT_GE(code.size(), 8) << "Expected at least 8 instructions";

  // Check instruction sequence
  EXPECT_EQ(code[0].op, VMOp::IterENodes);
  EXPECT_EQ(code[1].op, VMOp::Jump) << "Should have jump to skip NextENode";
  EXPECT_EQ(code[2].op, VMOp::NextENode);
  EXPECT_EQ(code[3].op, VMOp::CheckSymbol);
  EXPECT_EQ(code[4].op, VMOp::CheckArity);

  // Check backtrack targets
  auto loop_pos = static_cast<uint16_t>(2);  // NextENode position
  auto halt_pos = static_cast<uint16_t>(code.size() - 1);

  EXPECT_EQ(code[0].target, halt_pos) << "IterENodes should jump to halt on empty";
  EXPECT_EQ(code[1].target, 3) << "First Jump should skip to CheckSymbol";
  EXPECT_EQ(code[2].target, halt_pos) << "NextENode should jump to halt on exhausted";
  EXPECT_EQ(code[3].target, loop_pos) << "CheckSymbol should backtrack to NextENode";
  EXPECT_EQ(code[4].target, loop_pos) << "CheckArity should backtrack to NextENode";
}

TEST_F(VMCompilerTest, NestedSymbolPattern) {
  // Pattern: Neg(Neg(?x))
  auto pattern = TestPattern::build(Op::Neg, {Sym(Op::Neg, Var{kVarX})}, kTestRoot);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  auto code = compiled->code();

  std::cout << "Generated bytecode for Neg(Neg(?x)):\n" << disassemble<Op>(code, compiled->symbols()) << std::endl;

  // Expected structure:
  // 0: IterENodes r1, r0, @halt
  // 1: NextENode r1, @halt           ; outer loop
  // 2: CheckSymbol r1, Neg, @1
  // 3: CheckArity r1, 1, @1
  // 4: LoadChild r2, r1, 0           ; load child e-class
  // 5: IterENodes r3, r2, @1         ; inner iteration (backtrack to outer loop)
  // 6: NextENode r3, @1              ; inner loop (backtrack to outer loop)
  // 7: CheckSymbol r3, Neg, @6       ; check inner Neg (backtrack to inner loop)
  // 8: CheckArity r3, 1, @6
  // 9: LoadChild r4, r3, 0
  // 10: BindOrCheck slot[0], r4, @6  ; bind ?x (backtrack to inner loop)
  // 11: Yield
  // 12: Jump @6                       ; continue inner loop
  // 13: Jump @1                       ; continue outer loop
  // 14: Halt

  ASSERT_GE(code.size(), 10) << "Expected at least 10 instructions";

  // Find key instruction positions
  int outer_loop = -1, inner_iter = -1, inner_loop = -1;
  for (std::size_t i = 0; i < code.size(); ++i) {
    if (code[i].op == VMOp::NextENode) {
      if (outer_loop == -1)
        outer_loop = static_cast<int>(i);
      else
        inner_loop = static_cast<int>(i);
    }
    if (code[i].op == VMOp::IterENodes && i > 0) {
      inner_iter = static_cast<int>(i);
    }
  }

  ASSERT_NE(outer_loop, -1) << "Could not find outer loop";
  ASSERT_NE(inner_iter, -1) << "Could not find inner IterENodes";
  ASSERT_NE(inner_loop, -1) << "Could not find inner loop";

  // Inner IterENodes should backtrack to outer loop
  EXPECT_EQ(code[inner_iter].target, static_cast<uint16_t>(outer_loop))
      << "Inner IterENodes should backtrack to outer loop";

  // Inner NextENode should backtrack to outer loop
  EXPECT_EQ(code[inner_loop].target, static_cast<uint16_t>(outer_loop))
      << "Inner NextENode should backtrack to outer loop";
}

TEST_F(VMCompilerTest, BinarySymbolPattern) {
  // Pattern: Add(?x, ?y)
  auto pattern = TestPattern::build(Op::Add, {Var{kVarX}, Var{kVarY}}, kTestRoot);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  auto code = compiled->code();

  std::cout << "Generated bytecode for Add(?x, ?y):\n" << disassemble<Op>(code, compiled->symbols()) << std::endl;

  // Should have two LoadChild instructions for two children
  int load_child_count = 0;
  for (auto const &instr : code) {
    if (instr.op == VMOp::LoadChild) {
      ++load_child_count;
    }
  }
  EXPECT_EQ(load_child_count, 2) << "Expected 2 LoadChild instructions for binary pattern";

  // Should have two BindOrCheck for ?x and ?y
  int bind_or_check_count = 0;
  for (auto const &instr : code) {
    if (instr.op == VMOp::BindOrCheck) {
      ++bind_or_check_count;
    }
  }
  EXPECT_EQ(bind_or_check_count, 2) << "Expected 2 BindOrCheck instructions for two variables";
}

// ============================================================================
// VM Execution with Tracer Tests
// ============================================================================

class VMExecutionTest : public EGraphTestBase {
 protected:
  EMatchContext ctx;
  std::vector<PatternMatch> results;
};

TEST_F(VMExecutionTest, SimpleMatch) {
  // Create e-graph: Neg(Const(42))
  auto c = leaf(Op::Const, 42);
  node(Op::Neg, c);
  rebuild_egraph();

  // Pattern: Neg(?x)
  auto pattern = TestPattern::build(Op::Neg, {Var{kVarX}}, kTestRoot);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  std::cout << "Bytecode:\n" << disassemble<Op>(compiled->code(), compiled->symbols()) << std::endl;

  // Execute with tracer
  RecordingTracer tracer;
  VMExecutorVerify<Op, NoAnalysis, RecordingTracer> executor(egraph, &tracer);

  std::vector<EClassId> candidates;
  for (auto id : egraph.canonical_class_ids()) {
    candidates.push_back(id);
  }

  executor.execute(*compiled, candidates, ctx, results);

  std::cout << "Execution trace:\n";
  tracer.print(std::cout);

  EXPECT_EQ(results.size(), 1) << "Expected exactly 1 match";

  // Check that we found the right match
  if (!results.empty()) {
    auto bound_x = ctx.arena().get(results[0], 0);  // slot 0 = ?x
    EXPECT_EQ(egraph.find(bound_x), egraph.find(c)) << "?x should be bound to the Const node";
  }
}

TEST_F(VMExecutionTest, NoMatch) {
  // Create e-graph: Add(Const(1), Const(2))
  auto c1 = leaf(Op::Const, 1);
  auto c2 = leaf(Op::Const, 2);
  node(Op::Add, c1, c2);
  rebuild_egraph();

  // Pattern: Neg(?x) - should not match
  auto pattern = TestPattern::build(Op::Neg, {Var{kVarX}}, kTestRoot);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  VMExecutorVerify<Op, NoAnalysis> executor(egraph);

  std::vector<EClassId> candidates;
  for (auto id : egraph.canonical_class_ids()) {
    candidates.push_back(id);
  }

  executor.execute(*compiled, candidates, ctx, results);

  EXPECT_EQ(results.size(), 0) << "Expected no matches";
}

TEST_F(VMExecutionTest, MultipleMatches) {
  // Create e-graph with multiple Neg nodes
  auto c1 = leaf(Op::Const, 1);
  auto c2 = leaf(Op::Const, 2);
  node(Op::Neg, c1);
  node(Op::Neg, c2);
  node(Op::Neg, node(Op::Neg, c1));  // Neg(Neg(Const(1)))
  rebuild_egraph();

  // Pattern: Neg(?x)
  auto pattern = TestPattern::build(Op::Neg, {Var{kVarX}}, kTestRoot);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  VMExecutorVerify<Op, NoAnalysis> executor(egraph);

  std::vector<EClassId> candidates;
  for (auto id : egraph.canonical_class_ids()) {
    candidates.push_back(id);
  }

  executor.execute(*compiled, candidates, ctx, results);

  EXPECT_EQ(results.size(), 3) << "Expected 3 matches (n1, n2, n3 all contain Neg)";
}

TEST_F(VMExecutionTest, NestedPatternMatch) {
  // Create e-graph: Neg(Neg(Const(42)))
  auto c = leaf(Op::Const, 42);
  node(Op::Neg, node(Op::Neg, c));
  rebuild_egraph();

  // Pattern: Neg(Neg(?x))
  auto pattern = TestPattern::build(Op::Neg, {Sym(Op::Neg, Var{kVarX})}, kTestRoot);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  std::cout << "Bytecode for Neg(Neg(?x)):\n" << disassemble<Op>(compiled->code(), compiled->symbols()) << std::endl;

  RecordingTracer tracer;
  VMExecutorVerify<Op, NoAnalysis, RecordingTracer> executor(egraph, &tracer);

  std::vector<EClassId> candidates;
  for (auto id : egraph.canonical_class_ids()) {
    candidates.push_back(id);
  }

  std::cout << "Starting execution with " << candidates.size() << " candidates\n";
  std::cout.flush();

  // Execute one candidate at a time for debugging
  for (std::size_t i = 0; i < candidates.size(); ++i) {
    std::cout << "Processing candidate " << i << " (EC" << candidates[i].value_of() << ")\n";
    std::cout.flush();
    tracer.clear();
    std::vector<EClassId> single_candidate = {candidates[i]};
    executor.execute(*compiled, single_candidate, ctx, results);
    std::cout << "Candidate " << i << " completed, " << results.size() << " total matches\n";
    std::cout.flush();
  }

  std::cout << "Execution trace (last candidate):\n";
  tracer.print(std::cout);

  EXPECT_EQ(results.size(), 1) << "Expected exactly 1 match for Neg(Neg(?x))";

  if (!results.empty()) {
    auto bound_x = ctx.arena().get(results[0], 0);  // slot 0 = ?x
    EXPECT_EQ(egraph.find(bound_x), egraph.find(c)) << "?x should be bound to the Const node";
  }
}

TEST_F(VMExecutionTest, SelfReferentialEClass) {
  // The self-referential case from the bug:
  // n0 = B(64)
  // n1 = F(n0)
  // n2 = F(n1)
  // merge(n1, n2) => EC1 = {F(n0), F(EC1)}
  auto n0 = leaf(Op::B, 64);
  auto n1 = node(Op::F, n0);
  auto n2 = node(Op::F, n1);

  merge(n1, n2);
  rebuild_egraph();

  // Pattern: F(F(?x))
  auto pattern = TestPattern::build(Op::F, {Sym(Op::F, Var{kVarX})}, kTestRoot);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  std::cout << "Bytecode for F(F(?x)):\n" << disassemble<Op>(compiled->code(), compiled->symbols()) << std::endl;

  RecordingTracer tracer;
  VMExecutorVerify<Op, NoAnalysis, RecordingTracer> executor(egraph, &tracer);

  std::vector<EClassId> candidates;
  for (auto id : egraph.canonical_class_ids()) {
    candidates.push_back(id);
  }

  executor.execute(*compiled, candidates, ctx, results);

  std::cout << "Execution trace:\n";
  tracer.print(std::cout);

  // Should find at least 2 matches due to self-reference
  EXPECT_GE(results.size(), 2) << "Expected at least 2 matches for self-referential F(F(?x))";

  std::cout << "Found " << results.size() << " matches:\n";
  for (std::size_t i = 0; i < results.size(); ++i) {
    auto bound_x = ctx.arena().get(results[i], 0);  // slot 0 = ?x
    std::cout << "  Match " << i << ": ?x = " << bound_x.value_of() << "\n";
  }
}

// ============================================================================
// Deep Pattern Tests (regression for crash)
// ============================================================================

TEST_F(VMExecutionTest, DeepNestedPattern) {
  // Create a chain of Neg nodes: Neg(Neg(Neg(...Neg(x)...)))
  constexpr int kDepth = 10;

  auto x = leaf(Op::Const, 0);
  auto current = x;
  for (int i = 0; i < kDepth; ++i) {
    current = node(Op::Neg, current);
  }

  rebuild_egraph();

  // Pattern: Neg(Neg(Neg(?x))) - depth 3
  auto pattern = Pattern<Op>::build(Op::Neg, {Sym(Op::Neg, Sym(Op::Neg, Var{kVarX}))}, kTestRoot);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  std::cout << "Bytecode for Neg(Neg(Neg(?x))):\n"
            << disassemble<Op>(compiled->code(), compiled->symbols()) << std::endl;

  VMExecutorVerify<Op, NoAnalysis> executor(egraph);

  std::vector<EClassId> candidates;
  for (auto id : egraph.canonical_class_ids()) {
    candidates.push_back(id);
  }

  executor.execute(*compiled, candidates, ctx, results);

  // With depth 10 chain, pattern depth 3, we should find (10 - 3 + 1) = 8 matches
  EXPECT_EQ(results.size(), kDepth - 3 + 1)
      << "Expected " << (kDepth - 3 + 1) << " matches for depth-3 pattern on depth-" << kDepth << " chain";
}

TEST_F(VMExecutionTest, VeryDeepNestedPattern) {
  // Create a chain of Neg nodes: Neg(Neg(Neg(...Neg(x)...)))
  constexpr int kDepth = 50;

  auto x = leaf(Op::Const, 0);
  auto current = x;
  for (int i = 0; i < kDepth; ++i) {
    current = node(Op::Neg, current);
  }

  rebuild_egraph();

  // Build a deep pattern dynamically
  constexpr int kPatternDepth = 10;
  auto b = Pattern<Op>::Builder{};
  auto cur = b.var(kVarX);
  for (int i = 0; i < kPatternDepth; ++i) {
    cur = b.sym(Op::Neg, {cur});
  }
  auto pattern = std::move(b).build();

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  std::cout << "Bytecode for depth-" << kPatternDepth << " Neg pattern:\n"
            << disassemble<Op>(compiled->code(), compiled->symbols()) << std::endl;

  VMExecutorVerify<Op, NoAnalysis> executor(egraph);

  std::vector<EClassId> candidates;
  for (auto id : egraph.canonical_class_ids()) {
    candidates.push_back(id);
  }

  executor.execute(*compiled, candidates, ctx, results);

  // With depth 50 chain, pattern depth 10, we should find (50 - 10 + 1) = 41 matches
  EXPECT_EQ(results.size(), kDepth - kPatternDepth + 1)
      << "Expected " << (kDepth - kPatternDepth + 1) << " matches for depth-" << kPatternDepth << " pattern on depth-"
      << kDepth << " chain";
}

// Test that compiler returns nullopt for patterns that exceed register limit
TEST_F(VMExecutionTest, PatternExceedingRegisterLimit) {
  // VM has 64 registers, deep patterns need ~2*depth+1 registers
  // So depth 35+ should exceed the limit
  constexpr int kPatternDepth = 35;

  auto b = Pattern<Op>::Builder{};
  auto cur = b.var(kVarX);
  for (int i = 0; i < kPatternDepth; ++i) {
    cur = b.sym(Op::Neg, {cur});
  }
  auto pattern = std::move(b).build();

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  // Should return nullopt because pattern is too deep
  EXPECT_FALSE(compiled.has_value()) << "Expected compilation to fail for depth-" << kPatternDepth << " pattern";
}

// ============================================================================
// Fused Pattern Compiler Tests
// ============================================================================

class FusedCompilerTest : public VMExecutionTest {};

// Test: Bind(_, ?sym, ?expr) joined with ?id = Ident(?sym)
// This tests parent traversal: after matching Bind, traverse UP from ?sym to find Ident parents
TEST_F(FusedCompilerTest, SimpleJoinWithParentTraversal) {
  // Build e-graph:
  //   sym_val = Const(1)
  //   expr_val = Const(2)
  //   bind_node = Bind(Const(0), sym_val, expr_val)
  //   ident_node = Ident(sym_val)  <- shares sym_val with bind_node
  auto placeholder = leaf(Op::Const, 0);
  auto sym_val = leaf(Op::Const, 1);
  auto expr_val = leaf(Op::Const, 2);
  auto bind_node = node(Op::Bind, placeholder, sym_val, expr_val);
  auto ident_node = node(Op::Ident, sym_val);  // Uses same sym_val!

  rebuild_egraph();

  // Anchor pattern: Bind(_, ?sym, ?expr)
  constexpr PatternVar kVarSym{1};
  constexpr PatternVar kVarExpr{2};
  auto anchor = Pattern<Op>::build(Op::Bind, {Wildcard{}, Var{kVarSym}, Var{kVarExpr}}, kTestRoot);

  // Joined pattern: ?id = Ident(?sym)
  constexpr PatternVar kVarId{3};
  auto joined = Pattern<Op>::build(Op::Ident, {Var{kVarSym}}, kVarId);

  // Compile with FusedPatternCompiler
  FusedPatternCompiler<Op> compiler;
  auto compiled = compiler.compile(anchor, {joined}, {kVarSym});

  ASSERT_TRUE(compiled.has_value()) << "Fused compilation should succeed";

  std::cout << "Fused bytecode for Bind(_, ?sym, ?expr) + ?id=Ident(?sym):\n"
            << disassemble<Op>(compiled->code(), compiled->symbols()) << std::endl;

  // Verify bytecode has parent traversal instructions
  bool has_iter_parents = false;
  bool has_next_parent = false;
  bool has_get_enode_eclass = false;

  for (auto const &instr : compiled->code()) {
    if (instr.op == VMOp::IterParentsSym || instr.op == VMOp::IterParents) {
      has_iter_parents = true;
    }
    if (instr.op == VMOp::NextParent) {
      has_next_parent = true;
    }
    if (instr.op == VMOp::GetENodeEClass) {
      has_get_enode_eclass = true;
    }
  }

  EXPECT_TRUE(has_iter_parents) << "Fused bytecode should have IterParents(Sym) instruction";
  EXPECT_TRUE(has_next_parent) << "Fused bytecode should have NextParent instruction";
  EXPECT_TRUE(has_get_enode_eclass) << "Fused bytecode should have GetENodeEClass for ?id binding";

  // Execute and verify matches
  VMExecutorVerify<Op, NoAnalysis> executor(egraph);

  // Only use the Bind e-class as candidate (anchor pattern entry)
  std::vector<EClassId> candidates = {egraph.find(bind_node)};

  EMatchContext ctx;
  std::vector<PatternMatch> results;
  executor.execute(*compiled, candidates, ctx, results);

  // Should find 1 match: Bind paired with Ident (both reference same sym_val)
  EXPECT_EQ(results.size(), 1) << "Should find exactly 1 match where Bind and Ident share ?sym";

  if (!results.empty()) {
    // The match should contain bindings for kVarSym, kVarExpr, kVarId, and kTestRoot
    // Note: Slot ordering depends on unordered map iteration, so we check all slots
    // to find which one contains each expected value
    auto &match = results[0];
    auto num_slots = compiled->num_slots();

    bool found_sym = false, found_expr = false, found_id = false;
    for (std::size_t i = 0; i < num_slots; ++i) {
      auto bound = ctx.arena().get(match, i);
      if (egraph.find(bound) == egraph.find(sym_val)) found_sym = true;
      if (egraph.find(bound) == egraph.find(expr_val)) found_expr = true;
      if (egraph.find(bound) == egraph.find(ident_node)) found_id = true;
    }

    EXPECT_TRUE(found_sym) << "Match should contain binding for ?sym = sym_val";
    EXPECT_TRUE(found_expr) << "Match should contain binding for ?expr = expr_val";
    EXPECT_TRUE(found_id) << "Match should contain binding for ?id = ident_node";
  }
}

// Test: No matching join - Ident uses different symbol
TEST_F(FusedCompilerTest, NoMatchingJoin) {
  // Build e-graph:
  //   sym_val1 = Const(1)
  //   sym_val2 = Const(2)  <- different from sym_val1
  //   expr_val = Const(3)
  //   bind_node = Bind(Const(0), sym_val1, expr_val)
  //   ident_node = Ident(sym_val2)  <- uses DIFFERENT symbol!
  auto placeholder = leaf(Op::Const, 0);
  auto sym_val1 = leaf(Op::Const, 1);
  auto sym_val2 = leaf(Op::Const, 2);
  auto expr_val = leaf(Op::Const, 3);
  auto bind_node = node(Op::Bind, placeholder, sym_val1, expr_val);
  node(Op::Ident, sym_val2);  // Uses different sym!

  rebuild_egraph();

  // Anchor pattern: Bind(_, ?sym, ?expr)
  constexpr PatternVar kVarSym{1};
  constexpr PatternVar kVarExpr{2};
  auto anchor = Pattern<Op>::build(Op::Bind, {Wildcard{}, Var{kVarSym}, Var{kVarExpr}}, kTestRoot);

  // Joined pattern: ?id = Ident(?sym)
  constexpr PatternVar kVarId{3};
  auto joined = Pattern<Op>::build(Op::Ident, {Var{kVarSym}}, kVarId);

  // Compile and execute
  FusedPatternCompiler<Op> compiler;
  auto compiled = compiler.compile(anchor, {joined}, {kVarSym});
  ASSERT_TRUE(compiled.has_value());

  VMExecutorVerify<Op, NoAnalysis> executor(egraph);
  std::vector<EClassId> candidates = {egraph.find(bind_node)};

  EMatchContext ctx;
  std::vector<PatternMatch> results;
  executor.execute(*compiled, candidates, ctx, results);

  // Should find NO matches - Ident doesn't reference the same ?sym
  EXPECT_EQ(results.size(), 0) << "Should find no matches when Ident uses different symbol";
}

// Test: Multiple Ident references to same symbol
TEST_F(FusedCompilerTest, MultipleJoinMatches) {
  // Build e-graph:
  //   sym_val = Const(1)
  //   expr_val = Const(2)
  //   bind_node = Bind(Const(0), sym_val, expr_val)
  //   ident1 = Ident(sym_val)
  //   ident2 = Ident(sym_val)  <- second Ident referencing same symbol
  auto placeholder = leaf(Op::Const, 0);
  auto sym_val = leaf(Op::Const, 1);
  auto expr_val = leaf(Op::Const, 2);
  auto bind_node = node(Op::Bind, placeholder, sym_val, expr_val);
  auto ident1 = node(Op::Ident, sym_val);
  auto ident2 = node(Op::Ident, sym_val);  // Second Ident

  rebuild_egraph();

  // Anchor pattern: Bind(_, ?sym, ?expr)
  constexpr PatternVar kVarSym{1};
  constexpr PatternVar kVarExpr{2};
  auto anchor = Pattern<Op>::build(Op::Bind, {Wildcard{}, Var{kVarSym}, Var{kVarExpr}}, kTestRoot);

  // Joined pattern: ?id = Ident(?sym)
  constexpr PatternVar kVarId{3};
  auto joined = Pattern<Op>::build(Op::Ident, {Var{kVarSym}}, kVarId);

  // Compile and execute
  FusedPatternCompiler<Op> compiler;
  auto compiled = compiler.compile(anchor, {joined}, {kVarSym});
  ASSERT_TRUE(compiled.has_value());

  std::cout << "Fused bytecode (multiple Idents):\n"
            << disassemble<Op>(compiled->code(), compiled->symbols()) << std::endl;

  VMExecutorVerify<Op, NoAnalysis> executor(egraph);
  std::vector<EClassId> candidates = {egraph.find(bind_node)};

  EMatchContext ctx;
  std::vector<PatternMatch> results;
  executor.execute(*compiled, candidates, ctx, results);

  // Debug: Check how many parents sym_val has
  auto sym_canonical = egraph.find(sym_val);
  auto const &sym_eclass = egraph.eclass(sym_canonical);
  std::cout << "sym_val e-class " << sym_canonical << " has " << sym_eclass.parents().size() << " parents\n";
  for (auto parent_id : sym_eclass.parents()) {
    auto const &parent = egraph.get_enode(parent_id);
    std::cout << "  Parent: enode " << parent_id << " symbol=" << static_cast<int>(parent.symbol()) << "\n";
  }

  // Debug: Check if ident1 and ident2 are in different e-classes
  std::cout << "ident1 e-class: " << egraph.find(ident1) << "\n";
  std::cout << "ident2 e-class: " << egraph.find(ident2) << "\n";

  // Note: If both ident nodes have the same structure Ident(sym_val), they might
  // be in the same e-class due to structural sharing. In that case, there's only
  // 1 Ident e-class, so only 1 match.
  // Let's check what we actually expect:
  bool idents_same_eclass = (egraph.find(ident1) == egraph.find(ident2));
  std::size_t expected_matches = idents_same_eclass ? 1 : 2;

  EXPECT_EQ(results.size(), expected_matches)
      << "Should find " << expected_matches << " matches (idents same e-class: " << idents_same_eclass << ")";
}

}  // namespace memgraph::planner::core
