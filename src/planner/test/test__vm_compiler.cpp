// Copyright 2026 Memgraph Ltd.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt; by using this file, you agree to be bound by the terms of the Business Source
// License, and you may not use this file except in compliance with the Business Source License.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

#include <iostream>

#include <gtest/gtest.h>

#include "planner/pattern/vm/compiler.hpp"
#include "planner/pattern/vm/executor.hpp"
#include "planner/pattern/vm/tracer.hpp"
#include "test_egraph_fixture.hpp"
#include "test_patterns.hpp"

namespace memgraph::planner::core {

using namespace test;
using namespace vm;

// ============================================================================
// Compiler Bytecode Tests
// ============================================================================

class VMCompilerTest : public EGraphTestBase {};

TEST_F(VMCompilerTest, WildcardPattern) {
  // Pattern: _ (wildcard)
  auto builder = TestPattern::Builder{};
  builder.wildcard();
  auto pattern = std::move(builder).build();

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  // Wildcard at root: yield, jump back (to halt), halt
  auto code = compiled->code();
  ASSERT_EQ(code.size(), 3);
  EXPECT_EQ(code[0], Instruction::yield());
  EXPECT_EQ(code[1].op, VMOp::Jump);
  EXPECT_EQ(code[2], Instruction::halt());
}

TEST_F(VMCompilerTest, VariablePattern) {
  // Pattern: ?x
  auto pattern = make_var_pattern(kVarX);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  // Variable at root: bind, yield, jump back (to halt), halt
  auto code = compiled->code();
  ASSERT_EQ(code.size(), 4);
  EXPECT_EQ(code[0], Instruction::bind_slot(0, 0));  // slot 0, src reg 0
  EXPECT_EQ(code[1], Instruction::yield());
  EXPECT_EQ(code[2].op, VMOp::Jump);
  EXPECT_EQ(code[3], Instruction::halt());
}

TEST_F(VMCompilerTest, SimpleSymbolPattern) {
  // Pattern: Neg(?x)
  auto pattern = TestPattern::build(Op::Neg, {Var{kVarX}}, kTestRoot);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  // Expected bytecode structure:
  // 0:  IterENodes r1, r0, @halt     ; load first e-node
  // 1:  Jump @check                  ; skip NextENode first time
  // loop:
  // 2:  NextENode r1, @halt          ; advance to next
  // check:
  // 3:  CheckSymbol r1, Neg, @loop
  // 4:  CheckArity r1, 1, @loop
  // 5:  BindSlot slot[root], r0
  // 6:  LoadChild r2, r1, 0
  // 7:  BindOrCheck slot[0], r2, @loop
  // 8:  Yield
  // 9:  Jump @loop
  // 10: Halt

  auto code = compiled->code();

  std::cout << "Generated bytecode:\n" << disassemble<Op>(code, compiled->symbols()) << std::endl;

  ASSERT_GE(code.size(), 8) << "Expected at least 8 instructions";

  // Check instruction sequence
  EXPECT_EQ(code[0].op, VMOp::IterENodes);
  EXPECT_EQ(code[1].op, VMOp::Jump) << "Should have jump to skip NextENode";
  EXPECT_EQ(code[2].op, VMOp::NextENode);
  EXPECT_EQ(code[3].op, VMOp::CheckSymbol);
  EXPECT_EQ(code[4].op, VMOp::CheckArity);

  // Check backtrack targets
  auto loop_pos = static_cast<uint16_t>(2);  // NextENode position
  auto halt_pos = static_cast<uint16_t>(code.size() - 1);

  EXPECT_EQ(code[0].target, halt_pos) << "IterENodes should jump to halt on empty";
  EXPECT_EQ(code[1].target, 3) << "First Jump should skip to CheckSymbol";
  EXPECT_EQ(code[2].target, halt_pos) << "NextENode should jump to halt on exhausted";
  EXPECT_EQ(code[3].target, loop_pos) << "CheckSymbol should backtrack to NextENode";
  EXPECT_EQ(code[4].target, loop_pos) << "CheckArity should backtrack to NextENode";
}

TEST_F(VMCompilerTest, NestedSymbolPattern) {
  // Pattern: Neg(Neg(?x))
  auto pattern = TestPattern::build(Op::Neg, {Sym(Op::Neg, Var{kVarX})}, kTestRoot);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  auto code = compiled->code();

  std::cout << "Generated bytecode for Neg(Neg(?x)):\n" << disassemble<Op>(code, compiled->symbols()) << std::endl;

  // Expected structure:
  // 0: IterENodes r1, r0, @halt
  // 1: NextENode r1, @halt           ; outer loop
  // 2: CheckSymbol r1, Neg, @1
  // 3: CheckArity r1, 1, @1
  // 4: LoadChild r2, r1, 0           ; load child e-class
  // 5: IterENodes r3, r2, @1         ; inner iteration (backtrack to outer loop)
  // 6: NextENode r3, @1              ; inner loop (backtrack to outer loop)
  // 7: CheckSymbol r3, Neg, @6       ; check inner Neg (backtrack to inner loop)
  // 8: CheckArity r3, 1, @6
  // 9: LoadChild r4, r3, 0
  // 10: BindOrCheck slot[0], r4, @6  ; bind ?x (backtrack to inner loop)
  // 11: Yield
  // 12: Jump @6                       ; continue inner loop
  // 13: Jump @1                       ; continue outer loop
  // 14: Halt

  ASSERT_GE(code.size(), 10) << "Expected at least 10 instructions";

  // Find key instruction positions
  int outer_loop = -1, inner_iter = -1, inner_loop = -1;
  for (std::size_t i = 0; i < code.size(); ++i) {
    if (code[i].op == VMOp::NextENode) {
      if (outer_loop == -1)
        outer_loop = static_cast<int>(i);
      else
        inner_loop = static_cast<int>(i);
    }
    if (code[i].op == VMOp::IterENodes && i > 0) {
      inner_iter = static_cast<int>(i);
    }
  }

  ASSERT_NE(outer_loop, -1) << "Could not find outer loop";
  ASSERT_NE(inner_iter, -1) << "Could not find inner IterENodes";
  ASSERT_NE(inner_loop, -1) << "Could not find inner loop";

  // Inner IterENodes should backtrack to outer loop
  EXPECT_EQ(code[inner_iter].target, static_cast<uint16_t>(outer_loop))
      << "Inner IterENodes should backtrack to outer loop";

  // Inner NextENode should backtrack to outer loop
  EXPECT_EQ(code[inner_loop].target, static_cast<uint16_t>(outer_loop))
      << "Inner NextENode should backtrack to outer loop";
}

TEST_F(VMCompilerTest, BinarySymbolPattern) {
  // Pattern: Add(?x, ?y)
  auto pattern = TestPattern::build(Op::Add, {Var{kVarX}, Var{kVarY}}, kTestRoot);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  auto code = compiled->code();

  std::cout << "Generated bytecode for Add(?x, ?y):\n" << disassemble<Op>(code, compiled->symbols()) << std::endl;

  // Should have two LoadChild instructions for two children
  int load_child_count = 0;
  for (auto const &instr : code) {
    if (instr.op == VMOp::LoadChild) {
      ++load_child_count;
    }
  }
  EXPECT_EQ(load_child_count, 2) << "Expected 2 LoadChild instructions for binary pattern";

  // Should have two BindSlot for ?x and ?y (both first occurrences)
  int bind_slot_count = 0;
  for (auto const &instr : code) {
    if (instr.op == VMOp::BindSlot) {
      ++bind_slot_count;
    }
  }
  // Note: There are 3 BindSlots: one for root binding, and two for ?x and ?y
  // Actually there should be 2 for variables + 1 for root = 3 if root has binding
  // Let's check what we actually get - should be at least 2 for variables
  EXPECT_GE(bind_slot_count, 2) << "Expected at least 2 BindSlot instructions for two variables";
}

// ============================================================================
// VM Execution with Tracer Tests
// ============================================================================

class VMExecutionTest : public EGraphTestBase {
 protected:
  EMatchContext ctx;
  std::vector<PatternMatch> results;
};

TEST_F(VMExecutionTest, SimpleMatch) {
  // Create e-graph: Neg(Const(42))
  auto c = leaf(Op::Const, 42);
  node(Op::Neg, c);
  rebuild_egraph();

  // Pattern: Neg(?x)
  auto pattern = TestPattern::build(Op::Neg, {Var{kVarX}}, kTestRoot);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  std::cout << "Bytecode:\n" << disassemble<Op>(compiled->code(), compiled->symbols()) << std::endl;

  // Execute with tracer
  RecordingTracer tracer;
  VMExecutorVerify<Op, NoAnalysis, RecordingTracer> executor(egraph, &tracer);

  std::vector<EClassId> candidates;
  for (auto id : egraph.canonical_class_ids()) {
    candidates.push_back(id);
  }

  executor.execute(*compiled, candidates, ctx, results);

  std::cout << "Execution trace:\n";
  tracer.print(std::cout);

  EXPECT_EQ(results.size(), 1) << "Expected exactly 1 match";

  // Check that we found the right match
  if (!results.empty()) {
    auto bound_x = ctx.arena().get(results[0], 0);  // slot 0 = ?x
    EXPECT_EQ(egraph.find(bound_x), egraph.find(c)) << "?x should be bound to the Const node";
  }
}

TEST_F(VMExecutionTest, NoMatch) {
  // Create e-graph: Add(Const(1), Const(2))
  auto c1 = leaf(Op::Const, 1);
  auto c2 = leaf(Op::Const, 2);
  node(Op::Add, c1, c2);
  rebuild_egraph();

  // Pattern: Neg(?x) - should not match
  auto pattern = TestPattern::build(Op::Neg, {Var{kVarX}}, kTestRoot);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  VMExecutorVerify<Op, NoAnalysis> executor(egraph);

  std::vector<EClassId> candidates;
  for (auto id : egraph.canonical_class_ids()) {
    candidates.push_back(id);
  }

  executor.execute(*compiled, candidates, ctx, results);

  EXPECT_EQ(results.size(), 0) << "Expected no matches";
}

TEST_F(VMExecutionTest, MultipleMatches) {
  // Create e-graph with multiple Neg nodes
  auto c1 = leaf(Op::Const, 1);
  auto c2 = leaf(Op::Const, 2);
  node(Op::Neg, c1);
  node(Op::Neg, c2);
  node(Op::Neg, node(Op::Neg, c1));  // Neg(Neg(Const(1)))
  rebuild_egraph();

  // Pattern: Neg(?x)
  auto pattern = TestPattern::build(Op::Neg, {Var{kVarX}}, kTestRoot);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  VMExecutorVerify<Op, NoAnalysis> executor(egraph);

  std::vector<EClassId> candidates;
  for (auto id : egraph.canonical_class_ids()) {
    candidates.push_back(id);
  }

  executor.execute(*compiled, candidates, ctx, results);

  EXPECT_EQ(results.size(), 3) << "Expected 3 matches (n1, n2, n3 all contain Neg)";
}

TEST_F(VMExecutionTest, NestedPatternMatch) {
  // Create e-graph: Neg(Neg(Const(42)))
  auto c = leaf(Op::Const, 42);
  node(Op::Neg, node(Op::Neg, c));
  rebuild_egraph();

  // Pattern: Neg(Neg(?x))
  auto pattern = TestPattern::build(Op::Neg, {Sym(Op::Neg, Var{kVarX})}, kTestRoot);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  std::cout << "Bytecode for Neg(Neg(?x)):\n" << disassemble<Op>(compiled->code(), compiled->symbols()) << std::endl;

  RecordingTracer tracer;
  VMExecutorVerify<Op, NoAnalysis, RecordingTracer> executor(egraph, &tracer);

  std::vector<EClassId> candidates;
  for (auto id : egraph.canonical_class_ids()) {
    candidates.push_back(id);
  }

  std::cout << "Starting execution with " << candidates.size() << " candidates\n";
  std::cout.flush();

  // Execute one candidate at a time for debugging
  for (std::size_t i = 0; i < candidates.size(); ++i) {
    std::cout << "Processing candidate " << i << " (EC" << candidates[i].value_of() << ")\n";
    std::cout.flush();
    tracer.clear();
    std::vector<EClassId> single_candidate = {candidates[i]};
    executor.execute(*compiled, single_candidate, ctx, results);
    std::cout << "Candidate " << i << " completed, " << results.size() << " total matches\n";
    std::cout.flush();
  }

  std::cout << "Execution trace (last candidate):\n";
  tracer.print(std::cout);

  EXPECT_EQ(results.size(), 1) << "Expected exactly 1 match for Neg(Neg(?x))";

  if (!results.empty()) {
    auto bound_x = ctx.arena().get(results[0], 0);  // slot 0 = ?x
    EXPECT_EQ(egraph.find(bound_x), egraph.find(c)) << "?x should be bound to the Const node";
  }
}

TEST_F(VMExecutionTest, SelfReferentialEClass) {
  // The self-referential case from the bug:
  // n0 = B(64)
  // n1 = F(n0)
  // n2 = F(n1)
  // merge(n1, n2) => EC1 = {F(n0), F(EC1)}
  auto n0 = leaf(Op::B, 64);
  auto n1 = node(Op::F, n0);
  auto n2 = node(Op::F, n1);

  merge(n1, n2);
  rebuild_egraph();

  // Pattern: F(F(?x))
  auto pattern = TestPattern::build(Op::F, {Sym(Op::F, Var{kVarX})}, kTestRoot);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  std::cout << "Bytecode for F(F(?x)):\n" << disassemble<Op>(compiled->code(), compiled->symbols()) << std::endl;

  RecordingTracer tracer;
  VMExecutorVerify<Op, NoAnalysis, RecordingTracer> executor(egraph, &tracer);

  std::vector<EClassId> candidates;
  for (auto id : egraph.canonical_class_ids()) {
    candidates.push_back(id);
  }

  executor.execute(*compiled, candidates, ctx, results);

  std::cout << "Execution trace:\n";
  tracer.print(std::cout);

  // Should find at least 2 matches due to self-reference
  EXPECT_GE(results.size(), 2) << "Expected at least 2 matches for self-referential F(F(?x))";

  std::cout << "Found " << results.size() << " matches:\n";
  for (std::size_t i = 0; i < results.size(); ++i) {
    auto bound_x = ctx.arena().get(results[i], 0);  // slot 0 = ?x
    std::cout << "  Match " << i << ": ?x = " << bound_x.value_of() << "\n";
  }
}

// ============================================================================
// Deep Pattern Tests (regression for crash)
// ============================================================================

TEST_F(VMExecutionTest, DeepNestedPattern) {
  // Create a chain of Neg nodes: Neg(Neg(Neg(...Neg(x)...)))
  constexpr int kDepth = 10;

  auto x = leaf(Op::Const, 0);
  auto current = x;
  for (int i = 0; i < kDepth; ++i) {
    current = node(Op::Neg, current);
  }

  rebuild_egraph();

  // Pattern: Neg(Neg(Neg(?x))) - depth 3
  auto pattern = Pattern<Op>::build(Op::Neg, {Sym(Op::Neg, Sym(Op::Neg, Var{kVarX}))}, kTestRoot);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  std::cout << "Bytecode for Neg(Neg(Neg(?x))):\n"
            << disassemble<Op>(compiled->code(), compiled->symbols()) << std::endl;

  VMExecutorVerify<Op, NoAnalysis> executor(egraph);

  std::vector<EClassId> candidates;
  for (auto id : egraph.canonical_class_ids()) {
    candidates.push_back(id);
  }

  executor.execute(*compiled, candidates, ctx, results);

  // With depth 10 chain, pattern depth 3, we should find (10 - 3 + 1) = 8 matches
  EXPECT_EQ(results.size(), kDepth - 3 + 1)
      << "Expected " << (kDepth - 3 + 1) << " matches for depth-3 pattern on depth-" << kDepth << " chain";
}

TEST_F(VMExecutionTest, VeryDeepNestedPattern) {
  // Create a chain of Neg nodes: Neg(Neg(Neg(...Neg(x)...)))
  constexpr int kDepth = 50;

  auto x = leaf(Op::Const, 0);
  auto current = x;
  for (int i = 0; i < kDepth; ++i) {
    current = node(Op::Neg, current);
  }

  rebuild_egraph();

  // Build a deep pattern dynamically
  constexpr int kPatternDepth = 10;
  auto b = Pattern<Op>::Builder{};
  auto cur = b.var(kVarX);
  for (int i = 0; i < kPatternDepth; ++i) {
    cur = b.sym(Op::Neg, {cur});
  }
  auto pattern = std::move(b).build();

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  std::cout << "Bytecode for depth-" << kPatternDepth << " Neg pattern:\n"
            << disassemble<Op>(compiled->code(), compiled->symbols()) << std::endl;

  VMExecutorVerify<Op, NoAnalysis> executor(egraph);

  std::vector<EClassId> candidates;
  for (auto id : egraph.canonical_class_ids()) {
    candidates.push_back(id);
  }

  executor.execute(*compiled, candidates, ctx, results);

  // With depth 50 chain, pattern depth 10, we should find (50 - 10 + 1) = 41 matches
  EXPECT_EQ(results.size(), kDepth - kPatternDepth + 1)
      << "Expected " << (kDepth - kPatternDepth + 1) << " matches for depth-" << kPatternDepth << " pattern on depth-"
      << kDepth << " chain";
}

// Test that deep patterns compile successfully (dynamic register allocation)
TEST_F(VMExecutionTest, DeepPatternCompiles) {
  // VM now supports dynamic register allocation (up to 256 due to uint8_t)
  // Deep patterns need ~2*depth+1 registers, so depth 35 uses ~71 registers
  constexpr int kPatternDepth = 35;

  auto b = Pattern<Op>::Builder{};
  auto cur = b.var(kVarX);
  for (int i = 0; i < kPatternDepth; ++i) {
    cur = b.sym(Op::Neg, {cur});
  }
  auto pattern = std::move(b).build();

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);

  // Should compile successfully with dynamic registers
  ASSERT_TRUE(compiled.has_value()) << "Deep patterns should compile with dynamic registers";
  // Deep patterns need ~depth eclass registers (LoadChild) and ~depth enode registers (IterENodes)
  EXPECT_GE(compiled->num_eclass_regs() + compiled->num_enode_regs(), kPatternDepth)
      << "Should allocate enough registers";
}

// ============================================================================
// Fused Pattern Compiler Tests
// ============================================================================

class FusedCompilerTest : public VMExecutionTest {};

// Test: Bind(_, ?sym, ?expr) joined with ?id = Ident(?sym)
// This tests parent traversal: after matching Bind, traverse UP from ?sym to find Ident parents
TEST_F(FusedCompilerTest, SimpleJoinWithParentTraversal) {
  // Build e-graph:
  //   sym_val = Const(1)
  //   expr_val = Const(2)
  //   bind_node = Bind(Const(0), sym_val, expr_val)
  //   ident_node = Ident(sym_val)  <- shares sym_val with bind_node
  auto placeholder = leaf(Op::Const, 0);
  auto sym_val = leaf(Op::Const, 1);
  auto expr_val = leaf(Op::Const, 2);
  auto bind_node = node(Op::Bind, placeholder, sym_val, expr_val);
  auto ident_node = node(Op::Ident, sym_val);  // Uses same sym_val!

  rebuild_egraph();

  // Anchor pattern: Bind(_, ?sym, ?expr)
  constexpr PatternVar kVarSym{1};
  constexpr PatternVar kVarExpr{2};
  auto anchor = Pattern<Op>::build(Op::Bind, {Wildcard{}, Var{kVarSym}, Var{kVarExpr}}, kTestRoot);

  // Joined pattern: ?id = Ident(?sym)
  constexpr PatternVar kVarId{3};
  auto joined = Pattern<Op>::build(Op::Ident, {Var{kVarSym}}, kVarId);

  // Compile with PatternCompiler
  PatternCompiler<Op> compiler;
  std::array patterns = {anchor, joined};
  auto compiled = compiler.compile(patterns);

  ASSERT_TRUE(compiled.has_value()) << "Fused compilation should succeed";

  std::cout << "Fused bytecode for Bind(_, ?sym, ?expr) + ?id=Ident(?sym):\n"
            << disassemble<Op>(compiled->code(), compiled->symbols()) << std::endl;

  // Verify bytecode has parent traversal instructions
  bool has_iter_parents = false;
  bool has_next_parent = false;
  bool has_get_enode_eclass = false;

  for (auto const &instr : compiled->code()) {
    if (instr.op == VMOp::IterParentsSym || instr.op == VMOp::IterParents) {
      has_iter_parents = true;
    }
    if (instr.op == VMOp::NextParent || instr.op == VMOp::NextParentFiltered) {
      has_next_parent = true;
    }
    if (instr.op == VMOp::GetENodeEClass) {
      has_get_enode_eclass = true;
    }
  }

  EXPECT_TRUE(has_iter_parents) << "Fused bytecode should have IterParents(Sym) instruction";
  EXPECT_TRUE(has_next_parent) << "Fused bytecode should have NextParent or NextParentFiltered instruction";
  EXPECT_TRUE(has_get_enode_eclass) << "Fused bytecode should have GetENodeEClass for ?id binding";

  // Execute and verify matches
  VMExecutorVerify<Op, NoAnalysis> executor(egraph);

  // Only use the Bind e-class as candidate (anchor pattern entry)
  std::vector<EClassId> candidates = {egraph.find(bind_node)};

  EMatchContext ctx;
  std::vector<PatternMatch> results;
  executor.execute(*compiled, candidates, ctx, results);

  // Should find 1 match: Bind paired with Ident (both reference same sym_val)
  EXPECT_EQ(results.size(), 1) << "Should find exactly 1 match where Bind and Ident share ?sym";

  if (!results.empty()) {
    // The match should contain bindings for kVarSym, kVarExpr, kVarId, and kTestRoot
    // Note: Slot ordering depends on unordered map iteration, so we check all slots
    // to find which one contains each expected value
    auto &match = results[0];
    auto num_slots = compiled->num_slots();

    bool found_sym = false, found_expr = false, found_id = false;
    for (std::size_t i = 0; i < num_slots; ++i) {
      auto bound = ctx.arena().get(match, i);
      if (egraph.find(bound) == egraph.find(sym_val)) found_sym = true;
      if (egraph.find(bound) == egraph.find(expr_val)) found_expr = true;
      if (egraph.find(bound) == egraph.find(ident_node)) found_id = true;
    }

    EXPECT_TRUE(found_sym) << "Match should contain binding for ?sym = sym_val";
    EXPECT_TRUE(found_expr) << "Match should contain binding for ?expr = expr_val";
    EXPECT_TRUE(found_id) << "Match should contain binding for ?id = ident_node";
  }
}

// Test: No matching join - Ident uses different symbol
TEST_F(FusedCompilerTest, NoMatchingJoin) {
  // Build e-graph:
  //   sym_val1 = Const(1)
  //   sym_val2 = Const(2)  <- different from sym_val1
  //   expr_val = Const(3)
  //   bind_node = Bind(Const(0), sym_val1, expr_val)
  //   ident_node = Ident(sym_val2)  <- uses DIFFERENT symbol!
  auto placeholder = leaf(Op::Const, 0);
  auto sym_val1 = leaf(Op::Const, 1);
  auto sym_val2 = leaf(Op::Const, 2);
  auto expr_val = leaf(Op::Const, 3);
  auto bind_node = node(Op::Bind, placeholder, sym_val1, expr_val);
  node(Op::Ident, sym_val2);  // Uses different sym!

  rebuild_egraph();

  // Anchor pattern: Bind(_, ?sym, ?expr)
  constexpr PatternVar kVarSym{1};
  constexpr PatternVar kVarExpr{2};
  auto anchor = Pattern<Op>::build(Op::Bind, {Wildcard{}, Var{kVarSym}, Var{kVarExpr}}, kTestRoot);

  // Joined pattern: ?id = Ident(?sym)
  constexpr PatternVar kVarId{3};
  auto joined = Pattern<Op>::build(Op::Ident, {Var{kVarSym}}, kVarId);

  // Compile and execute
  PatternCompiler<Op> compiler;
  std::array patterns = {anchor, joined};
  auto compiled = compiler.compile(patterns);
  ASSERT_TRUE(compiled.has_value());

  VMExecutorVerify<Op, NoAnalysis> executor(egraph);
  std::vector<EClassId> candidates = {egraph.find(bind_node)};

  EMatchContext ctx;
  std::vector<PatternMatch> results;
  executor.execute(*compiled, candidates, ctx, results);

  // Should find NO matches - Ident doesn't reference the same ?sym
  EXPECT_EQ(results.size(), 0) << "Should find no matches when Ident uses different symbol";
}

// Test: Multiple Ident references to same symbol
// ============================================================================
// Same Variable Correctness Tests
// ============================================================================

// Bug: After Yield clears bound flags, BindOrCheck for repeated variable
// incorrectly rebinds instead of checking when iterating multiple e-nodes.
TEST_F(VMExecutionTest, SameVariableMergedEClass) {
  // Create e-graph with merged e-class containing:
  //   n0 = Add(a, Neg(a))  -- ?x binds to a, Neg child is a, should match
  //   n1 = Add(a, Neg(b))  -- ?x binds to a, Neg child is b, should NOT match
  //
  // After merge(n0, n1), both are in same e-class.
  // Pattern Add(?x, Neg(?x)) should find 1 match (only n0).

  auto a = leaf(Op::Const, 1);
  auto b = leaf(Op::Const, 2);
  auto neg_a = node(Op::Neg, a);
  auto neg_b = node(Op::Neg, b);
  auto n0 = node(Op::Add, a, neg_a);  // Add(a, Neg(a)) - should match
  auto n1 = node(Op::Add, a, neg_b);  // Add(a, Neg(b)) - should NOT match

  // Merge the two Add nodes into same e-class
  merge(n0, n1);
  rebuild_egraph();

  // Verify both Add nodes are in same e-class
  ASSERT_EQ(egraph.find(n0), egraph.find(n1)) << "Both Add nodes should be in same e-class after merge";

  // Pattern: Add(?x, Neg(?x))
  auto pattern = TestPattern::build(Op::Add, {Var{kVarX}, Sym(Op::Neg, Var{kVarX})}, kTestRoot);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);
  ASSERT_TRUE(compiled.has_value());

  std::cout << "Bytecode for Add(?x, Neg(?x)):\n"
            << disassemble<Op>(compiled->code(), compiled->symbols()) << std::endl;

  RecordingTracer tracer;
  VMExecutorVerify<Op, NoAnalysis, RecordingTracer> executor(egraph, &tracer);

  // Use the merged Add e-class as candidate
  std::vector<EClassId> candidates = {egraph.find(n0)};

  EMatchContext ctx;
  std::vector<PatternMatch> results;
  executor.execute(*compiled, candidates, ctx, results);

  std::cout << "Execution trace:\n";
  tracer.print(std::cout);

  std::cout << "Found " << results.size() << " matches:\n";
  for (std::size_t i = 0; i < results.size(); ++i) {
    auto bound_x = ctx.arena().get(results[i], 0);
    std::cout << "  Match " << i << ": ?x = EC" << bound_x.value_of() << "\n";
  }

  // Should find exactly 1 match: Add(a, Neg(a)) where ?x = a
  // Bug would cause 2 matches if second Add(a, Neg(b)) incorrectly matches
  EXPECT_EQ(results.size(), 1) << "Should find exactly 1 match (Add(a, Neg(a))), not 2";
}

// Critical bug test: Inner loop with multiple e-nodes, outer has one
// This specifically tests when Yield clears bound and inner continues
TEST_F(VMExecutionTest, SameVariableInnerLoopMultipleENodes) {
  // Pattern: Add(?x, Neg(?x))
  // E-graph:
  //   a = Const(1)
  //   b = Const(2)
  //   neg_merged = Neg(a) MERGED WITH Neg(b)  <- inner has 2 e-nodes!
  //   add = Add(a, neg_merged)  <- outer has 1 e-node
  //
  // Expected: 1 match (Add(a, Neg(a)))
  // Bug would cause 2 matches (incorrectly matching Add(a, Neg(b)))
  //
  // IMPORTANT: Create neg_b first so neg_a comes SECOND in the e-class.
  // After merge, iteration order is typically: neg_a, neg_b
  // This ensures the matching one (neg_a) is tried first, yields, clears bound,
  // and then neg_b should fail but the bug would cause it to rebind.

  auto a = leaf(Op::Const, 1);
  auto b = leaf(Op::Const, 2);

  // Create neg_b first, then neg_a - this affects iteration order after merge
  auto neg_b = node(Op::Neg, b);
  auto neg_a = node(Op::Neg, a);

  // Merge into neg_b's class (neg_a merges into neg_b)
  // After merge, iteration should be: neg_a, neg_b (insertion order matters)
  merge(neg_b, neg_a);
  rebuild_egraph();

  // Create Add that uses 'a' and the merged Neg e-class
  auto add = node(Op::Add, a, neg_b);  // Uses the merged Neg e-class
  rebuild_egraph();

  // Verify the structure
  auto neg_class = egraph.find(neg_a);
  ASSERT_EQ(egraph.find(neg_b), neg_class) << "Neg nodes should be in same e-class";
  auto const &neg_eclass = egraph.eclass(neg_class);
  ASSERT_EQ(neg_eclass.nodes().size(), 2) << "Neg e-class should have 2 e-nodes";

  // Pattern: Add(?x, Neg(?x))
  auto pattern = TestPattern::build(Op::Add, {Var{kVarX}, Sym(Op::Neg, Var{kVarX})}, kTestRoot);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);
  ASSERT_TRUE(compiled.has_value());

  std::cout << "Bytecode for Add(?x, Neg(?x)) - inner loop bug test:\n"
            << disassemble<Op>(compiled->code(), compiled->symbols()) << std::endl;

  RecordingTracer tracer;
  VMExecutorVerify<Op, NoAnalysis, RecordingTracer> executor(egraph, &tracer);

  std::vector<EClassId> candidates = {egraph.find(add)};

  EMatchContext ctx;
  std::vector<PatternMatch> results;
  executor.execute(*compiled, candidates, ctx, results);

  std::cout << "Execution trace:\n";
  tracer.print(std::cout);

  std::cout << "Found " << results.size() << " matches:\n";
  for (std::size_t i = 0; i < results.size(); ++i) {
    auto bound_x = ctx.arena().get(results[i], 0);
    std::cout << "  Match " << i << ": ?x = EC" << bound_x.value_of() << "\n";
  }

  // CRITICAL: Should find exactly 1 match
  // The inner loop iterates Neg(a) and Neg(b).
  // - Neg(a): ?x = a, child = a, check passes -> Yield
  // - Neg(b): ?x should still be bound to a, child = b, check should FAIL
  // Bug: After Yield, bound is cleared, so ?x gets rebound to b, and we get
  // an incorrect second match.
  EXPECT_EQ(results.size(), 1) << "Should find exactly 1 match. Bug causes 2 matches.";
}

// Additional test: Three e-nodes, only one matches
TEST_F(VMExecutionTest, SameVariableMultipleMergedENodes) {
  // n0 = Add(a, Neg(a))  -- matches
  // n1 = Add(a, Neg(b))  -- no match
  // n2 = Add(b, Neg(b))  -- matches

  auto a = leaf(Op::Const, 1);
  auto b = leaf(Op::Const, 2);
  auto neg_a = node(Op::Neg, a);
  auto neg_b = node(Op::Neg, b);
  auto n0 = node(Op::Add, a, neg_a);  // matches
  auto n1 = node(Op::Add, a, neg_b);  // no match
  auto n2 = node(Op::Add, b, neg_b);  // matches

  // Merge all into same e-class
  merge(n0, n1);
  merge(n1, n2);
  rebuild_egraph();

  // Pattern: Add(?x, Neg(?x))
  auto pattern = TestPattern::build(Op::Add, {Var{kVarX}, Sym(Op::Neg, Var{kVarX})}, kTestRoot);

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(pattern);
  ASSERT_TRUE(compiled.has_value());

  VMExecutorVerify<Op, NoAnalysis> executor(egraph);
  std::vector<EClassId> candidates = {egraph.find(n0)};

  EMatchContext ctx;
  std::vector<PatternMatch> results;
  executor.execute(*compiled, candidates, ctx, results);

  // Should find 2 matches: Add(a, Neg(a)) and Add(b, Neg(b))
  EXPECT_EQ(results.size(), 2) << "Should find 2 matches (Add(a,Neg(a)) and Add(b,Neg(b)))";
}

TEST_F(FusedCompilerTest, MultipleJoinMatches) {
  // Build e-graph:
  //   sym_val = Const(1)
  //   expr_val = Const(2)
  //   bind_node = Bind(Const(0), sym_val, expr_val)
  //   ident1 = Ident(sym_val)
  //   ident2 = Ident(sym_val)  <- second Ident referencing same symbol
  auto placeholder = leaf(Op::Const, 0);
  auto sym_val = leaf(Op::Const, 1);
  auto expr_val = leaf(Op::Const, 2);
  auto bind_node = node(Op::Bind, placeholder, sym_val, expr_val);
  auto ident1 = node(Op::Ident, sym_val);
  auto ident2 = node(Op::Ident, sym_val);  // Second Ident

  rebuild_egraph();

  // Anchor pattern: Bind(_, ?sym, ?expr)
  constexpr PatternVar kVarSym{1};
  constexpr PatternVar kVarExpr{2};
  auto anchor = Pattern<Op>::build(Op::Bind, {Wildcard{}, Var{kVarSym}, Var{kVarExpr}}, kTestRoot);

  // Joined pattern: ?id = Ident(?sym)
  constexpr PatternVar kVarId{3};
  auto joined = Pattern<Op>::build(Op::Ident, {Var{kVarSym}}, kVarId);

  // Compile and execute
  PatternCompiler<Op> compiler;
  std::array patterns = {anchor, joined};
  auto compiled = compiler.compile(patterns);
  ASSERT_TRUE(compiled.has_value());

  std::cout << "Fused bytecode (multiple Idents):\n"
            << disassemble<Op>(compiled->code(), compiled->symbols()) << std::endl;

  VMExecutorVerify<Op, NoAnalysis> executor(egraph);
  std::vector<EClassId> candidates = {egraph.find(bind_node)};

  EMatchContext ctx;
  std::vector<PatternMatch> results;
  executor.execute(*compiled, candidates, ctx, results);

  // Debug: Check how many parents sym_val has
  auto sym_canonical = egraph.find(sym_val);
  auto const &sym_eclass = egraph.eclass(sym_canonical);
  std::cout << "sym_val e-class " << sym_canonical << " has " << sym_eclass.parents().size() << " parents\n";
  for (auto parent_id : sym_eclass.parents()) {
    auto const &parent = egraph.get_enode(parent_id);
    std::cout << "  Parent: enode " << parent_id << " symbol=" << static_cast<int>(parent.symbol()) << "\n";
  }

  // Debug: Check if ident1 and ident2 are in different e-classes
  std::cout << "ident1 e-class: " << egraph.find(ident1) << "\n";
  std::cout << "ident2 e-class: " << egraph.find(ident2) << "\n";

  // Note: If both ident nodes have the same structure Ident(sym_val), they might
  // be in the same e-class due to structural sharing. In that case, there's only
  // 1 Ident e-class, so only 1 match.
  // Let's check what we actually expect:
  bool idents_same_eclass = (egraph.find(ident1) == egraph.find(ident2));
  std::size_t expected_matches = idents_same_eclass ? 1 : 2;

  EXPECT_EQ(results.size(), expected_matches)
      << "Should find " << expected_matches << " matches (idents same e-class: " << idents_same_eclass << ")";
}

// Test PatternsCompiler with nested patterns in joined patterns
// This tests the emit_joined_child recursive handling for patterns with
// nested symbol structures that share a variable
class FusedPatternNestedTest : public EGraphTestBase {};

TEST_F(FusedPatternNestedTest, NestedJoinedPatternViaParentTraversal) {
  // Build e-graph:
  // We want to test nested symbol patterns in joined patterns.
  // Anchor: Bind(_, ?sym, _) matches bind_node
  // Joined: F(?sym, Neg(?x)) - has nested Neg with shared ?sym as direct child
  //
  // This tests that when the joined pattern has nested symbols, they are
  // compiled correctly via emit_joined_child recursion.

  constexpr PatternVar kVarSym{0};
  constexpr PatternVar kVarX{1};
  constexpr PatternVar kTestRoot{2};

  // Build: sym_val, x_val, Neg(x_val), F(sym_val, Neg(x_val)), Bind(_, sym_val, _)
  auto sym_val = leaf(Op::Const, 1);
  auto x_val = leaf(Op::Const, 2);
  auto neg_x = node(Op::Neg, x_val);
  auto f_node = node(Op::F, sym_val, neg_x);
  auto bind_node = node(Op::Bind, leaf(Op::A), sym_val, leaf(Op::B));

  // Anchor pattern: Bind(_, ?sym, _)
  auto anchor = Pattern<Op>::build(Op::Bind, {Wildcard{}, Var{kVarSym}, Wildcard{}}, kTestRoot);

  // Joined pattern: F(?sym, Neg(?x)) - nested Neg symbol with shared ?sym
  auto joined = Pattern<Op>::build(Op::F, {Var{kVarSym}, Sym(Op::Neg, Var{kVarX})});

  PatternCompiler<Op> compiler;
  std::array patterns = {anchor, joined};
  auto compiled = compiler.compile(patterns);
  ASSERT_TRUE(compiled.has_value()) << "Fused compilation should succeed";

  std::cout << "Fused bytecode (nested joined pattern with parent traversal):\n"
            << disassemble<Op>(compiled->code(), compiled->symbols()) << std::endl;

  VMExecutorVerify<Op, NoAnalysis> executor(egraph);
  std::vector<EClassId> candidates = {egraph.find(bind_node)};

  EMatchContext ctx;
  std::vector<PatternMatch> results;
  executor.execute(*compiled, candidates, ctx, results);

  EXPECT_EQ(results.size(), 1) << "Should find 1 match for nested pattern";

  // Check that we found all the right bindings - collect bound values
  if (!results.empty()) {
    std::set<EClassId> bound_values;
    auto num_slots = compiled->num_slots();
    for (std::size_t i = 0; i < num_slots; ++i) {
      bound_values.insert(ctx.arena().get(results[0], i));
    }
    // Should have bound: bind_node (root), sym_val, x_val
    EXPECT_TRUE(bound_values.count(egraph.find(bind_node)) > 0 || bound_values.count(egraph.find(sym_val)) > 0)
        << "Should have bound sym_val or bind_node";
    EXPECT_TRUE(bound_values.count(egraph.find(x_val)) > 0) << "Should have bound x_val";
  }
}

// Test PatternsCompiler with deeply nested symbols in Cartesian product join
TEST_F(FusedPatternNestedTest, DeeplyNestedCartesianPattern) {
  // Build e-graph with deeply nested structure
  // The joined pattern has no shared variable at direct child level,
  // so it uses Cartesian product. This tests emit_joined_child recursion
  // in the Cartesian product path.

  constexpr PatternVar kVarX{0};
  constexpr PatternVar kVarY{1};
  constexpr PatternVar kVarZ{2};

  // Create: x, Neg(x), Neg(Neg(x)), y, Add(y, Neg(Neg(x)))
  auto x = leaf(Op::Const, 1);
  auto y = leaf(Op::Const, 2);
  auto neg_x = node(Op::Neg, x);
  auto neg_neg_x = node(Op::Neg, neg_x);
  auto add_node = node(Op::Add, y, neg_neg_x);

  // Anchor pattern: Add(?y, ?x) - ?x will bind to Neg(Neg(x))
  auto anchor = Pattern<Op>::build(Op::Add, {Var{kVarY}, Var{kVarX}});

  // Joined pattern: Neg(Neg(?z)) - deeply nested, no direct shared var with anchor
  // This forces Cartesian product with recursive compilation
  auto joined = Pattern<Op>::build(Op::Neg, {Sym(Op::Neg, Var{kVarZ})});

  // Compiler will detect shared variables automatically
  PatternCompiler<Op> compiler;
  std::array patterns = {anchor, joined};
  auto compiled = compiler.compile(patterns);
  ASSERT_TRUE(compiled.has_value()) << "Fused compilation should succeed";

  std::cout << "Fused bytecode (deeply nested Cartesian):\n"
            << disassemble<Op>(compiled->code(), compiled->symbols()) << std::endl;

  VMExecutorVerify<Op, NoAnalysis> executor(egraph);
  std::vector<EClassId> candidates = {egraph.find(add_node)};

  EMatchContext ctx;
  std::vector<PatternMatch> results;
  executor.execute(*compiled, candidates, ctx, results);

  // Should find at least one match
  EXPECT_GE(results.size(), 1) << "Should find matches for nested pattern";

  std::cout << "Found " << results.size() << " matches\n";
  for (std::size_t i = 0; i < results.size(); ++i) {
    std::cout << "  Match " << i << ": ";
    for (std::size_t j = 0; j < compiled->num_slots(); ++j) {
      std::cout << "slot[" << j << "]=" << ctx.arena().get(results[i], j).value_of() << " ";
    }
    std::cout << "\n";
  }
}

// Test that verifies bytecode structure for Cartesian product joins
// This tests that IterAllEClasses and NextEClass instructions are generated
TEST_F(FusedPatternNestedTest, CartesianProductBytecodeStructure) {
  // Build minimal e-graph
  auto x = leaf(Op::Const, 1);
  auto y = leaf(Op::Const, 2);
  auto add_node = node(Op::Add, x, y);

  // Anchor pattern: Add(?x, ?y)
  constexpr PatternVar kVarX{0};
  constexpr PatternVar kVarY{1};
  constexpr PatternVar kVarZ{2};
  auto anchor = Pattern<Op>::build(Op::Add, {Var{kVarX}, Var{kVarY}});

  // Joined pattern: Neg(?z) - no shared variable with anchor
  // This forces Cartesian product join
  auto joined = Pattern<Op>::build(Op::Neg, {Var{kVarZ}});

  PatternCompiler<Op> compiler;
  // No shared vars between patterns forces Cartesian product
  std::array patterns = {anchor, joined};
  auto compiled = compiler.compile(patterns);
  ASSERT_TRUE(compiled.has_value()) << "Fused compilation should succeed";

  std::cout << "Fused bytecode (Cartesian product):\n"
            << disassemble<Op>(compiled->code(), compiled->symbols()) << std::endl;

  // Verify bytecode has IterAllEClasses and NextEClass instructions
  bool has_iter_all_eclasses = false;
  bool has_next_eclass = false;

  for (auto const &instr : compiled->code()) {
    if (instr.op == VMOp::IterAllEClasses) {
      has_iter_all_eclasses = true;
    }
    if (instr.op == VMOp::NextEClass) {
      has_next_eclass = true;
    }
  }

  EXPECT_TRUE(has_iter_all_eclasses) << "Cartesian product bytecode should have IterAllEClasses instruction";
  EXPECT_TRUE(has_next_eclass) << "Cartesian product bytecode should have NextEClass instruction";
}

// Test the simplified compile(patterns) API that computes join order internally
TEST_F(FusedPatternNestedTest, SimplifiedCompileAPI) {
  // Build e-graph with shared variables between patterns
  auto sym_val = leaf(Op::Const, 1);
  auto expr_val = leaf(Op::Const, 2);
  auto bind_node = node(Op::Bind, leaf(Op::A), sym_val, expr_val);
  auto ident_node = node(Op::Ident, sym_val);

  // Create patterns - order doesn't matter, compiler figures out optimal join order
  constexpr PatternVar kVarSym{1};
  constexpr PatternVar kVarExpr{2};
  constexpr PatternVar kVarId{3};
  constexpr PatternVar kTestRoot{0};

  auto bind_pattern = Pattern<Op>::build(Op::Bind, {Wildcard{}, Var{kVarSym}, Var{kVarExpr}}, kTestRoot);
  auto ident_pattern = Pattern<Op>::build(Op::Ident, {Var{kVarSym}}, kVarId);

  // Use simplified API - just pass all patterns
  std::array<Pattern<Op>, 2> patterns = {bind_pattern, ident_pattern};

  PatternCompiler<Op> compiler;
  auto compiled = compiler.compile(patterns);

  ASSERT_TRUE(compiled.has_value()) << "Simplified compile API should succeed";

  std::cout << "Fused bytecode (simplified API):\n"
            << disassemble<Op>(compiled->code(), compiled->symbols()) << std::endl;

  // Execute and verify matches work
  VMExecutorVerify<Op, NoAnalysis> executor(egraph);
  std::vector<EClassId> candidates = {egraph.find(bind_node)};

  EMatchContext ctx;
  std::vector<PatternMatch> results;
  executor.execute(*compiled, candidates, ctx, results);

  EXPECT_EQ(results.size(), 1) << "Should find 1 match using simplified API";
}

// Test that verifies bytecode structure for variable-only joined patterns
TEST_F(FusedPatternNestedTest, VariableOnlyJoinedPatternBytecode) {
  // Build minimal e-graph
  auto x = leaf(Op::Const, 1);
  auto add_node = node(Op::Add, x, x);

  // Anchor pattern: Add(?x, ?y)
  constexpr PatternVar kVarX{0};
  constexpr PatternVar kVarY{1};
  constexpr PatternVar kVarZ{2};
  auto anchor = Pattern<Op>::build(Op::Add, {Var{kVarX}, Var{kVarY}});

  // Joined pattern: ?z - just a variable, no symbol
  // This tests variable-only pattern handling
  auto joined_builder = TestPattern::Builder{};
  joined_builder.var(kVarZ);
  auto joined = std::move(joined_builder).build();

  PatternCompiler<Op> compiler;
  // No shared vars between patterns
  std::array patterns = {anchor, joined};
  auto compiled = compiler.compile(patterns);
  ASSERT_TRUE(compiled.has_value()) << "Fused compilation should succeed for variable-only joined pattern";

  std::cout << "Fused bytecode (variable-only joined pattern):\n"
            << disassemble<Op>(compiled->code(), compiled->symbols()) << std::endl;

  // Verify bytecode has IterAllEClasses for the variable-only pattern
  bool has_iter_all_eclasses = false;
  bool has_next_eclass = false;

  for (auto const &instr : compiled->code()) {
    if (instr.op == VMOp::IterAllEClasses) {
      has_iter_all_eclasses = true;
    }
    if (instr.op == VMOp::NextEClass) {
      has_next_eclass = true;
    }
  }

  EXPECT_TRUE(has_iter_all_eclasses) << "Variable-only joined pattern should use IterAllEClasses";
  EXPECT_TRUE(has_next_eclass) << "Variable-only joined pattern should use NextEClass";
}

}  // namespace memgraph::planner::core
