// Copyright 2026 Memgraph Ltd.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt; by using this file, you agree to be bound by the terms of the Business Source
// License, and you may not use this file except in compliance with the Business Source License.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

#pragma once

#include <optional>
#include <variant>
#include <vector>

#include <boost/unordered/unordered_flat_map.hpp>

#include "planner/pattern/pattern.hpp"
#include "planner/pattern/vm/executor.hpp"
#include "planner/pattern/vm/instruction.hpp"

namespace memgraph::planner::core::vm {

/// Compiler for single patterns
///
/// Compiles a Pattern<Symbol> into bytecode for VMExecutor.
///
/// Generated bytecode structure for pattern `Sym(child1, child2)`:
/// ```
/// 0:  IterENodes r1, r0, @end     ; iterate e-nodes in input e-class
/// 1:  NextENode r1, @end          ; advance, or jump to end
/// 2:  CheckSymbol r1, sym, @1     ; wrong symbol -> try next e-node
/// 3:  CheckArity r1, 2, @1        ; wrong arity -> try next e-node
/// 4:  [BindSlot if node has binding]
/// 5:  LoadChild r2, r1, 0         ; load child[0]
/// 6:  [emit child1, backtrack to @1]
/// 7:  LoadChild r3, r1, 1         ; load child[1]
/// 8:  [emit child2, backtrack to @1]
/// 9:  Yield                       ; (only at root)
/// 10: Jump @1                     ; try next e-node
/// end:
/// 11: Halt                        ; (only at root)
/// ```
template <typename Symbol>
class PatternCompiler {
 public:
  enum class Mode {
    Verify,  // Always verify child consistency
    Clean,   // Trust parent index, skip verification
  };

  explicit PatternCompiler(Mode mode = Mode::Verify) : mode_(mode) {}

  /// Compile a single pattern into bytecode
  /// Returns std::nullopt if the pattern exceeds the VM's register limit
  auto compile(Pattern<Symbol> const &pattern) -> std::optional<CompiledPattern<Symbol>> {
    code_.clear();
    symbols_.clear();
    next_reg_ = 1;  // r0 is reserved for entry candidate
    register_overflow_ = false;

    // Get entry symbol for index lookup
    std::optional<Symbol> entry_symbol;
    auto const &root_node = pattern[pattern.root()];
    if (auto const *sym = std::get_if<SymbolWithChildren<Symbol>>(&root_node)) {
      entry_symbol = sym->sym;
    }

    // Placeholder for halt position (will be patched)
    // For root node, backtrack target is the halt instruction
    auto halt_pos = static_cast<uint16_t>(0xFFFF);  // Placeholder, will patch

    // Emit code starting from root
    emit_pattern_node(pattern, pattern.root(), 0, halt_pos, true);

    // Check for register overflow
    if (register_overflow_) {
      return std::nullopt;
    }

    // Patch all halt placeholders
    auto actual_halt = static_cast<uint16_t>(code_.size());
    for (auto &instr : code_) {
      if (instr.target == 0xFFFF) {
        instr.target = actual_halt;
      }
    }

    // Add halt instruction
    code_.push_back(Instruction::halt());

    return CompiledPattern<Symbol>(std::move(code_), pattern.num_vars(), std::move(symbols_), entry_symbol);
  }

  /// Get the compiled bytecode (for testing)
  [[nodiscard]] auto code() const -> std::vector<Instruction> const & { return code_; }

  /// Get the symbol table (for testing)
  [[nodiscard]] auto symbols() const -> std::vector<Symbol> const & { return symbols_; }

 private:
  /// Emit code for a pattern node
  /// @param pattern The pattern being compiled
  /// @param node_id The current pattern node
  /// @param eclass_reg Register containing the e-class to match against
  /// @param backtrack_target Where to jump on failure (try next e-node or halt)
  /// @param is_root True if this is the root node (emit Yield)
  /// @return The innermost loop position (for continuing iteration after yield)
  auto emit_pattern_node(Pattern<Symbol> const &pattern, PatternNodeId node_id, uint8_t eclass_reg,
                         uint16_t backtrack_target, bool is_root) -> uint16_t {
    auto const &node = pattern[node_id];
    uint16_t innermost_loop = backtrack_target;  // Default: backtrack to parent

    std::visit(
        [&](auto const &n) {
          using T = std::decay_t<decltype(n)>;
          if constexpr (std::is_same_v<T, Wildcard>) {
            // Wildcard matches anything, no code needed
            // But if root, still need to yield
            if (is_root) {
              code_.push_back(Instruction::yield());
            }
            // For wildcards, innermost loop is the backtrack target
          } else if constexpr (std::is_same_v<T, PatternVar>) {
            // Variable: bind or check
            auto slot = pattern.var_slot(n);
            code_.push_back(Instruction::bind_or_check(static_cast<uint8_t>(slot), eclass_reg, backtrack_target));
            if (is_root) {
              code_.push_back(Instruction::yield());
            }
            // For variables, innermost loop is the backtrack target
          } else if constexpr (std::is_same_v<T, SymbolWithChildren<Symbol>>) {
            innermost_loop = emit_symbol_node(pattern, node_id, n, eclass_reg, backtrack_target, is_root);
          }
        },
        node);

    return innermost_loop;
  }

  /// Emit code for a symbol node with children
  ///
  /// Generated structure:
  /// ```
  ///   IterENodes r1, r0, @backtrack   ; load first e-node, jump if empty
  ///   Jump @check                     ; skip NextENode on first iteration
  /// loop:
  ///   NextENode r1, @backtrack        ; advance to next, jump if exhausted
  /// check:
  ///   CheckSymbol r1, sym, @loop      ; wrong symbol -> try next
  ///   CheckArity r1, N, @loop         ; wrong arity -> try next
  ///   [BindSlot if node has binding]
  ///   [emit children, backtracking to @loop]
  ///   [Yield if root, then Jump to innermost loop]
  /// ```
  /// @return The loop position of this symbol node (for parent to use as innermost loop)
  auto emit_symbol_node(Pattern<Symbol> const &pattern, PatternNodeId node_id, SymbolWithChildren<Symbol> const &sym,
                        uint8_t eclass_reg, uint16_t backtrack_target, bool is_root) -> uint16_t {
    auto sym_idx = get_symbol_index(sym.sym);
    auto enode_reg = alloc_reg();

    // IterENodes: start iterating e-nodes in the e-class
    // On empty, jump to backtrack target (parent's loop or halt)
    code_.push_back(Instruction::iter_enodes(enode_reg, eclass_reg, backtrack_target));

    // Jump past NextENode on first iteration (IterENodes already loaded first element)
    auto jump_to_check_pos = static_cast<uint16_t>(code_.size());
    code_.push_back(Instruction::jmp(0));  // Placeholder, will patch

    // NextENode: advance to next e-node (loop comes back here)
    auto loop_pos = static_cast<uint16_t>(code_.size());
    code_.push_back(Instruction::next_enode(enode_reg, backtrack_target));

    // Patch the jump to skip to after NextENode
    auto check_pos = static_cast<uint16_t>(code_.size());
    code_[jump_to_check_pos].target = check_pos;

    // CheckSymbol: if symbol doesn't match, try next e-node
    code_.push_back(Instruction::check_symbol(enode_reg, sym_idx, loop_pos));

    // CheckArity: if arity doesn't match, try next e-node
    code_.push_back(Instruction::check_arity(enode_reg, static_cast<uint8_t>(sym.children.size()), loop_pos));

    // Bind this node's e-class if it has a binding
    if (auto binding = pattern.binding_for(node_id)) {
      auto slot = pattern.var_slot(*binding);
      code_.push_back(Instruction::bind_slot(static_cast<uint8_t>(slot), eclass_reg));
    }

    // Process children - they backtrack to THIS node's loop (try next e-node)
    // Track the innermost loop from children
    uint16_t innermost_loop = loop_pos;  // Default to this node's loop
    for (std::size_t i = 0; i < sym.children.size(); ++i) {
      auto child_reg = alloc_reg();
      code_.push_back(Instruction::load_child(child_reg, enode_reg, static_cast<uint8_t>(i)));
      // Children backtrack to loop_pos to try next e-node in THIS e-class
      auto child_innermost = emit_pattern_node(pattern, sym.children[i], child_reg, loop_pos, false);
      // Update innermost loop to the deepest child's loop
      innermost_loop = child_innermost;
    }

    // At this point, we've matched this symbol node and all its children.
    // For root: yield the match, then try more combinations starting from innermost loop
    // For non-root: fall through to parent (which will yield or continue)
    if (is_root) {
      code_.push_back(Instruction::yield());
      // After yielding, continue from the innermost loop to try all combinations
      code_.push_back(Instruction::jmp(innermost_loop));
    }

    // Return this node's loop position so parent knows where to continue
    return loop_pos;
  }

  auto get_symbol_index(Symbol const &sym) -> uint8_t {
    for (std::size_t i = 0; i < symbols_.size(); ++i) {
      if (symbols_[i] == sym) {
        return static_cast<uint8_t>(i);
      }
    }
    symbols_.push_back(sym);
    return static_cast<uint8_t>(symbols_.size() - 1);
  }

  auto alloc_reg() -> uint8_t {
    if (next_reg_ >= kMaxRegisters) {
      register_overflow_ = true;
      return 0;  // Return dummy value, compilation will fail
    }
    return next_reg_++;
  }

  Mode mode_;
  std::vector<Instruction> code_;
  std::vector<Symbol> symbols_;
  uint8_t next_reg_{1};
  bool register_overflow_{false};
};

/// Compiler for multi-pattern rules with parent traversal fusion
///
/// Compiles an anchor pattern with joined patterns that share variables.
/// Uses parent traversal to efficiently find joined pattern matches.
///
/// Example: `Bind(_, ?sym, ?expr)` anchor with `?id = Ident(?sym)` joined
///
/// Generated bytecode structure:
/// ```
/// # ===== Anchor: Bind(_, ?sym, ?expr) =====
/// 0:  IterENodes r1, r0, @halt
/// ... (anchor matching code)
/// N:  BindSlot slot[sym], rX          ; bind shared variable
///
/// # ===== Join: ?id = Ident(?sym) via parent traversal =====
/// N+1: IterParentsSym r_p, rX, Ident, @anchor_loop  ; iterate Ident parents of ?sym
/// N+2: Jump @check
/// N+3: NextParent r_p, @anchor_loop
/// N+4: CheckArity r_p, 1, @N+3
/// N+5: GetENodeEClass r_id, r_p       ; get e-class for ?id
/// N+6: BindSlot slot[id], r_id
///
/// N+7: Yield
/// N+8: Jump @N+3                      ; try more join matches
/// halt:
/// N+9: Halt
/// ```
template <typename Symbol>
class FusedPatternCompiler {
 public:
  enum class Mode {
    Verify,
    Clean,
  };

  explicit FusedPatternCompiler(Mode mode = Mode::Verify) : mode_(mode) {}

  /// Compile anchor with joined patterns
  ///
  /// @param anchor The anchor pattern to match first
  /// @param joined Patterns to join via shared variables (using parent traversal)
  /// @param shared_vars Variables that appear in both anchor and at least one joined pattern
  /// @return Compiled bytecode or nullopt if patterns exceed register limit
  auto compile(Pattern<Symbol> const &anchor, std::vector<Pattern<Symbol>> const &joined,
               std::vector<PatternVar> const &shared_vars) -> std::optional<CompiledPattern<Symbol>> {
    code_.clear();
    symbols_.clear();
    next_reg_ = 1;  // r0 is reserved for entry candidate
    register_overflow_ = false;
    slot_map_.clear();

    // If no joined patterns, fall back to single pattern compilation
    if (joined.empty()) {
      PatternCompiler<Symbol> single_compiler(mode_ == Mode::Verify ? PatternCompiler<Symbol>::Mode::Verify
                                                                    : PatternCompiler<Symbol>::Mode::Clean);
      return single_compiler.compile(anchor);
    }

    // Build unified slot map: anchor vars first, then unique joined vars
    build_slot_map(anchor, joined);

    // Get entry symbol for index lookup
    std::optional<Symbol> entry_symbol;
    auto const &root_node = anchor[anchor.root()];
    if (auto const *sym = std::get_if<SymbolWithChildren<Symbol>>(&root_node)) {
      entry_symbol = sym->sym;
    }

    // Placeholder for halt position
    auto halt_pos = static_cast<uint16_t>(0xFFFF);

    // Emit anchor pattern (returns innermost loop position)
    // Don't emit yield - we'll do that after all joins
    auto anchor_innermost = emit_anchor_pattern(anchor, 0, halt_pos);

    if (register_overflow_) {
      return std::nullopt;
    }

    // Track innermost loop across all joins for the final yield
    uint16_t innermost_loop = anchor_innermost;

    // Emit joined patterns using parent traversal
    for (auto const &join_pattern : joined) {
      auto join_innermost = emit_joined_pattern(join_pattern, shared_vars, anchor, innermost_loop);
      if (register_overflow_) {
        return std::nullopt;
      }
      innermost_loop = join_innermost;
    }

    // Now emit Yield and jump back to innermost loop
    code_.push_back(Instruction::yield());
    code_.push_back(Instruction::jmp(innermost_loop));

    // Patch all halt placeholders
    auto actual_halt = static_cast<uint16_t>(code_.size());
    for (auto &instr : code_) {
      if (instr.target == 0xFFFF) {
        instr.target = actual_halt;
      }
    }

    // Add halt instruction
    code_.push_back(Instruction::halt());

    return CompiledPattern<Symbol>(std::move(code_), slot_map_.size(), std::move(symbols_), entry_symbol);
  }

 private:
  /// Build unified slot map for all patterns
  void build_slot_map(Pattern<Symbol> const &anchor, std::vector<Pattern<Symbol>> const &joined) {
    // Add anchor variables first
    for (auto const &[var, _slot] : anchor.var_slots()) {
      if (slot_map_.find(var) == slot_map_.end()) {
        slot_map_[var] = slot_map_.size();
      }
    }

    // Add unique joined pattern variables
    for (auto const &pattern : joined) {
      for (auto const &[var, _slot] : pattern.var_slots()) {
        if (slot_map_.find(var) == slot_map_.end()) {
          slot_map_[var] = slot_map_.size();
        }
      }
    }
  }

  /// Get global slot for a variable
  auto get_slot(PatternVar var) const -> uint8_t {
    auto it = slot_map_.find(var);
    if (it != slot_map_.end()) {
      return static_cast<uint8_t>(it->second);
    }
    return 0;  // Should not happen if slot map is built correctly
  }

  /// Emit anchor pattern code (without yield)
  auto emit_anchor_pattern(Pattern<Symbol> const &pattern, uint8_t eclass_reg, uint16_t backtrack_target) -> uint16_t {
    auto const &node = pattern[pattern.root()];
    uint16_t innermost_loop = backtrack_target;

    std::visit(
        [&](auto const &n) {
          using T = std::decay_t<decltype(n)>;
          if constexpr (std::is_same_v<T, Wildcard>) {
            // Wildcard matches anything, no code needed
          } else if constexpr (std::is_same_v<T, PatternVar>) {
            // Variable: bind or check
            auto slot = get_slot(n);
            code_.push_back(Instruction::bind_or_check(slot, eclass_reg, backtrack_target));
          } else if constexpr (std::is_same_v<T, SymbolWithChildren<Symbol>>) {
            innermost_loop = emit_anchor_symbol_node(pattern, pattern.root(), n, eclass_reg, backtrack_target);
          }
        },
        node);

    return innermost_loop;
  }

  /// Emit anchor symbol node (without yield at end)
  auto emit_anchor_symbol_node(Pattern<Symbol> const &pattern, PatternNodeId node_id,
                               SymbolWithChildren<Symbol> const &sym, uint8_t eclass_reg, uint16_t backtrack_target)
      -> uint16_t {
    auto sym_idx = get_symbol_index(sym.sym);
    auto enode_reg = alloc_reg();

    // IterENodes: start iterating e-nodes in the e-class
    code_.push_back(Instruction::iter_enodes(enode_reg, eclass_reg, backtrack_target));

    // Jump past NextENode on first iteration
    auto jump_to_check_pos = static_cast<uint16_t>(code_.size());
    code_.push_back(Instruction::jmp(0));

    // NextENode: advance to next e-node (loop comes back here)
    auto loop_pos = static_cast<uint16_t>(code_.size());
    code_.push_back(Instruction::next_enode(enode_reg, backtrack_target));

    // Patch the jump
    code_[jump_to_check_pos].target = static_cast<uint16_t>(code_.size());

    // CheckSymbol and CheckArity
    code_.push_back(Instruction::check_symbol(enode_reg, sym_idx, loop_pos));
    code_.push_back(Instruction::check_arity(enode_reg, static_cast<uint8_t>(sym.children.size()), loop_pos));

    // Bind this node's e-class if it has a binding
    if (auto binding = pattern.binding_for(node_id)) {
      auto slot = get_slot(*binding);
      code_.push_back(Instruction::bind_slot(slot, eclass_reg));
    }

    // Process children
    uint16_t innermost_loop = loop_pos;
    for (std::size_t i = 0; i < sym.children.size(); ++i) {
      auto child_reg = alloc_reg();
      code_.push_back(Instruction::load_child(child_reg, enode_reg, static_cast<uint8_t>(i)));
      auto child_innermost = emit_anchor_child(pattern, sym.children[i], child_reg, loop_pos);
      innermost_loop = child_innermost;
    }

    return innermost_loop;
  }

  /// Emit anchor child node
  auto emit_anchor_child(Pattern<Symbol> const &pattern, PatternNodeId node_id, uint8_t eclass_reg,
                         uint16_t backtrack_target) -> uint16_t {
    auto const &node = pattern[node_id];
    uint16_t innermost_loop = backtrack_target;

    std::visit(
        [&](auto const &n) {
          using T = std::decay_t<decltype(n)>;
          if constexpr (std::is_same_v<T, Wildcard>) {
            // Wildcard matches anything
          } else if constexpr (std::is_same_v<T, PatternVar>) {
            auto slot = get_slot(n);
            code_.push_back(Instruction::bind_or_check(slot, eclass_reg, backtrack_target));
            // Track this register for parent traversal from this variable
            var_to_reg_[n] = eclass_reg;
          } else if constexpr (std::is_same_v<T, SymbolWithChildren<Symbol>>) {
            innermost_loop = emit_anchor_symbol_node(pattern, node_id, n, eclass_reg, backtrack_target);
          }
        },
        node);

    return innermost_loop;
  }

  /// Emit joined pattern using parent traversal
  ///
  /// For pattern `?id = Ident(?sym)` where ?sym is shared:
  /// - Find Ident parents of ?sym's e-class
  /// - Bind ?id to the parent's e-class
  auto emit_joined_pattern(Pattern<Symbol> const &pattern, std::vector<PatternVar> const &shared_vars,
                           Pattern<Symbol> const &anchor, uint16_t anchor_backtrack) -> uint16_t {
    auto const &root_node = pattern[pattern.root()];

    // Must be a symbol node for parent traversal
    auto const *sym = std::get_if<SymbolWithChildren<Symbol>>(&root_node);
    if (!sym) {
      // Can't do parent traversal on variable/wildcard root
      // TODO: Handle this case differently
      return anchor_backtrack;
    }

    // Find which child is the shared variable
    std::optional<std::size_t> shared_child_idx;
    PatternVar shared_var{};

    for (std::size_t i = 0; i < sym->children.size(); ++i) {
      auto const &child_node = pattern[sym->children[i]];
      if (auto const *var = std::get_if<PatternVar>(&child_node)) {
        // Check if this variable is shared
        for (auto const &sv : shared_vars) {
          if (*var == sv) {
            shared_child_idx = i;
            shared_var = sv;
            break;
          }
        }
        if (shared_child_idx) break;
      }
    }

    if (!shared_child_idx) {
      // No shared variable found as direct child - can't use simple parent traversal
      // TODO: Handle more complex cases (shared var deeper in tree)
      return anchor_backtrack;
    }

    // Get the register holding the shared variable's e-class
    auto shared_var_it = var_to_reg_.find(shared_var);
    if (shared_var_it == var_to_reg_.end()) {
      // Shared variable wasn't captured in anchor's var_to_reg_ map
      // This happens if the variable binding didn't go through emit_anchor_child
      // TODO: Support loading from slot - would need a LoadSlot instruction
      return anchor_backtrack;
    }

    auto shared_eclass_reg = shared_var_it->second;

    // Get symbol index for parent filter
    auto parent_sym_idx = get_symbol_index(sym->sym);

    // Allocate register for parent e-node
    auto parent_reg = alloc_reg();

    // IterParentsSym: iterate parents with this symbol
    code_.push_back(Instruction::iter_parents_sym(parent_reg, shared_eclass_reg, parent_sym_idx, anchor_backtrack));

    // Jump past NextParent on first iteration
    auto jump_to_check_pos = static_cast<uint16_t>(code_.size());
    code_.push_back(Instruction::jmp(0));

    // NextParent: advance to next parent
    auto loop_pos = static_cast<uint16_t>(code_.size());
    code_.push_back(Instruction::next_parent(parent_reg, anchor_backtrack));

    // Patch the jump
    code_[jump_to_check_pos].target = static_cast<uint16_t>(code_.size());

    // CheckArity
    code_.push_back(Instruction::check_arity(parent_reg, static_cast<uint8_t>(sym->children.size()), loop_pos));

    // Verify non-shared children match (if any)
    for (std::size_t i = 0; i < sym->children.size(); ++i) {
      if (i == *shared_child_idx) {
        // This is the shared variable - already matched by parent traversal
        // But we should verify the child actually points to the shared e-class
        auto child_reg = alloc_reg();
        code_.push_back(Instruction::load_child(child_reg, parent_reg, static_cast<uint8_t>(i)));
        auto shared_slot = get_slot(shared_var);
        code_.push_back(Instruction::check_slot(shared_slot, child_reg, loop_pos));
        continue;
      }

      auto const &child_node = pattern[sym->children[i]];
      auto child_reg = alloc_reg();
      code_.push_back(Instruction::load_child(child_reg, parent_reg, static_cast<uint8_t>(i)));

      // Match the child
      std::visit(
          [&](auto const &n) {
            using T = std::decay_t<decltype(n)>;
            if constexpr (std::is_same_v<T, Wildcard>) {
              // Wildcard matches anything
            } else if constexpr (std::is_same_v<T, PatternVar>) {
              auto slot = get_slot(n);
              code_.push_back(Instruction::bind_or_check(slot, child_reg, loop_pos));
            } else if constexpr (std::is_same_v<T, SymbolWithChildren<Symbol>>) {
              // TODO: Handle nested symbols in joined pattern
              // For now, just try to match it
            }
          },
          child_node);
    }

    // Bind the root's e-class if it has a binding (e.g., ?id in ?id = Ident(?sym))
    if (auto binding = pattern.binding_for(pattern.root())) {
      auto slot = get_slot(*binding);
      // Get e-class containing this parent e-node
      auto eclass_reg = alloc_reg();
      code_.push_back(Instruction::get_enode_eclass(eclass_reg, parent_reg));
      code_.push_back(Instruction::bind_slot(slot, eclass_reg));
    }

    return loop_pos;
  }

  auto get_symbol_index(Symbol const &sym) -> uint8_t {
    for (std::size_t i = 0; i < symbols_.size(); ++i) {
      if (symbols_[i] == sym) {
        return static_cast<uint8_t>(i);
      }
    }
    symbols_.push_back(sym);
    return static_cast<uint8_t>(symbols_.size() - 1);
  }

  auto alloc_reg() -> uint8_t {
    if (next_reg_ >= kMaxRegisters) {
      register_overflow_ = true;
      return 0;
    }
    return next_reg_++;
  }

  Mode mode_;
  std::vector<Instruction> code_;
  std::vector<Symbol> symbols_;
  uint8_t next_reg_{1};
  bool register_overflow_{false};
  boost::unordered_flat_map<PatternVar, std::size_t> slot_map_;
  boost::unordered_flat_map<PatternVar, uint8_t> var_to_reg_;  // Track which register holds each variable
};

}  // namespace memgraph::planner::core::vm
