// Copyright 2026 Memgraph Ltd.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt; by using this file, you agree to be bound by the terms of the Business Source
// License, and you may not use this file except in compliance with the Business Source License.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

#pragma once

#include <optional>
#include <variant>
#include <vector>

#include <boost/unordered/unordered_flat_map.hpp>
#include <boost/unordered/unordered_flat_set.hpp>

#include "planner/pattern/pattern.hpp"
#include "planner/pattern/vm/executor.hpp"
#include "planner/pattern/vm/instruction.hpp"

namespace memgraph::planner::core::vm {

/// Compiler for single patterns
///
/// Compiles a Pattern<Symbol> into bytecode for VMExecutor.
///
/// Generated bytecode structure for pattern `Sym(child1, child2)`:
/// ```
/// 0:  IterENodes r1, r0, @end     ; iterate e-nodes in input e-class
/// 1:  NextENode r1, @end          ; advance, or jump to end
/// 2:  CheckSymbol r1, sym, @1     ; wrong symbol -> try next e-node
/// 3:  CheckArity r1, 2, @1        ; wrong arity -> try next e-node
/// 4:  [BindSlot if node has binding]
/// 5:  LoadChild r2, r1, 0         ; load child[0]
/// 6:  [emit child1, backtrack to @1]
/// 7:  LoadChild r3, r1, 1         ; load child[1]
/// 8:  [emit child2, backtrack to @1]
/// 9:  Yield                       ; (only at root)
/// 10: Jump @1                     ; try next e-node
/// end:
/// 11: Halt                        ; (only at root)
/// ```
template <typename Symbol>
class PatternCompiler {
 public:
  enum class Mode {
    Verify,  // Always verify child consistency
    Clean,   // Trust parent index, skip verification
  };

  explicit PatternCompiler(Mode mode = Mode::Verify) : mode_(mode) {}

  /// Compile a single pattern into bytecode
  /// Returns std::nullopt if the pattern exceeds the VM's register limit
  auto compile(Pattern<Symbol> const &pattern) -> std::optional<CompiledPattern<Symbol>> {
    code_.clear();
    symbols_.clear();
    seen_vars_.clear();  // Track which variables we've seen
    next_reg_ = 1;       // r0 is reserved for entry candidate
    register_overflow_ = false;

    // Get entry symbol for index lookup
    std::optional<Symbol> entry_symbol;
    auto const &root_node = pattern[pattern.root()];
    if (auto const *sym = std::get_if<SymbolWithChildren<Symbol>>(&root_node)) {
      entry_symbol = sym->sym;
    }

    // Placeholder for halt position (will be patched)
    // For root node, backtrack target is the halt instruction
    auto halt_pos = static_cast<uint16_t>(0xFFFF);  // Placeholder, will patch

    // Emit code starting from root
    emit_pattern_node(pattern, pattern.root(), 0, halt_pos, true);

    // Check for register overflow
    if (register_overflow_) {
      return std::nullopt;
    }

    // Patch all halt placeholders
    auto actual_halt = static_cast<uint16_t>(code_.size());
    for (auto &instr : code_) {
      if (instr.target == 0xFFFF) {
        instr.target = actual_halt;
      }
    }

    // Add halt instruction
    code_.push_back(Instruction::halt());

    return CompiledPattern<Symbol>(std::move(code_), pattern.num_vars(), std::move(symbols_), entry_symbol);
  }

  /// Get the compiled bytecode (for testing)
  [[nodiscard]] auto code() const -> std::vector<Instruction> const & { return code_; }

  /// Get the symbol table (for testing)
  [[nodiscard]] auto symbols() const -> std::vector<Symbol> const & { return symbols_; }

 private:
  /// Emit code for a pattern node
  /// @param pattern The pattern being compiled
  /// @param node_id The current pattern node
  /// @param eclass_reg Register containing the e-class to match against
  /// @param backtrack_target Where to jump on failure (try next e-node or halt)
  /// @param is_root True if this is the root node (emit Yield)
  /// @return The innermost loop position (for continuing iteration after yield)
  auto emit_pattern_node(Pattern<Symbol> const &pattern, PatternNodeId node_id, uint8_t eclass_reg,
                         uint16_t backtrack_target, bool is_root) -> uint16_t {
    auto const &node = pattern[node_id];
    uint16_t innermost_loop = backtrack_target;  // Default: backtrack to parent

    std::visit(
        [&](auto const &n) {
          using T = std::decay_t<decltype(n)>;
          if constexpr (std::is_same_v<T, Wildcard>) {
            // Wildcard matches anything, no code needed
            // But if root, still need to yield
            if (is_root) {
              code_.push_back(Instruction::yield());
            }
            // For wildcards, innermost loop is the backtrack target
          } else if constexpr (std::is_same_v<T, PatternVar>) {
            // Variable: bind if first occurrence, check if subsequent
            auto slot = pattern.var_slot(n);
            emit_var_binding(n, static_cast<uint8_t>(slot), eclass_reg, backtrack_target);
            if (is_root) {
              code_.push_back(Instruction::yield());
            }
            // For variables, innermost loop is the backtrack target
          } else if constexpr (std::is_same_v<T, SymbolWithChildren<Symbol>>) {
            innermost_loop = emit_symbol_node(pattern, node_id, n, eclass_reg, backtrack_target, is_root);
          }
        },
        node);

    return innermost_loop;
  }

  /// Emit code for a symbol node with children
  ///
  /// Generated structure:
  /// ```
  ///   IterENodes r1, r0, @backtrack   ; load first e-node, jump if empty
  ///   Jump @check                     ; skip NextENode on first iteration
  /// loop:
  ///   NextENode r1, @backtrack        ; advance to next, jump if exhausted
  /// check:
  ///   CheckSymbol r1, sym, @loop      ; wrong symbol -> try next
  ///   CheckArity r1, N, @loop         ; wrong arity -> try next
  ///   [BindSlot if node has binding]
  ///   [emit children, backtracking to @loop]
  ///   [Yield if root, then Jump to innermost loop]
  /// ```
  /// @return The loop position of this symbol node (for parent to use as innermost loop)
  auto emit_symbol_node(Pattern<Symbol> const &pattern, PatternNodeId node_id, SymbolWithChildren<Symbol> const &sym,
                        uint8_t eclass_reg, uint16_t backtrack_target, bool is_root) -> uint16_t {
    auto sym_idx = get_symbol_index(sym.sym);
    auto enode_reg = alloc_reg();

    // IterENodes: start iterating e-nodes in the e-class
    // On empty, jump to backtrack target (parent's loop or halt)
    code_.push_back(Instruction::iter_enodes(enode_reg, eclass_reg, backtrack_target));

    // Jump past NextENode on first iteration (IterENodes already loaded first element)
    auto jump_to_check_pos = static_cast<uint16_t>(code_.size());
    code_.push_back(Instruction::jmp(0));  // Placeholder, will patch

    // NextENode: advance to next e-node (loop comes back here)
    auto loop_pos = static_cast<uint16_t>(code_.size());
    code_.push_back(Instruction::next_enode(enode_reg, backtrack_target));

    // Patch the jump to skip to after NextENode
    auto check_pos = static_cast<uint16_t>(code_.size());
    code_[jump_to_check_pos].target = check_pos;

    // CheckSymbol: if symbol doesn't match, try next e-node
    code_.push_back(Instruction::check_symbol(enode_reg, sym_idx, loop_pos));

    // CheckArity: if arity doesn't match, try next e-node
    code_.push_back(Instruction::check_arity(enode_reg, static_cast<uint8_t>(sym.children.size()), loop_pos));

    // Bind this node's e-class if it has a binding
    if (auto binding = pattern.binding_for(node_id)) {
      auto slot = pattern.var_slot(*binding);
      code_.push_back(Instruction::bind_slot(static_cast<uint8_t>(slot), eclass_reg));
    }

    // Process children - they backtrack to THIS node's loop (try next e-node)
    // Track the innermost loop from children
    uint16_t innermost_loop = loop_pos;  // Default to this node's loop
    for (std::size_t i = 0; i < sym.children.size(); ++i) {
      auto child_reg = alloc_reg();
      code_.push_back(Instruction::load_child(child_reg, enode_reg, static_cast<uint8_t>(i)));
      // Children backtrack to loop_pos to try next e-node in THIS e-class
      auto child_innermost = emit_pattern_node(pattern, sym.children[i], child_reg, loop_pos, false);
      // Update innermost loop to the deepest child's loop
      innermost_loop = child_innermost;
    }

    // At this point, we've matched this symbol node and all its children.
    // For root: yield the match, then try more combinations starting from innermost loop
    // For non-root: fall through to parent (which will yield or continue)
    if (is_root) {
      code_.push_back(Instruction::yield());
      // After yielding, continue from the innermost loop to try all combinations
      code_.push_back(Instruction::jmp(innermost_loop));
    }

    // Return this node's loop position so parent knows where to continue
    return loop_pos;
  }

  /// Emit variable binding - uses BindSlot for first occurrence, CheckSlot for subsequent
  ///
  /// This is critical for correctness: after Yield clears the bound flags,
  /// we need CheckSlot (not BindOrCheck) to ensure subsequent occurrences
  /// check against the existing slot value rather than rebinding.
  void emit_var_binding(PatternVar var, uint8_t slot, uint8_t eclass_reg, uint16_t backtrack_target) {
    if (seen_vars_.contains(var)) {
      // Subsequent occurrence: check against existing binding
      code_.push_back(Instruction::check_slot(slot, eclass_reg, backtrack_target));
    } else {
      // First occurrence: bind unconditionally
      seen_vars_.insert(var);
      code_.push_back(Instruction::bind_slot(slot, eclass_reg));
    }
  }

  auto get_symbol_index(Symbol const &sym) -> uint8_t {
    for (std::size_t i = 0; i < symbols_.size(); ++i) {
      if (symbols_[i] == sym) {
        return static_cast<uint8_t>(i);
      }
    }
    symbols_.push_back(sym);
    return static_cast<uint8_t>(symbols_.size() - 1);
  }

  auto alloc_reg() -> uint8_t {
    if (next_reg_ >= kMaxRegisters) {
      register_overflow_ = true;
      return 0;  // Return dummy value, compilation will fail
    }
    return next_reg_++;
  }

  Mode mode_;
  std::vector<Instruction> code_;
  std::vector<Symbol> symbols_;
  boost::unordered_flat_set<PatternVar> seen_vars_;  // Track first vs subsequent occurrences
  uint8_t next_reg_{1};
  bool register_overflow_{false};
};

/// Compiler for multi-pattern rules with parent traversal fusion
///
/// Compiles an anchor pattern with joined patterns that share variables.
/// Uses parent traversal to efficiently find joined pattern matches.
///
/// Example: `Bind(_, ?sym, ?expr)` anchor with `?id = Ident(?sym)` joined
///
/// Generated bytecode structure:
/// ```
/// # ===== Anchor: Bind(_, ?sym, ?expr) =====
/// 0:  IterENodes r1, r0, @halt
/// ... (anchor matching code)
/// N:  BindSlot slot[sym], rX          ; bind shared variable
///
/// # ===== Join: ?id = Ident(?sym) via parent traversal =====
/// N+1: IterParentsSym r_p, rX, Ident, @anchor_loop  ; iterate Ident parents of ?sym
/// N+2: Jump @check
/// N+3: NextParent r_p, @anchor_loop
/// N+4: CheckArity r_p, 1, @N+3
/// N+5: GetENodeEClass r_id, r_p       ; get e-class for ?id
/// N+6: BindSlot slot[id], r_id
///
/// N+7: Yield
/// N+8: Jump @N+3                      ; try more join matches
/// halt:
/// N+9: Halt
/// ```
template <typename Symbol>
class FusedPatternCompiler {
 public:
  enum class Mode {
    Verify,
    Clean,
  };

  explicit FusedPatternCompiler(Mode mode = Mode::Verify) : mode_(mode) {}

  /// Compile multiple patterns into fused bytecode with automatic join order computation.
  ///
  /// Analyzes shared variables between patterns to determine:
  /// - Anchor pattern (highest connectivity in variable-sharing graph)
  /// - Join order (greedy by shared variables with already-matched patterns)
  /// - Shared variables for each join step
  ///
  /// @param patterns All patterns to compile (order doesn't matter, optimal order computed internally)
  /// @return Compiled bytecode or nullopt if patterns exceed register limit
  auto compile(std::span<Pattern<Symbol> const> patterns) -> std::optional<CompiledPattern<Symbol>> {
    if (patterns.empty()) {
      return std::nullopt;
    }

    // Compute join order - works for single pattern too (trivial case)
    auto join_order = compute_join_order(patterns);

    // Extract anchor and joined patterns based on computed order
    auto const &anchor = patterns[join_order.anchor_idx];
    std::vector<Pattern<Symbol>> joined;
    joined.reserve(join_order.join_indices.size());
    for (auto idx : join_order.join_indices) {
      joined.push_back(patterns[idx]);
    }

    return compile_internal(anchor, joined, join_order.all_shared_vars);
  }

  /// Compile anchor with joined patterns (explicit join order - for backward compatibility)
  ///
  /// @param anchor The anchor pattern to match first
  /// @param joined Patterns to join via shared variables (using parent traversal)
  /// @param shared_vars Variables that appear in both anchor and at least one joined pattern
  /// @return Compiled bytecode or nullopt if patterns exceed register limit
  auto compile(Pattern<Symbol> const &anchor, std::vector<Pattern<Symbol>> const &joined,
               std::vector<PatternVar> const &shared_vars) -> std::optional<CompiledPattern<Symbol>> {
    return compile_internal(anchor, joined, shared_vars);
  }

  /// Get the slot map from the last successful compilation.
  /// Maps each PatternVar to its slot index in the compiled pattern.
  /// Only valid after a successful compile() call.
  [[nodiscard]] auto slot_map() const -> boost::unordered_flat_map<PatternVar, std::size_t> const & {
    return slot_map_;
  }

 private:
  /// Internal join order representation
  struct JoinOrder {
    std::size_t anchor_idx{0};
    std::vector<std::size_t> join_indices;
    std::vector<PatternVar> all_shared_vars;
  };

  /// Compute optimal join order from patterns by analyzing shared variables.
  /// Uses greedy algorithm: start with highest-degree pattern, then pick patterns
  /// sharing most variables with already-selected patterns.
  static auto compute_join_order(std::span<Pattern<Symbol> const> patterns) -> JoinOrder {
    auto const n = patterns.size();
    JoinOrder order;

    // Collect variables per pattern
    std::vector<boost::unordered_flat_set<PatternVar>> pattern_vars(n);
    for (std::size_t i = 0; i < n; ++i) {
      for (auto const &[var, _] : patterns[i].var_slots()) {
        pattern_vars[i].insert(var);
      }
    }

    // Compute pairwise shared variable counts
    std::vector<std::vector<std::size_t>> shared_counts(n, std::vector<std::size_t>(n, 0));
    for (std::size_t i = 0; i < n; ++i) {
      for (std::size_t j = i + 1; j < n; ++j) {
        std::size_t count = 0;
        for (auto const &var : pattern_vars[i]) {
          if (pattern_vars[j].contains(var)) ++count;
        }
        shared_counts[i][j] = shared_counts[j][i] = count;
      }
    }

    // Compute degree for each pattern (total shared variable connections)
    std::vector<std::size_t> degree(n, 0);
    for (std::size_t i = 0; i < n; ++i) {
      for (std::size_t j = 0; j < n; ++j) {
        degree[i] += shared_counts[i][j];
      }
    }

    // Track which patterns are remaining and which vars we've seen
    boost::unordered_flat_set<std::size_t> remaining;
    for (std::size_t i = 0; i < n; ++i) remaining.insert(i);
    boost::unordered_flat_set<PatternVar> seen_vars;

    // Start with highest-degree pattern as anchor
    std::size_t best_idx = 0;
    std::size_t best_degree = degree[0];
    for (std::size_t i = 1; i < n; ++i) {
      if (degree[i] > best_degree) {
        best_degree = degree[i];
        best_idx = i;
      }
    }
    order.anchor_idx = best_idx;
    remaining.erase(best_idx);
    for (auto const &var : pattern_vars[best_idx]) {
      seen_vars.insert(var);
    }

    // Greedily add remaining patterns by most shared vars with seen set
    while (!remaining.empty()) {
      std::size_t best = *remaining.begin();
      std::size_t best_shared = 0;

      for (auto idx : remaining) {
        std::size_t shared = 0;
        for (auto const &var : pattern_vars[idx]) {
          if (seen_vars.contains(var)) ++shared;
        }
        if (shared > best_shared) {
          best_shared = shared;
          best = idx;
        }
      }

      order.join_indices.push_back(best);
      remaining.erase(best);

      // Collect shared vars and add new vars to seen
      for (auto const &var : pattern_vars[best]) {
        if (seen_vars.contains(var)) {
          // Check if already in all_shared_vars
          bool found = false;
          for (auto const &sv : order.all_shared_vars) {
            if (sv == var) {
              found = true;
              break;
            }
          }
          if (!found) {
            order.all_shared_vars.push_back(var);
          }
        }
        seen_vars.insert(var);
      }
    }

    return order;
  }

  /// Internal compilation with explicit anchor/joined/shared_vars
  auto compile_internal(Pattern<Symbol> const &anchor, std::vector<Pattern<Symbol>> const &joined,
                        std::vector<PatternVar> const &shared_vars) -> std::optional<CompiledPattern<Symbol>> {
    code_.clear();
    symbols_.clear();
    seen_vars_.clear();  // Track which variables we've seen
    var_to_reg_.clear();
    next_reg_ = 1;  // r0 is reserved for entry candidate
    register_overflow_ = false;
    slot_map_.clear();

    // Build unified slot map: anchor vars first, then unique joined vars
    build_slot_map(anchor, joined);

    // Get entry symbol for index lookup
    std::optional<Symbol> entry_symbol;
    auto const &root_node = anchor[anchor.root()];
    if (auto const *sym = std::get_if<SymbolWithChildren<Symbol>>(&root_node)) {
      entry_symbol = sym->sym;
    }

    // Placeholder for halt position
    auto halt_pos = static_cast<uint16_t>(0xFFFF);

    // Emit anchor pattern (returns innermost loop position)
    // Don't emit yield - we'll do that after all joins
    auto anchor_innermost = emit_anchor_pattern(anchor, 0, halt_pos);

    if (register_overflow_) {
      return std::nullopt;
    }

    // Track innermost loop across all joins for the final yield
    uint16_t innermost_loop = anchor_innermost;

    // Emit joined patterns using parent traversal
    for (auto const &join_pattern : joined) {
      auto join_innermost = emit_joined_pattern(join_pattern, shared_vars, anchor, innermost_loop);
      if (register_overflow_) {
        return std::nullopt;
      }
      innermost_loop = join_innermost;
    }

    // Now emit Yield and jump back to innermost loop
    code_.push_back(Instruction::yield());
    code_.push_back(Instruction::jmp(innermost_loop));

    // Patch all halt placeholders
    auto actual_halt = static_cast<uint16_t>(code_.size());
    for (auto &instr : code_) {
      if (instr.target == 0xFFFF) {
        instr.target = actual_halt;
      }
    }

    // Add halt instruction
    code_.push_back(Instruction::halt());

    return CompiledPattern<Symbol>(std::move(code_), slot_map_.size(), std::move(symbols_), entry_symbol);
  }

  /// Build unified slot map for all patterns
  void build_slot_map(Pattern<Symbol> const &anchor, std::vector<Pattern<Symbol>> const &joined) {
    // Add anchor variables first
    for (auto const &[var, _slot] : anchor.var_slots()) {
      if (slot_map_.find(var) == slot_map_.end()) {
        slot_map_[var] = slot_map_.size();
      }
    }

    // Add unique joined pattern variables
    for (auto const &pattern : joined) {
      for (auto const &[var, _slot] : pattern.var_slots()) {
        if (slot_map_.find(var) == slot_map_.end()) {
          slot_map_[var] = slot_map_.size();
        }
      }
    }
  }

  /// Get global slot for a variable
  auto get_slot(PatternVar var) const -> uint8_t {
    auto it = slot_map_.find(var);
    if (it != slot_map_.end()) {
      return static_cast<uint8_t>(it->second);
    }
    return 0;  // Should not happen if slot map is built correctly
  }

  /// Emit anchor pattern code (without yield)
  auto emit_anchor_pattern(Pattern<Symbol> const &pattern, uint8_t eclass_reg, uint16_t backtrack_target) -> uint16_t {
    auto const &node = pattern[pattern.root()];
    uint16_t innermost_loop = backtrack_target;

    std::visit(
        [&](auto const &n) {
          using T = std::decay_t<decltype(n)>;
          if constexpr (std::is_same_v<T, Wildcard>) {
            // Wildcard matches anything, no code needed
          } else if constexpr (std::is_same_v<T, PatternVar>) {
            // Variable: bind if first, check if subsequent
            auto slot = get_slot(n);
            emit_var_binding(n, slot, eclass_reg, backtrack_target);
          } else if constexpr (std::is_same_v<T, SymbolWithChildren<Symbol>>) {
            innermost_loop = emit_anchor_symbol_node(pattern, pattern.root(), n, eclass_reg, backtrack_target);
          }
        },
        node);

    return innermost_loop;
  }

  /// Emit anchor symbol node (without yield at end)
  auto emit_anchor_symbol_node(Pattern<Symbol> const &pattern, PatternNodeId node_id,
                               SymbolWithChildren<Symbol> const &sym, uint8_t eclass_reg, uint16_t backtrack_target)
      -> uint16_t {
    auto sym_idx = get_symbol_index(sym.sym);
    auto enode_reg = alloc_reg();

    // IterENodes: start iterating e-nodes in the e-class
    code_.push_back(Instruction::iter_enodes(enode_reg, eclass_reg, backtrack_target));

    // Jump past NextENode on first iteration
    auto jump_to_check_pos = static_cast<uint16_t>(code_.size());
    code_.push_back(Instruction::jmp(0));

    // NextENode: advance to next e-node (loop comes back here)
    auto loop_pos = static_cast<uint16_t>(code_.size());
    code_.push_back(Instruction::next_enode(enode_reg, backtrack_target));

    // Patch the jump
    code_[jump_to_check_pos].target = static_cast<uint16_t>(code_.size());

    // CheckSymbol and CheckArity
    code_.push_back(Instruction::check_symbol(enode_reg, sym_idx, loop_pos));
    code_.push_back(Instruction::check_arity(enode_reg, static_cast<uint8_t>(sym.children.size()), loop_pos));

    // Bind this node's e-class if it has a binding
    if (auto binding = pattern.binding_for(node_id)) {
      auto slot = get_slot(*binding);
      code_.push_back(Instruction::bind_slot(slot, eclass_reg));
    }

    // Process children
    uint16_t innermost_loop = loop_pos;
    for (std::size_t i = 0; i < sym.children.size(); ++i) {
      auto child_reg = alloc_reg();
      code_.push_back(Instruction::load_child(child_reg, enode_reg, static_cast<uint8_t>(i)));
      auto child_innermost = emit_anchor_child(pattern, sym.children[i], child_reg, loop_pos);
      innermost_loop = child_innermost;
    }

    return innermost_loop;
  }

  /// Emit anchor child node
  auto emit_anchor_child(Pattern<Symbol> const &pattern, PatternNodeId node_id, uint8_t eclass_reg,
                         uint16_t backtrack_target) -> uint16_t {
    auto const &node = pattern[node_id];
    uint16_t innermost_loop = backtrack_target;

    std::visit(
        [&](auto const &n) {
          using T = std::decay_t<decltype(n)>;
          if constexpr (std::is_same_v<T, Wildcard>) {
            // Wildcard matches anything
          } else if constexpr (std::is_same_v<T, PatternVar>) {
            auto slot = get_slot(n);
            emit_var_binding(n, slot, eclass_reg, backtrack_target);
            // Track this register for parent traversal from this variable
            var_to_reg_[n] = eclass_reg;
          } else if constexpr (std::is_same_v<T, SymbolWithChildren<Symbol>>) {
            innermost_loop = emit_anchor_symbol_node(pattern, node_id, n, eclass_reg, backtrack_target);
          }
        },
        node);

    return innermost_loop;
  }

  /// Emit joined pattern - handles three cases:
  /// 1. Variable-only root: iterate all e-classes (Cartesian product)
  /// 2. Symbol root with shared variable: use parent traversal (efficient join)
  /// 3. Symbol root without shared variable: iterate all e-classes (Cartesian product)
  auto emit_joined_pattern(Pattern<Symbol> const &pattern, std::vector<PatternVar> const &shared_vars,
                           Pattern<Symbol> const &anchor, uint16_t anchor_backtrack) -> uint16_t {
    auto const &root_node = pattern[pattern.root()];

    // Check if root is a symbol node
    auto const *sym = std::get_if<SymbolWithChildren<Symbol>>(&root_node);

    if (!sym) {
      // Case 1: Variable-only or wildcard root - iterate all e-classes
      return emit_joined_variable_pattern(pattern, anchor_backtrack);
    }

    // Find shared variable as direct child for parent traversal
    std::optional<std::size_t> shared_child_idx;
    PatternVar shared_var{};

    for (std::size_t i = 0; i < sym->children.size(); ++i) {
      auto const &child_node = pattern[sym->children[i]];
      if (auto const *var = std::get_if<PatternVar>(&child_node)) {
        for (auto const &sv : shared_vars) {
          if (*var == sv) {
            shared_child_idx = i;
            shared_var = sv;
            break;
          }
        }
        if (shared_child_idx) break;
      }
    }

    // Check if we have a shared variable we can use for parent traversal
    if (shared_child_idx) {
      auto shared_var_it = var_to_reg_.find(shared_var);
      if (shared_var_it != var_to_reg_.end()) {
        // Case 2: Shared variable found - use efficient parent traversal
        return emit_joined_pattern_with_parent_traversal(
            pattern, *sym, shared_var, *shared_child_idx, shared_var_it->second, anchor_backtrack);
      }
    }

    // Case 3: No usable shared variable - use Cartesian product
    return emit_joined_cartesian_pattern(pattern, *sym, anchor_backtrack);
  }

  /// Emit code for variable-only joined pattern (Cartesian product)
  auto emit_joined_variable_pattern(Pattern<Symbol> const &pattern, uint16_t anchor_backtrack) -> uint16_t {
    auto const &root_node = pattern[pattern.root()];

    // Allocate register for e-class iteration
    auto eclass_reg = alloc_reg();

    // IterAllEClasses: iterate all e-classes
    code_.push_back(Instruction::iter_all_eclasses(eclass_reg, anchor_backtrack));

    auto jump_to_check_pos = static_cast<uint16_t>(code_.size());
    code_.push_back(Instruction::jmp(0));

    auto loop_pos = static_cast<uint16_t>(code_.size());
    code_.push_back(Instruction::next_eclass(eclass_reg, anchor_backtrack));

    code_[jump_to_check_pos].target = static_cast<uint16_t>(code_.size());

    // Handle root node binding
    std::visit(
        [&](auto const &n) {
          using T = std::decay_t<decltype(n)>;
          if constexpr (std::is_same_v<T, Wildcard>) {
            // Wildcard matches anything, no binding
          } else if constexpr (std::is_same_v<T, PatternVar>) {
            auto slot = get_slot(n);
            emit_var_binding(n, slot, eclass_reg, loop_pos);
            var_to_reg_[n] = eclass_reg;
          }
        },
        root_node);

    // Handle root binding if present
    if (auto binding = pattern.binding_for(pattern.root())) {
      auto slot = get_slot(*binding);
      emit_var_binding(*binding, slot, eclass_reg, loop_pos);
    }

    return loop_pos;
  }

  /// Emit code for Cartesian product join with symbol pattern
  auto emit_joined_cartesian_pattern(Pattern<Symbol> const &pattern, SymbolWithChildren<Symbol> const &sym,
                                     uint16_t anchor_backtrack) -> uint16_t {
    // Allocate registers
    auto eclass_reg = alloc_reg();
    auto enode_reg = alloc_reg();

    // Outer loop: iterate all e-classes
    code_.push_back(Instruction::iter_all_eclasses(eclass_reg, anchor_backtrack));

    auto jump_to_eclass_check = static_cast<uint16_t>(code_.size());
    code_.push_back(Instruction::jmp(0));

    auto eclass_loop_pos = static_cast<uint16_t>(code_.size());
    code_.push_back(Instruction::next_eclass(eclass_reg, anchor_backtrack));

    code_[jump_to_eclass_check].target = static_cast<uint16_t>(code_.size());

    // Inner loop: iterate e-nodes in each e-class
    code_.push_back(Instruction::iter_enodes(enode_reg, eclass_reg, eclass_loop_pos));

    auto jump_to_enode_check = static_cast<uint16_t>(code_.size());
    code_.push_back(Instruction::jmp(0));

    auto enode_loop_pos = static_cast<uint16_t>(code_.size());
    code_.push_back(Instruction::next_enode(enode_reg, eclass_loop_pos));

    code_[jump_to_enode_check].target = static_cast<uint16_t>(code_.size());

    // Check symbol matches
    auto sym_idx = get_symbol_index(sym.sym);
    code_.push_back(Instruction::check_symbol(enode_reg, sym_idx, enode_loop_pos));

    // Check arity
    code_.push_back(Instruction::check_arity(enode_reg, static_cast<uint8_t>(sym.children.size()), enode_loop_pos));

    // Process children recursively
    uint16_t innermost = enode_loop_pos;
    for (std::size_t i = 0; i < sym.children.size(); ++i) {
      auto child_reg = alloc_reg();
      code_.push_back(Instruction::load_child(child_reg, enode_reg, static_cast<uint8_t>(i)));
      innermost = emit_joined_child(pattern, sym.children[i], child_reg, innermost);
    }

    // Bind root e-class if needed
    if (auto binding = pattern.binding_for(pattern.root())) {
      auto slot = get_slot(*binding);
      code_.push_back(Instruction::bind_slot(slot, eclass_reg));
    }

    return innermost;
  }

  /// Emit code for joined pattern using parent traversal (efficient join)
  auto emit_joined_pattern_with_parent_traversal(Pattern<Symbol> const &pattern, SymbolWithChildren<Symbol> const &sym,
                                                 PatternVar shared_var, std::size_t shared_child_idx,
                                                 uint8_t shared_eclass_reg, uint16_t anchor_backtrack) -> uint16_t {
    auto parent_sym_idx = get_symbol_index(sym.sym);
    auto parent_reg = alloc_reg();

    // IterParentsSym: iterate parents with this symbol
    code_.push_back(Instruction::iter_parents_sym(parent_reg, shared_eclass_reg, parent_sym_idx, anchor_backtrack));

    auto jump_to_check_pos = static_cast<uint16_t>(code_.size());
    code_.push_back(Instruction::jmp(0));

    auto loop_pos = static_cast<uint16_t>(code_.size());
    code_.push_back(Instruction::next_parent(parent_reg, anchor_backtrack));

    code_[jump_to_check_pos].target = static_cast<uint16_t>(code_.size());

    // CheckArity
    code_.push_back(Instruction::check_arity(parent_reg, static_cast<uint8_t>(sym.children.size()), loop_pos));

    // Process children recursively
    uint16_t innermost = loop_pos;
    for (std::size_t i = 0; i < sym.children.size(); ++i) {
      auto child_reg = alloc_reg();
      code_.push_back(Instruction::load_child(child_reg, parent_reg, static_cast<uint8_t>(i)));

      if (i == shared_child_idx) {
        // Verify the child points to the shared e-class
        auto shared_slot = get_slot(shared_var);
        code_.push_back(Instruction::check_slot(shared_slot, child_reg, innermost));
        continue;
      }

      innermost = emit_joined_child(pattern, sym.children[i], child_reg, innermost);
    }

    // Bind the root's e-class if it has a binding
    if (auto binding = pattern.binding_for(pattern.root())) {
      auto slot = get_slot(*binding);
      auto eclass_reg = alloc_reg();
      code_.push_back(Instruction::get_enode_eclass(eclass_reg, parent_reg));
      code_.push_back(Instruction::bind_slot(slot, eclass_reg));
    }

    return innermost;
  }

  /// Emit code for a child node in a joined pattern (recursive for nested symbols)
  auto emit_joined_child(Pattern<Symbol> const &pattern, PatternNodeId node_id, uint8_t eclass_reg,
                         uint16_t backtrack_target) -> uint16_t {
    auto const &node = pattern[node_id];
    uint16_t innermost = backtrack_target;

    std::visit(
        [&](auto const &n) {
          using T = std::decay_t<decltype(n)>;
          if constexpr (std::is_same_v<T, Wildcard>) {
            // Wildcard matches anything, no code needed
          } else if constexpr (std::is_same_v<T, PatternVar>) {
            auto slot = get_slot(n);
            emit_var_binding(n, slot, eclass_reg, backtrack_target);
            var_to_reg_[n] = eclass_reg;
          } else if constexpr (std::is_same_v<T, SymbolWithChildren<Symbol>>) {
            // Nested symbol node - emit iteration and recursive processing
            auto sym_idx = get_symbol_index(n.sym);
            auto enode_reg = alloc_reg();

            // IterENodes: iterate e-nodes in the child e-class
            code_.push_back(Instruction::iter_enodes(enode_reg, eclass_reg, backtrack_target));

            auto jump_to_check_pos = static_cast<uint16_t>(code_.size());
            code_.push_back(Instruction::jmp(0));

            auto loop_pos = static_cast<uint16_t>(code_.size());
            code_.push_back(Instruction::next_enode(enode_reg, backtrack_target));

            code_[jump_to_check_pos].target = static_cast<uint16_t>(code_.size());

            // Check symbol and arity
            code_.push_back(Instruction::check_symbol(enode_reg, sym_idx, loop_pos));
            code_.push_back(Instruction::check_arity(enode_reg, static_cast<uint8_t>(n.children.size()), loop_pos));

            // Bind this node's e-class if it has a binding
            if (auto binding = pattern.binding_for(node_id)) {
              auto slot = get_slot(*binding);
              code_.push_back(Instruction::bind_slot(slot, eclass_reg));
            }

            // Process children recursively
            innermost = loop_pos;
            for (std::size_t i = 0; i < n.children.size(); ++i) {
              auto child_reg = alloc_reg();
              code_.push_back(Instruction::load_child(child_reg, enode_reg, static_cast<uint8_t>(i)));
              innermost = emit_joined_child(pattern, n.children[i], child_reg, innermost);
            }
          }
        },
        node);

    return innermost;
  }

  /// Emit variable binding - uses BindSlot for first occurrence, CheckSlot for subsequent
  void emit_var_binding(PatternVar var, uint8_t slot, uint8_t eclass_reg, uint16_t backtrack_target) {
    if (seen_vars_.contains(var)) {
      // Subsequent occurrence: check against existing binding
      code_.push_back(Instruction::check_slot(slot, eclass_reg, backtrack_target));
    } else {
      // First occurrence: bind unconditionally
      seen_vars_.insert(var);
      code_.push_back(Instruction::bind_slot(slot, eclass_reg));
    }
  }

  auto get_symbol_index(Symbol const &sym) -> uint8_t {
    for (std::size_t i = 0; i < symbols_.size(); ++i) {
      if (symbols_[i] == sym) {
        return static_cast<uint8_t>(i);
      }
    }
    symbols_.push_back(sym);
    return static_cast<uint8_t>(symbols_.size() - 1);
  }

  auto alloc_reg() -> uint8_t {
    if (next_reg_ >= kMaxRegisters) {
      register_overflow_ = true;
      return 0;
    }
    return next_reg_++;
  }

  Mode mode_;
  std::vector<Instruction> code_;
  std::vector<Symbol> symbols_;
  boost::unordered_flat_set<PatternVar> seen_vars_;  // Track first vs subsequent occurrences
  uint8_t next_reg_{1};
  bool register_overflow_{false};
  boost::unordered_flat_map<PatternVar, std::size_t> slot_map_;
  boost::unordered_flat_map<PatternVar, uint8_t> var_to_reg_;  // Track which register holds each variable
};

/// Bottom-up pattern compiler
///
/// Compiles patterns to traverse FROM leaf variables UP to root via parent traversal.
/// This is O(n) where n = number of e-classes (candidates for leaf variable),
/// vs top-down which is O(k) where k = candidates with root symbol.
///
/// Bottom-up is better when:
/// - Pattern has a variable at leaf position
/// - Few e-classes match the leaf vs many match the root
///
/// Generated bytecode structure for `Neg(Neg(?x))`:
/// ```
/// // r0 = candidate e-class (potential ?x binding)
/// 0:  BindSlot slot[?x], r0              // Bind ?x
/// 1:  IterParentsSym r1, r0, Neg, @halt  // Find Neg parents -> inner Neg e-nodes
/// 2:  Jump @4
/// 3:  NextParent r1, @halt
/// 4:  LoadChild r2, r1, 0                // Verify child[0] == ?x
/// 5:  CheckSlot r2, slot[?x], @3
/// 6:  GetENodeEClass r3, r1              // r3 = e-class of inner Neg
/// 7:  BindSlot slot[inner], r3           // Store for next level's verification
/// 8:  IterParentsSym r4, r3, Neg, @3     // Find Neg parents -> outer Neg e-nodes
/// 9:  Jump @11
/// 10: NextParent r4, @3
/// 11: LoadChild r5, r4, 0                // Verify child[0] == inner Neg e-class
/// 12: CheckSlot r5, slot[inner], @10
/// 13: GetENodeEClass r6, r4              // r6 = e-class of outer Neg (root)
/// 14: BindSlot slot[root], r6            // Bind root if needed
/// 15: Yield
/// 16: Jump @10                           // Continue from innermost loop
/// 17: Halt
/// ```
template <typename Symbol>
class BottomUpPatternCompiler {
 public:
  explicit BottomUpPatternCompiler() = default;

  /// Compile a pattern for bottom-up matching
  /// Returns std::nullopt if pattern is not suitable for bottom-up or exceeds limits
  auto compile(Pattern<Symbol> const &pattern) -> std::optional<CompiledPattern<Symbol>> {
    code_.clear();
    symbols_.clear();
    next_reg_ = 1;  // r0 is reserved for entry candidate (leaf e-class)
    // Internal slots for verification start after pattern's variable slots
    next_internal_slot_ = pattern.num_vars();
    register_overflow_ = false;

    // Find the leaf variable - must have exactly one for simple bottom-up
    auto leaf_var = find_leaf_variable(pattern, pattern.root());
    if (!leaf_var) {
      return std::nullopt;  // Pattern not suitable for bottom-up
    }

    // Build path from leaf to root
    auto path = build_leaf_to_root_path(pattern, pattern.root(), *leaf_var);
    if (path.empty()) {
      return std::nullopt;
    }

    // Bind the leaf variable to r0 (the candidate e-class)
    // Use the pattern's actual slot assignment
    auto leaf_slot = static_cast<uint8_t>(pattern.var_slot(*leaf_var));
    code_.push_back(Instruction::bind_slot(leaf_slot, 0));

    // Placeholder for halt
    auto halt_pos = static_cast<uint16_t>(0xFFFF);

    // Generate code traversing up from leaf to root
    uint8_t current_eclass_reg = 0;  // Start with leaf's e-class in r0
    uint16_t innermost_loop = halt_pos;
    uint8_t prev_slot = leaf_slot;  // Slot holding the e-class we came from

    for (std::size_t i = 0; i < path.size(); ++i) {
      auto const &step = path[i];
      bool is_root = (i == path.size() - 1);

      auto loop_pos = emit_parent_traversal_step(pattern, step, current_eclass_reg, prev_slot, innermost_loop, is_root);

      // Update for next iteration
      innermost_loop = loop_pos;
      current_eclass_reg = step.result_eclass_reg;
      prev_slot = step.result_slot;
    }

    if (register_overflow_) {
      return std::nullopt;
    }

    // Yield and continue from innermost loop
    code_.push_back(Instruction::yield());
    code_.push_back(Instruction::jmp(innermost_loop));

    // Patch halt placeholders
    auto actual_halt = static_cast<uint16_t>(code_.size());
    for (auto &instr : code_) {
      if (instr.target == 0xFFFF) {
        instr.target = actual_halt;
      }
    }
    code_.push_back(Instruction::halt());

    // No entry symbol for bottom-up - we iterate all e-classes
    // Use next_internal_slot_ as total slots (includes pattern vars + internal verification slots)
    return CompiledPattern<Symbol>(std::move(code_), next_internal_slot_, std::move(symbols_), std::nullopt);
  }

 private:
  /// Step in the leaf-to-root path
  struct PathStep {
    Symbol parent_symbol;               // Symbol of the parent node
    uint8_t child_position;             // Which child position we came from
    uint8_t arity;                      // Arity of the parent node
    PatternNodeId node_id;              // Pattern node ID
    std::optional<PatternVar> binding;  // Variable binding if any
    uint8_t result_eclass_reg;          // Register that will hold parent's e-class
    uint8_t result_slot;                // Slot that will hold parent's e-class
  };

  /// Find a leaf variable in the pattern (DFS to find first variable at a leaf)
  auto find_leaf_variable(Pattern<Symbol> const &pattern, PatternNodeId node_id) -> std::optional<PatternVar> {
    auto const &node = pattern[node_id];

    return std::visit(
        [&](auto const &n) -> std::optional<PatternVar> {
          using T = std::decay_t<decltype(n)>;
          if constexpr (std::is_same_v<T, PatternVar>) {
            return n;
          } else if constexpr (std::is_same_v<T, SymbolWithChildren<Symbol>>) {
            // Recurse into children to find a leaf variable
            for (auto const &child_id : n.children) {
              if (auto var = find_leaf_variable(pattern, child_id)) {
                return var;
              }
            }
          }
          return std::nullopt;
        },
        node);
  }

  /// Build path from leaf variable to root, recording parent symbols and child positions
  auto build_leaf_to_root_path(Pattern<Symbol> const &pattern, PatternNodeId root_id, PatternVar leaf_var)
      -> std::vector<PathStep> {
    std::vector<PathStep> path;

    // Helper to find path recursively
    std::function<bool(PatternNodeId, std::vector<PathStep> &)> find_path =
        [&](PatternNodeId node_id, std::vector<PathStep> &current_path) -> bool {
      auto const &node = pattern[node_id];

      return std::visit(
          [&](auto const &n) -> bool {
            using T = std::decay_t<decltype(n)>;
            if constexpr (std::is_same_v<T, PatternVar>) {
              return n == leaf_var;  // Found the leaf variable
            } else if constexpr (std::is_same_v<T, SymbolWithChildren<Symbol>>) {
              // Try each child
              for (std::size_t i = 0; i < n.children.size(); ++i) {
                if (find_path(n.children[i], current_path)) {
                  // Child contains the leaf - add this node to path
                  PathStep step;
                  step.parent_symbol = n.sym;
                  step.child_position = static_cast<uint8_t>(i);
                  step.arity = static_cast<uint8_t>(n.children.size());
                  step.node_id = node_id;
                  step.binding = pattern.binding_for(node_id);
                  step.result_eclass_reg = alloc_reg();
                  step.result_slot = alloc_slot_anonymous();
                  current_path.push_back(step);
                  return true;
                }
              }
            }
            return false;
          },
          node);
    };

    find_path(root_id, path);
    return path;
  }

  /// Emit code for one level of parent traversal
  auto emit_parent_traversal_step(Pattern<Symbol> const &pattern, PathStep const &step, uint8_t child_eclass_reg,
                                  uint8_t child_slot, uint16_t backtrack_target, bool is_root) -> uint16_t {
    auto sym_idx = get_symbol_index(step.parent_symbol);
    auto parent_enode_reg = alloc_reg();

    // IterParentsSym: find parents with this symbol
    code_.push_back(Instruction::iter_parents_sym(parent_enode_reg, child_eclass_reg, sym_idx, backtrack_target));

    // Jump past NextParent on first iteration
    auto jump_pos = static_cast<uint16_t>(code_.size());
    code_.push_back(Instruction::jmp(0));

    // NextParent: advance to next parent
    auto loop_pos = static_cast<uint16_t>(code_.size());
    code_.push_back(Instruction::next_parent(parent_enode_reg, backtrack_target));

    // Patch jump
    code_[jump_pos].target = static_cast<uint16_t>(code_.size());

    // CheckArity
    code_.push_back(Instruction::check_arity(parent_enode_reg, step.arity, loop_pos));

    // Verify child at expected position matches where we came from
    auto verify_reg = alloc_reg();
    code_.push_back(Instruction::load_child(verify_reg, parent_enode_reg, step.child_position));
    code_.push_back(Instruction::check_slot(child_slot, verify_reg, loop_pos));

    // Get the parent's e-class
    code_.push_back(Instruction::get_enode_eclass(step.result_eclass_reg, parent_enode_reg));

    // Store in slot for next level's verification
    code_.push_back(Instruction::bind_slot(step.result_slot, step.result_eclass_reg));

    // Bind variable if this node has one (use pattern's original slot assignment)
    if (step.binding) {
      auto var_slot = static_cast<uint8_t>(pattern.var_slot(*step.binding));
      code_.push_back(Instruction::bind_slot(var_slot, step.result_eclass_reg));
    }

    return loop_pos;
  }

  auto get_symbol_index(Symbol const &sym) -> uint8_t {
    for (std::size_t i = 0; i < symbols_.size(); ++i) {
      if (symbols_[i] == sym) {
        return static_cast<uint8_t>(i);
      }
    }
    symbols_.push_back(sym);
    return static_cast<uint8_t>(symbols_.size() - 1);
  }

  auto alloc_reg() -> uint8_t {
    if (next_reg_ >= kMaxRegisters) {
      register_overflow_ = true;
      return 0;
    }
    return next_reg_++;
  }

  /// Allocate an anonymous slot for internal verification (not a pattern variable)
  auto alloc_slot_anonymous() -> uint8_t { return static_cast<uint8_t>(next_internal_slot_++); }

  std::vector<Instruction> code_;
  std::vector<Symbol> symbols_;
  uint8_t next_reg_{1};
  std::size_t next_internal_slot_{0};  // Slots for internal verification, starts after pattern vars
  bool register_overflow_{false};
};

}  // namespace memgraph::planner::core::vm
