
// Generated from /home/kostas/Desktop/memgraph/src/parser/opencypher/grammar/MemgraphCypher.g4 by ANTLR 4.10.1


#include "MemgraphCypherListener.h"
#include "MemgraphCypherVisitor.h"

#include "MemgraphCypher.h"


using namespace antlrcpp;
using namespace antlropencypher;

using namespace antlr4;

namespace {

struct MemgraphCypherStaticData final {
  MemgraphCypherStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  MemgraphCypherStaticData(const MemgraphCypherStaticData&) = delete;
  MemgraphCypherStaticData(MemgraphCypherStaticData&&) = delete;
  MemgraphCypherStaticData& operator=(const MemgraphCypherStaticData&) = delete;
  MemgraphCypherStaticData& operator=(MemgraphCypherStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

std::once_flag memgraphcypherParserOnceFlag;
MemgraphCypherStaticData *memgraphcypherParserStaticData = nullptr;

void memgraphcypherParserInitialize() {
  assert(memgraphcypherParserStaticData == nullptr);
  auto staticData = std::make_unique<MemgraphCypherStaticData>(
    std::vector<std::string>{
      "memgraphCypherKeyword", "symbolicName", "query", "authQuery", "replicationQuery", 
      "triggerQuery", "clause", "updateClause", "foreach", "streamQuery", 
      "settingQuery", "loadCsv", "csvFile", "delimiter", "quote", "rowVar", 
      "userOrRoleName", "createRole", "dropRole", "showRoles", "createUser", 
      "setPassword", "dropUser", "showUsers", "setRole", "clearRole", "grantPrivilege", 
      "denyPrivilege", "revokePrivilege", "privilege", "privilegeList", 
      "showPrivileges", "showRoleForUser", "showUsersForRole", "dumpQuery", 
      "setReplicationRole", "showReplicationRole", "replicaName", "socketAddress", 
      "registerReplica", "dropReplica", "showReplicas", "lockPathQuery", 
      "freeMemoryQuery", "triggerName", "triggerStatement", "emptyVertex", 
      "emptyEdge", "createTrigger", "dropTrigger", "showTriggers", "isolationLevel", 
      "isolationLevelScope", "isolationLevelQuery", "createSnapshotQuery", 
      "streamName", "symbolicNameWithMinus", "symbolicNameWithDotsAndMinus", 
      "symbolicTopicNames", "topicNames", "commonCreateStreamConfig", "createStream", 
      "configKeyValuePair", "configMap", "kafkaCreateStreamConfig", "kafkaCreateStream", 
      "pulsarCreateStreamConfig", "pulsarCreateStream", "dropStream", "startStream", 
      "startAllStreams", "stopStream", "stopAllStreams", "showStreams", 
      "checkStream", "settingName", "settingValue", "setSetting", "showSetting", 
      "showSettings", "versionQuery", "cypher", "statement", "constraintQuery", 
      "constraint", "constraintPropertyList", "storageInfo", "indexInfo", 
      "constraintInfo", "infoQuery", "explainQuery", "profileQuery", "cypherQuery", 
      "indexQuery", "singleQuery", "cypherUnion", "cypherMatch", "unwind", 
      "merge", "mergeAction", "create", "set", "setItem", "cypherDelete", 
      "remove", "removeItem", "with", "cypherReturn", "callProcedure", "procedureName", 
      "yieldProcedureResults", "memoryLimit", "queryMemoryLimit", "procedureMemoryLimit", 
      "procedureResult", "returnBody", "returnItems", "returnItem", "order", 
      "skip", "limit", "sortItem", "where", "pattern", "patternPart", "anonymousPatternPart", 
      "patternElement", "nodePattern", "patternElementChain", "relationshipPattern", 
      "leftArrowHead", "rightArrowHead", "dash", "relationshipDetail", "relationshipLambda", 
      "variableExpansion", "properties", "relationshipTypes", "nodeLabels", 
      "nodeLabel", "labelName", "relTypeName", "expression", "expression12", 
      "expression11", "expression10", "expression9", "expression8", "expression7", 
      "expression6", "expression5", "expression4", "expression3a", "stringAndNullOperators", 
      "expression3b", "listIndexingOrSlicing", "expression2a", "expression2b", 
      "atom", "literal", "booleanLiteral", "listLiteral", "partialComparisonExpression", 
      "parenthesizedExpression", "relationshipsPattern", "filterExpression", 
      "reduceExpression", "extractExpression", "idInColl", "functionInvocation", 
      "functionName", "listComprehension", "patternComprehension", "propertyLookup", 
      "caseExpression", "caseAlternatives", "variable", "numberLiteral", 
      "mapLiteral", "parameter", "propertyExpression", "propertyKeyName", 
      "integerLiteral", "createIndex", "dropIndex", "doubleLiteral", "cypherKeyword"
    },
    std::vector<std::string>{
      "", "'_'", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "'('", "')'", "'['", "']'", "'{'", 
      "'}'", "','", "'.'", "'..'", "':'", "';'", "'$'", "'|'", "'='", "'<'", 
      "'>'", "'<='", "'>='", "'<>'", "'!='", "'=~'", "'+'", "'-'", "'*'", 
      "'/'", "'%'", "'^'", "'+='"
    },
    std::vector<std::string>{
      "", "UNDERSCORE", "AFTER", "ALTER", "ASYNC", "AUTH", "BAD", "BATCH_INTERVAL", 
      "BATCH_LIMIT", "BATCH_SIZE", "BEFORE", "BOOTSTRAP_SERVERS", "CHECK", 
      "CLEAR", "COMMIT", "COMMITTED", "CONFIG", "CONFIGS", "CONSUMER_GROUP", 
      "CREDENTIALS", "CSV", "DATA", "DELIMITER", "DATABASE", "DENY", "DIRECTORY", 
      "DROP", "DUMP", "DURABILITY", "EXECUTE", "FOR", "FOREACH", "FREE", 
      "FREE_MEMORY", "FROM", "GLOBAL", "GRANT", "GRANTS", "HEADER", "IDENTIFIED", 
      "IGNORE", "ISOLATION", "KAFKA", "LEVEL", "LOAD", "LOCK", "MAIN", "MODE", 
      "MODULE_READ", "MODULE_WRITE", "NEXT", "NO", "PASSWORD", "PORT", "PRIVILEGES", 
      "PULSAR", "READ", "READ_FILE", "REGISTER", "REPLICA", "REPLICAS", 
      "REPLICATION", "REVOKE", "ROLE", "ROLES", "QUOTE", "SERVICE_URL", 
      "SESSION", "SETTING", "SETTINGS", "SNAPSHOT", "START", "STATS", "STOP", 
      "STREAM", "STREAMS", "SYNC", "TIMEOUT", "TO", "TOPICS", "TRANSACTION", 
      "TRANSFORM", "TRIGGER", "TRIGGERS", "UNCOMMITTED", "UNLOCK", "UPDATE", 
      "USER", "USERS", "VERSION", "WEBSOCKET", "Skipped", "LPAREN", "RPAREN", 
      "LBRACK", "RBRACK", "LBRACE", "RBRACE", "COMMA", "DOT", "DOTS", "COLON", 
      "SEMICOLON", "DOLLAR", "PIPE", "EQ", "LT", "GT", "LTE", "GTE", "NEQ1", 
      "NEQ2", "SIM", "PLUS", "MINUS", "ASTERISK", "SLASH", "PERCENT", "CARET", 
      "PLUS_EQ", "LeftArrowHeadPart", "RightArrowHeadPart", "DashPart", 
      "ALL", "AND", "ANY", "AS", "ASC", "ASCENDING", "ASSERT", "BFS", "BY", 
      "CALL", "CASE", "COALESCE", "CONSTRAINT", "CONTAINS", "COUNT", "CREATE", 
      "CYPHERNULL", "DELETE", "DESC", "DESCENDING", "DETACH", "DISTINCT", 
      "ELSE", "END", "ENDS", "EXISTS", "EXPLAIN", "EXTRACT", "FALSE", "FILTER", 
      "IN", "INDEX", "INFO", "IS", "KB", "KEY", "LIMIT", "L_SKIP", "MATCH", 
      "MB", "MEMORY", "MERGE", "NODE", "NONE", "NOT", "ON", "OPTIONAL", 
      "OR", "ORDER", "PROCEDURE", "PROFILE", "QUERY", "REDUCE", "REMOVE", 
      "RETURN", "SET", "SHOW", "SINGLE", "STARTS", "STORAGE", "THEN", "TRUE", 
      "UNION", "UNIQUE", "UNLIMITED", "UNWIND", "WHEN", "WHERE", "WITH", 
      "WSHORTEST", "XOR", "YIELD", "StringLiteral", "DecimalLiteral", "OctalLiteral", 
      "HexadecimalLiteral", "FloatingLiteral", "UnescapedSymbolicName", 
      "EscapedSymbolicName", "IdentifierStart", "IdentifierPart"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,203,1877,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,
  	7,128,2,129,7,129,2,130,7,130,2,131,7,131,2,132,7,132,2,133,7,133,2,134,
  	7,134,2,135,7,135,2,136,7,136,2,137,7,137,2,138,7,138,2,139,7,139,2,140,
  	7,140,2,141,7,141,2,142,7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,
  	7,146,2,147,7,147,2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,
  	7,152,2,153,7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,
  	7,158,2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,
  	7,164,2,165,7,165,2,166,7,166,2,167,7,167,2,168,7,168,2,169,7,169,2,170,
  	7,170,2,171,7,171,2,172,7,172,2,173,7,173,2,174,7,174,2,175,7,175,2,176,
  	7,176,2,177,7,177,2,178,7,178,2,179,7,179,2,180,7,180,2,181,7,181,2,182,
  	7,182,2,183,7,183,2,184,7,184,2,185,7,185,2,186,7,186,1,0,1,0,1,0,1,0,
  	1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
  	0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,
  	1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
  	0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,
  	1,0,1,0,1,0,1,0,1,0,3,0,454,8,0,1,1,1,1,1,1,3,1,459,8,1,1,2,1,2,1,2,1,
  	2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,3,2,478,8,2,1,3,
  	1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,3,3,495,8,3,1,
  	4,1,4,1,4,1,4,1,4,3,4,502,8,4,1,5,1,5,1,5,3,5,507,8,5,1,6,1,6,1,6,1,6,
  	1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,3,6,521,8,6,1,7,1,7,1,7,1,7,1,7,1,7,3,
  	7,529,8,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,4,8,538,8,8,11,8,12,8,539,1,8,1,
  	8,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,3,9,552,8,9,1,10,1,10,1,10,3,10,557,
  	8,10,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,3,11,567,8,11,1,11,1,11,
  	3,11,571,8,11,1,11,1,11,3,11,575,8,11,1,11,1,11,1,11,1,12,1,12,1,13,1,
  	13,1,14,1,14,1,15,1,15,1,16,1,16,1,17,1,17,1,17,1,17,1,18,1,18,1,18,1,
  	18,1,19,1,19,1,19,1,20,1,20,1,20,1,20,1,20,1,20,3,20,607,8,20,1,21,1,
  	21,1,21,1,21,1,21,1,21,1,21,1,22,1,22,1,22,1,22,1,23,1,23,1,23,1,24,1,
  	24,1,24,1,24,1,24,1,24,1,24,1,25,1,25,1,25,1,25,1,25,1,26,1,26,1,26,1,
  	26,3,26,639,8,26,1,26,1,26,1,26,1,27,1,27,1,27,1,27,3,27,648,8,27,1,27,
  	1,27,1,27,1,28,1,28,1,28,1,28,3,28,657,8,28,1,28,1,28,1,28,1,29,1,29,
  	1,30,1,30,1,30,5,30,667,8,30,10,30,12,30,670,9,30,1,31,1,31,1,31,1,31,
  	1,31,1,32,1,32,1,32,1,32,1,32,1,33,1,33,1,33,1,33,1,33,1,34,1,34,1,34,
  	1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,3,35,698,8,35,1,36,1,36,1,36,
  	1,36,1,37,1,37,1,38,1,38,1,39,1,39,1,39,1,39,1,39,1,39,1,39,1,40,1,40,
  	1,40,1,40,1,41,1,41,1,41,1,42,1,42,1,42,1,42,1,43,1,43,1,43,1,44,1,44,
  	1,45,5,45,732,8,45,10,45,12,45,735,9,45,1,46,1,46,1,46,1,47,1,47,1,47,
  	1,47,1,48,1,48,1,48,1,48,1,48,1,48,3,48,750,8,48,1,48,3,48,753,8,48,1,
  	48,1,48,1,48,1,48,1,48,1,49,1,49,1,49,1,49,1,50,1,50,1,50,1,51,1,51,1,
  	51,1,51,1,51,1,51,3,51,773,8,51,1,52,1,52,1,53,1,53,1,53,1,53,1,53,1,
  	53,1,53,1,54,1,54,1,54,1,55,1,55,1,56,1,56,1,56,5,56,792,8,56,10,56,12,
  	56,795,9,56,1,57,1,57,1,57,5,57,800,8,57,10,57,12,57,803,9,57,1,58,1,
  	58,1,58,5,58,808,8,58,10,58,12,58,811,9,58,1,59,1,59,3,59,815,8,59,1,
  	60,1,60,1,60,1,60,1,60,1,60,3,60,823,8,60,1,61,1,61,3,61,827,8,61,1,62,
  	1,62,1,62,1,62,1,63,1,63,1,63,1,63,5,63,837,8,63,10,63,12,63,840,9,63,
  	3,63,842,8,63,1,63,1,63,1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,
  	1,64,1,64,3,64,857,8,64,1,65,1,65,1,65,1,65,1,65,5,65,864,8,65,10,65,
  	12,65,867,9,65,1,66,1,66,1,66,1,66,1,66,3,66,874,8,66,1,67,1,67,1,67,
  	1,67,1,67,5,67,881,8,67,10,67,12,67,884,9,67,1,68,1,68,1,68,1,68,1,69,
  	1,69,1,69,1,69,1,69,3,69,895,8,69,1,69,1,69,3,69,899,8,69,1,70,1,70,1,
  	70,1,70,1,71,1,71,1,71,1,71,1,72,1,72,1,72,1,72,1,73,1,73,1,73,1,74,1,
  	74,1,74,1,74,1,74,3,74,921,8,74,1,74,1,74,3,74,925,8,74,1,75,1,75,1,76,
  	1,76,1,77,1,77,1,77,1,77,1,77,1,77,1,77,1,78,1,78,1,78,1,78,1,78,1,79,
  	1,79,1,79,1,79,1,80,1,80,1,80,1,81,1,81,3,81,952,8,81,1,81,1,81,1,82,
  	1,82,1,83,1,83,1,83,1,83,1,83,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,
  	1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,
  	1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,3,84,997,
  	8,84,1,85,1,85,1,85,1,85,1,85,1,85,5,85,1005,8,85,10,85,12,85,1008,9,
  	85,1,86,1,86,1,86,1,87,1,87,1,87,1,88,1,88,1,88,1,89,1,89,1,89,1,89,3,
  	89,1023,8,89,1,90,1,90,1,90,1,91,1,91,1,91,1,92,1,92,5,92,1033,8,92,10,
  	92,12,92,1036,9,92,1,92,3,92,1039,8,92,1,93,1,93,3,93,1043,8,93,1,94,
  	1,94,5,94,1047,8,94,10,94,12,94,1050,9,94,1,95,1,95,1,95,1,95,1,95,3,
  	95,1057,8,95,1,96,3,96,1060,8,96,1,96,1,96,1,96,3,96,1065,8,96,1,97,1,
  	97,1,97,1,97,1,97,1,98,1,98,1,98,5,98,1075,8,98,10,98,12,98,1078,9,98,
  	1,99,1,99,1,99,1,99,1,99,1,99,3,99,1086,8,99,1,100,1,100,1,100,1,101,
  	1,101,1,101,1,101,5,101,1095,8,101,10,101,12,101,1098,9,101,1,102,1,102,
  	1,102,1,102,1,102,1,102,1,102,1,102,1,102,1,102,1,102,1,102,1,102,1,102,
  	1,102,3,102,1115,8,102,1,103,3,103,1118,8,103,1,103,1,103,1,103,1,103,
  	5,103,1124,8,103,10,103,12,103,1127,9,103,1,104,1,104,1,104,1,104,5,104,
  	1133,8,104,10,104,12,104,1136,9,104,1,105,1,105,1,105,1,105,3,105,1142,
  	8,105,1,106,1,106,3,106,1146,8,106,1,106,1,106,3,106,1150,8,106,1,107,
  	1,107,3,107,1154,8,107,1,107,1,107,1,108,1,108,1,108,1,108,1,108,1,108,
  	5,108,1164,8,108,10,108,12,108,1167,9,108,3,108,1169,8,108,1,108,1,108,
  	3,108,1173,8,108,1,108,3,108,1176,8,108,1,109,1,109,1,109,5,109,1181,
  	8,109,10,109,12,109,1184,9,109,1,110,1,110,1,110,1,110,1,110,5,110,1191,
  	8,110,10,110,12,110,1194,9,110,3,110,1196,8,110,1,111,1,111,1,111,1,111,
  	1,111,1,111,3,111,1204,8,111,1,112,1,112,1,112,1,113,1,113,1,113,1,114,
  	1,114,1,114,1,114,1,114,3,114,1217,8,114,1,115,1,115,3,115,1221,8,115,
  	1,115,3,115,1224,8,115,1,115,3,115,1227,8,115,1,116,1,116,1,116,5,116,
  	1232,8,116,10,116,12,116,1235,9,116,1,116,1,116,1,116,5,116,1240,8,116,
  	10,116,12,116,1243,9,116,3,116,1245,8,116,1,117,1,117,1,117,1,117,1,117,
  	3,117,1252,8,117,1,118,1,118,1,118,1,118,1,118,5,118,1259,8,118,10,118,
  	12,118,1262,9,118,1,119,1,119,1,119,1,120,1,120,1,120,1,121,1,121,3,121,
  	1272,8,121,1,122,1,122,1,122,1,123,1,123,1,123,5,123,1280,8,123,10,123,
  	12,123,1283,9,123,1,124,1,124,1,124,1,124,1,124,3,124,1290,8,124,1,125,
  	1,125,1,126,1,126,5,126,1296,8,126,10,126,12,126,1299,9,126,1,126,1,126,
  	1,126,1,126,3,126,1305,8,126,1,127,1,127,3,127,1309,8,127,1,127,3,127,
  	1312,8,127,1,127,3,127,1315,8,127,1,127,1,127,1,128,1,128,1,128,1,129,
  	1,129,1,129,3,129,1325,8,129,1,129,1,129,1,129,1,129,1,129,1,129,3,129,
  	1333,8,129,1,129,1,129,1,129,1,129,3,129,1339,8,129,1,129,1,129,1,129,
  	1,129,1,129,3,129,1346,8,129,1,129,1,129,3,129,1350,8,129,1,130,1,130,
  	1,131,1,131,1,132,1,132,1,133,1,133,3,133,1360,8,133,1,133,3,133,1363,
  	8,133,1,133,3,133,1366,8,133,1,133,1,133,1,133,1,133,1,133,3,133,1373,
  	8,133,1,133,3,133,1376,8,133,1,133,3,133,1379,8,133,1,133,1,133,3,133,
  	1383,8,133,1,133,3,133,1386,8,133,1,133,1,133,1,133,1,133,3,133,1392,
  	8,133,1,133,3,133,1395,8,133,1,133,3,133,1398,8,133,1,133,5,133,1401,
  	8,133,10,133,12,133,1404,9,133,1,133,1,133,1,133,3,133,1409,8,133,1,133,
  	3,133,1412,8,133,1,133,3,133,1415,8,133,1,134,1,134,1,134,1,134,1,134,
  	1,134,1,134,1,134,1,135,1,135,3,135,1427,8,135,1,135,3,135,1430,8,135,
  	1,135,1,135,3,135,1434,8,135,3,135,1436,8,135,1,136,1,136,3,136,1440,
  	8,136,1,137,1,137,1,137,1,137,3,137,1446,8,137,1,137,5,137,1449,8,137,
  	10,137,12,137,1452,9,137,1,138,1,138,5,138,1456,8,138,10,138,12,138,1459,
  	9,138,1,139,1,139,1,139,1,140,1,140,1,141,1,141,1,142,1,142,1,143,1,143,
  	1,143,5,143,1473,8,143,10,143,12,143,1476,9,143,1,144,1,144,1,144,5,144,
  	1481,8,144,10,144,12,144,1484,9,144,1,145,1,145,1,145,5,145,1489,8,145,
  	10,145,12,145,1492,9,145,1,146,5,146,1495,8,146,10,146,12,146,1498,9,
  	146,1,146,1,146,1,147,1,147,5,147,1504,8,147,10,147,12,147,1507,9,147,
  	1,148,1,148,1,148,1,148,1,148,5,148,1514,8,148,10,148,12,148,1517,9,148,
  	1,149,1,149,1,149,1,149,1,149,1,149,1,149,5,149,1526,8,149,10,149,12,
  	149,1529,9,149,1,150,1,150,1,150,5,150,1534,8,150,10,150,12,150,1537,
  	9,150,1,151,5,151,1540,8,151,10,151,12,151,1543,9,151,1,151,1,151,1,152,
  	1,152,5,152,1549,8,152,10,152,12,152,1552,9,152,1,153,1,153,1,153,1,153,
  	1,153,1,153,1,153,3,153,1561,8,153,1,153,1,153,1,153,1,153,1,153,1,153,
  	3,153,1569,8,153,1,154,1,154,5,154,1573,8,154,10,154,12,154,1576,9,154,
  	1,155,1,155,1,155,1,155,1,155,1,155,3,155,1584,8,155,1,155,1,155,3,155,
  	1588,8,155,1,155,3,155,1591,8,155,1,156,1,156,3,156,1595,8,156,1,157,
  	1,157,5,157,1599,8,157,10,157,12,157,1602,9,157,1,158,1,158,1,158,1,158,
  	1,158,1,158,1,158,1,158,1,158,1,158,1,158,1,158,1,158,1,158,1,158,1,158,
  	1,158,1,158,1,158,1,158,1,158,1,158,1,158,1,158,1,158,1,158,1,158,1,158,
  	1,158,5,158,1633,8,158,10,158,12,158,1636,9,158,1,158,1,158,1,158,1,158,
  	1,158,1,158,1,158,1,158,1,158,1,158,1,158,1,158,1,158,1,158,1,158,1,158,
  	1,158,1,158,1,158,1,158,1,158,1,158,1,158,1,158,1,158,1,158,3,158,1664,
  	8,158,1,159,1,159,1,159,1,159,1,159,1,159,3,159,1672,8,159,1,160,1,160,
  	1,161,1,161,1,161,1,161,5,161,1680,8,161,10,161,12,161,1683,9,161,3,161,
  	1685,8,161,1,161,1,161,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,
  	1,162,1,162,1,162,1,162,1,162,1,162,3,162,1703,8,162,1,163,1,163,1,163,
  	1,163,1,164,1,164,4,164,1711,8,164,11,164,12,164,1712,1,165,1,165,3,165,
  	1717,8,165,1,166,1,166,1,166,1,166,1,166,1,166,1,166,1,166,1,167,1,167,
  	1,167,1,167,1,168,1,168,1,168,1,168,1,169,1,169,1,169,3,169,1738,8,169,
  	1,169,1,169,1,169,5,169,1743,8,169,10,169,12,169,1746,9,169,3,169,1748,
  	8,169,1,169,1,169,1,170,1,170,1,170,5,170,1755,8,170,10,170,12,170,1758,
  	9,170,1,171,1,171,1,171,1,171,3,171,1764,8,171,1,171,1,171,1,172,1,172,
  	1,172,1,172,3,172,1772,8,172,1,172,1,172,1,172,3,172,1777,8,172,1,172,
  	1,172,1,172,1,172,1,173,1,173,1,173,1,174,1,174,4,174,1788,8,174,11,174,
  	12,174,1789,1,174,1,174,1,174,4,174,1795,8,174,11,174,12,174,1796,3,174,
  	1799,8,174,1,174,1,174,3,174,1803,8,174,1,174,1,174,1,175,1,175,1,175,
  	1,175,1,175,1,176,1,176,1,177,1,177,3,177,1816,8,177,1,178,1,178,1,178,
  	1,178,1,178,1,178,1,178,1,178,1,178,5,178,1827,8,178,10,178,12,178,1830,
  	9,178,3,178,1832,8,178,1,178,1,178,1,179,1,179,1,179,3,179,1839,8,179,
  	1,180,1,180,4,180,1843,8,180,11,180,12,180,1844,1,181,1,181,1,182,1,182,
  	1,183,1,183,1,183,1,183,1,183,1,183,1,183,1,183,1,183,3,183,1860,8,183,
  	1,184,1,184,1,184,1,184,1,184,1,184,1,184,1,184,1,184,3,184,1871,8,184,
  	1,185,1,185,1,186,1,186,1,186,1,733,0,187,0,2,4,6,8,10,12,14,16,18,20,
  	22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,
  	68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,
  	112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,
  	148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,
  	184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,
  	220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,
  	256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,
  	292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,
  	328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,
  	364,366,368,370,372,0,19,2,0,51,51,191,191,19,0,5,5,16,16,27,28,33,33,
  	48,49,57,57,61,61,72,72,74,74,82,82,90,90,135,135,138,138,140,140,154,
  	154,161,161,164,164,176,176,178,178,2,0,46,46,59,59,2,0,4,4,76,76,2,0,
  	45,45,85,85,3,0,86,86,138,138,140,140,2,0,2,2,10,10,3,0,35,35,50,50,67,
  	67,2,0,26,26,138,138,2,0,157,157,162,162,2,0,127,128,141,142,2,0,106,
  	106,120,120,2,0,107,107,121,121,2,0,114,114,122,122,2,0,130,130,192,192,
  	1,0,113,114,2,0,151,151,184,184,1,0,196,198,5,0,123,133,135,156,158,161,
  	164,186,188,194,2026,0,453,1,0,0,0,2,458,1,0,0,0,4,477,1,0,0,0,6,494,
  	1,0,0,0,8,501,1,0,0,0,10,506,1,0,0,0,12,520,1,0,0,0,14,528,1,0,0,0,16,
  	530,1,0,0,0,18,551,1,0,0,0,20,556,1,0,0,0,22,558,1,0,0,0,24,579,1,0,0,
  	0,26,581,1,0,0,0,28,583,1,0,0,0,30,585,1,0,0,0,32,587,1,0,0,0,34,589,
  	1,0,0,0,36,593,1,0,0,0,38,597,1,0,0,0,40,600,1,0,0,0,42,608,1,0,0,0,44,
  	615,1,0,0,0,46,619,1,0,0,0,48,622,1,0,0,0,50,629,1,0,0,0,52,634,1,0,0,
  	0,54,643,1,0,0,0,56,652,1,0,0,0,58,661,1,0,0,0,60,663,1,0,0,0,62,671,
  	1,0,0,0,64,676,1,0,0,0,66,681,1,0,0,0,68,686,1,0,0,0,70,689,1,0,0,0,72,
  	699,1,0,0,0,74,703,1,0,0,0,76,705,1,0,0,0,78,707,1,0,0,0,80,714,1,0,0,
  	0,82,718,1,0,0,0,84,721,1,0,0,0,86,725,1,0,0,0,88,728,1,0,0,0,90,733,
  	1,0,0,0,92,736,1,0,0,0,94,739,1,0,0,0,96,743,1,0,0,0,98,759,1,0,0,0,100,
  	763,1,0,0,0,102,772,1,0,0,0,104,774,1,0,0,0,106,776,1,0,0,0,108,783,1,
  	0,0,0,110,786,1,0,0,0,112,788,1,0,0,0,114,796,1,0,0,0,116,804,1,0,0,0,
  	118,814,1,0,0,0,120,822,1,0,0,0,122,826,1,0,0,0,124,828,1,0,0,0,126,832,
  	1,0,0,0,128,856,1,0,0,0,130,858,1,0,0,0,132,873,1,0,0,0,134,875,1,0,0,
  	0,136,885,1,0,0,0,138,889,1,0,0,0,140,900,1,0,0,0,142,904,1,0,0,0,144,
  	908,1,0,0,0,146,912,1,0,0,0,148,915,1,0,0,0,150,926,1,0,0,0,152,928,1,
  	0,0,0,154,930,1,0,0,0,156,937,1,0,0,0,158,942,1,0,0,0,160,946,1,0,0,0,
  	162,949,1,0,0,0,164,955,1,0,0,0,166,957,1,0,0,0,168,996,1,0,0,0,170,998,
  	1,0,0,0,172,1009,1,0,0,0,174,1012,1,0,0,0,176,1015,1,0,0,0,178,1018,1,
  	0,0,0,180,1024,1,0,0,0,182,1027,1,0,0,0,184,1030,1,0,0,0,186,1042,1,0,
  	0,0,188,1044,1,0,0,0,190,1056,1,0,0,0,192,1059,1,0,0,0,194,1066,1,0,0,
  	0,196,1071,1,0,0,0,198,1085,1,0,0,0,200,1087,1,0,0,0,202,1090,1,0,0,0,
  	204,1114,1,0,0,0,206,1117,1,0,0,0,208,1128,1,0,0,0,210,1141,1,0,0,0,212,
  	1143,1,0,0,0,214,1151,1,0,0,0,216,1157,1,0,0,0,218,1177,1,0,0,0,220,1185,
  	1,0,0,0,222,1197,1,0,0,0,224,1205,1,0,0,0,226,1208,1,0,0,0,228,1216,1,
  	0,0,0,230,1218,1,0,0,0,232,1244,1,0,0,0,234,1251,1,0,0,0,236,1253,1,0,
  	0,0,238,1263,1,0,0,0,240,1266,1,0,0,0,242,1269,1,0,0,0,244,1273,1,0,0,
  	0,246,1276,1,0,0,0,248,1289,1,0,0,0,250,1291,1,0,0,0,252,1304,1,0,0,0,
  	254,1306,1,0,0,0,256,1318,1,0,0,0,258,1349,1,0,0,0,260,1351,1,0,0,0,262,
  	1353,1,0,0,0,264,1355,1,0,0,0,266,1414,1,0,0,0,268,1416,1,0,0,0,270,1424,
  	1,0,0,0,272,1439,1,0,0,0,274,1441,1,0,0,0,276,1453,1,0,0,0,278,1460,1,
  	0,0,0,280,1463,1,0,0,0,282,1465,1,0,0,0,284,1467,1,0,0,0,286,1469,1,0,
  	0,0,288,1477,1,0,0,0,290,1485,1,0,0,0,292,1496,1,0,0,0,294,1501,1,0,0,
  	0,296,1508,1,0,0,0,298,1518,1,0,0,0,300,1530,1,0,0,0,302,1541,1,0,0,0,
  	304,1546,1,0,0,0,306,1568,1,0,0,0,308,1570,1,0,0,0,310,1590,1,0,0,0,312,
  	1592,1,0,0,0,314,1596,1,0,0,0,316,1663,1,0,0,0,318,1671,1,0,0,0,320,1673,
  	1,0,0,0,322,1675,1,0,0,0,324,1702,1,0,0,0,326,1704,1,0,0,0,328,1708,1,
  	0,0,0,330,1714,1,0,0,0,332,1718,1,0,0,0,334,1726,1,0,0,0,336,1730,1,0,
  	0,0,338,1734,1,0,0,0,340,1751,1,0,0,0,342,1759,1,0,0,0,344,1767,1,0,0,
  	0,346,1782,1,0,0,0,348,1798,1,0,0,0,350,1806,1,0,0,0,352,1811,1,0,0,0,
  	354,1815,1,0,0,0,356,1817,1,0,0,0,358,1835,1,0,0,0,360,1840,1,0,0,0,362,
  	1846,1,0,0,0,364,1848,1,0,0,0,366,1850,1,0,0,0,368,1861,1,0,0,0,370,1872,
  	1,0,0,0,372,1874,1,0,0,0,374,454,3,372,186,0,375,454,5,2,0,0,376,454,
  	5,3,0,0,377,454,5,4,0,0,378,454,5,5,0,0,379,454,5,6,0,0,380,454,5,7,0,
  	0,381,454,5,8,0,0,382,454,5,9,0,0,383,454,5,10,0,0,384,454,5,11,0,0,385,
  	454,5,12,0,0,386,454,5,13,0,0,387,454,5,14,0,0,388,454,5,15,0,0,389,454,
  	5,16,0,0,390,454,5,17,0,0,391,454,5,18,0,0,392,454,5,19,0,0,393,454,5,
  	20,0,0,394,454,5,21,0,0,395,454,5,22,0,0,396,454,5,23,0,0,397,454,5,24,
  	0,0,398,454,5,26,0,0,399,454,5,27,0,0,400,454,5,29,0,0,401,454,5,30,0,
  	0,402,454,5,31,0,0,403,454,5,32,0,0,404,454,5,34,0,0,405,454,5,35,0,0,
  	406,454,5,36,0,0,407,454,5,38,0,0,408,454,5,39,0,0,409,454,5,41,0,0,410,
  	454,5,42,0,0,411,454,5,43,0,0,412,454,5,44,0,0,413,454,5,45,0,0,414,454,
  	5,46,0,0,415,454,5,47,0,0,416,454,5,50,0,0,417,454,5,51,0,0,418,454,5,
  	52,0,0,419,454,5,55,0,0,420,454,5,53,0,0,421,454,5,54,0,0,422,454,5,56,
  	0,0,423,454,5,58,0,0,424,454,5,59,0,0,425,454,5,60,0,0,426,454,5,61,0,
  	0,427,454,5,62,0,0,428,454,5,63,0,0,429,454,5,64,0,0,430,454,5,65,0,0,
  	431,454,5,67,0,0,432,454,5,68,0,0,433,454,5,69,0,0,434,454,5,70,0,0,435,
  	454,5,71,0,0,436,454,5,72,0,0,437,454,5,74,0,0,438,454,5,75,0,0,439,454,
  	5,76,0,0,440,454,5,77,0,0,441,454,5,78,0,0,442,454,5,79,0,0,443,454,5,
  	80,0,0,444,454,5,81,0,0,445,454,5,82,0,0,446,454,5,83,0,0,447,454,5,84,
  	0,0,448,454,5,85,0,0,449,454,5,86,0,0,450,454,5,87,0,0,451,454,5,88,0,
  	0,452,454,5,89,0,0,453,374,1,0,0,0,453,375,1,0,0,0,453,376,1,0,0,0,453,
  	377,1,0,0,0,453,378,1,0,0,0,453,379,1,0,0,0,453,380,1,0,0,0,453,381,1,
  	0,0,0,453,382,1,0,0,0,453,383,1,0,0,0,453,384,1,0,0,0,453,385,1,0,0,0,
  	453,386,1,0,0,0,453,387,1,0,0,0,453,388,1,0,0,0,453,389,1,0,0,0,453,390,
  	1,0,0,0,453,391,1,0,0,0,453,392,1,0,0,0,453,393,1,0,0,0,453,394,1,0,0,
  	0,453,395,1,0,0,0,453,396,1,0,0,0,453,397,1,0,0,0,453,398,1,0,0,0,453,
  	399,1,0,0,0,453,400,1,0,0,0,453,401,1,0,0,0,453,402,1,0,0,0,453,403,1,
  	0,0,0,453,404,1,0,0,0,453,405,1,0,0,0,453,406,1,0,0,0,453,407,1,0,0,0,
  	453,408,1,0,0,0,453,409,1,0,0,0,453,410,1,0,0,0,453,411,1,0,0,0,453,412,
  	1,0,0,0,453,413,1,0,0,0,453,414,1,0,0,0,453,415,1,0,0,0,453,416,1,0,0,
  	0,453,417,1,0,0,0,453,418,1,0,0,0,453,419,1,0,0,0,453,420,1,0,0,0,453,
  	421,1,0,0,0,453,422,1,0,0,0,453,423,1,0,0,0,453,424,1,0,0,0,453,425,1,
  	0,0,0,453,426,1,0,0,0,453,427,1,0,0,0,453,428,1,0,0,0,453,429,1,0,0,0,
  	453,430,1,0,0,0,453,431,1,0,0,0,453,432,1,0,0,0,453,433,1,0,0,0,453,434,
  	1,0,0,0,453,435,1,0,0,0,453,436,1,0,0,0,453,437,1,0,0,0,453,438,1,0,0,
  	0,453,439,1,0,0,0,453,440,1,0,0,0,453,441,1,0,0,0,453,442,1,0,0,0,453,
  	443,1,0,0,0,453,444,1,0,0,0,453,445,1,0,0,0,453,446,1,0,0,0,453,447,1,
  	0,0,0,453,448,1,0,0,0,453,449,1,0,0,0,453,450,1,0,0,0,453,451,1,0,0,0,
  	453,452,1,0,0,0,454,1,1,0,0,0,455,459,5,200,0,0,456,459,5,201,0,0,457,
  	459,3,0,0,0,458,455,1,0,0,0,458,456,1,0,0,0,458,457,1,0,0,0,459,3,1,0,
  	0,0,460,478,3,184,92,0,461,478,3,186,93,0,462,478,3,180,90,0,463,478,
  	3,182,91,0,464,478,3,178,89,0,465,478,3,166,83,0,466,478,3,6,3,0,467,
  	478,3,68,34,0,468,478,3,8,4,0,469,478,3,84,42,0,470,478,3,86,43,0,471,
  	478,3,10,5,0,472,478,3,106,53,0,473,478,3,108,54,0,474,478,3,18,9,0,475,
  	478,3,20,10,0,476,478,3,160,80,0,477,460,1,0,0,0,477,461,1,0,0,0,477,
  	462,1,0,0,0,477,463,1,0,0,0,477,464,1,0,0,0,477,465,1,0,0,0,477,466,1,
  	0,0,0,477,467,1,0,0,0,477,468,1,0,0,0,477,469,1,0,0,0,477,470,1,0,0,0,
  	477,471,1,0,0,0,477,472,1,0,0,0,477,473,1,0,0,0,477,474,1,0,0,0,477,475,
  	1,0,0,0,477,476,1,0,0,0,478,5,1,0,0,0,479,495,3,34,17,0,480,495,3,36,
  	18,0,481,495,3,38,19,0,482,495,3,40,20,0,483,495,3,42,21,0,484,495,3,
  	44,22,0,485,495,3,46,23,0,486,495,3,48,24,0,487,495,3,50,25,0,488,495,
  	3,52,26,0,489,495,3,54,27,0,490,495,3,56,28,0,491,495,3,62,31,0,492,495,
  	3,64,32,0,493,495,3,66,33,0,494,479,1,0,0,0,494,480,1,0,0,0,494,481,1,
  	0,0,0,494,482,1,0,0,0,494,483,1,0,0,0,494,484,1,0,0,0,494,485,1,0,0,0,
  	494,486,1,0,0,0,494,487,1,0,0,0,494,488,1,0,0,0,494,489,1,0,0,0,494,490,
  	1,0,0,0,494,491,1,0,0,0,494,492,1,0,0,0,494,493,1,0,0,0,495,7,1,0,0,0,
  	496,502,3,70,35,0,497,502,3,72,36,0,498,502,3,78,39,0,499,502,3,80,40,
  	0,500,502,3,82,41,0,501,496,1,0,0,0,501,497,1,0,0,0,501,498,1,0,0,0,501,
  	499,1,0,0,0,501,500,1,0,0,0,502,9,1,0,0,0,503,507,3,96,48,0,504,507,3,
  	98,49,0,505,507,3,100,50,0,506,503,1,0,0,0,506,504,1,0,0,0,506,505,1,
  	0,0,0,507,11,1,0,0,0,508,521,3,192,96,0,509,521,3,194,97,0,510,521,3,
  	196,98,0,511,521,3,200,100,0,512,521,3,202,101,0,513,521,3,206,103,0,
  	514,521,3,208,104,0,515,521,3,212,106,0,516,521,3,214,107,0,517,521,3,
  	216,108,0,518,521,3,22,11,0,519,521,3,16,8,0,520,508,1,0,0,0,520,509,
  	1,0,0,0,520,510,1,0,0,0,520,511,1,0,0,0,520,512,1,0,0,0,520,513,1,0,0,
  	0,520,514,1,0,0,0,520,515,1,0,0,0,520,516,1,0,0,0,520,517,1,0,0,0,520,
  	518,1,0,0,0,520,519,1,0,0,0,521,13,1,0,0,0,522,529,3,202,101,0,523,529,
  	3,208,104,0,524,529,3,200,100,0,525,529,3,196,98,0,526,529,3,206,103,
  	0,527,529,3,16,8,0,528,522,1,0,0,0,528,523,1,0,0,0,528,524,1,0,0,0,528,
  	525,1,0,0,0,528,526,1,0,0,0,528,527,1,0,0,0,529,15,1,0,0,0,530,531,5,
  	31,0,0,531,532,5,92,0,0,532,533,3,352,176,0,533,534,5,153,0,0,534,535,
  	3,284,142,0,535,537,5,104,0,0,536,538,3,14,7,0,537,536,1,0,0,0,538,539,
  	1,0,0,0,539,537,1,0,0,0,539,540,1,0,0,0,540,541,1,0,0,0,541,542,5,93,
  	0,0,542,17,1,0,0,0,543,552,3,148,74,0,544,552,3,122,61,0,545,552,3,136,
  	68,0,546,552,3,138,69,0,547,552,3,140,70,0,548,552,3,142,71,0,549,552,
  	3,144,72,0,550,552,3,146,73,0,551,543,1,0,0,0,551,544,1,0,0,0,551,545,
  	1,0,0,0,551,546,1,0,0,0,551,547,1,0,0,0,551,548,1,0,0,0,551,549,1,0,0,
  	0,551,550,1,0,0,0,552,19,1,0,0,0,553,557,3,154,77,0,554,557,3,156,78,
  	0,555,557,3,158,79,0,556,553,1,0,0,0,556,554,1,0,0,0,556,555,1,0,0,0,
  	557,21,1,0,0,0,558,559,5,44,0,0,559,560,5,20,0,0,560,561,5,34,0,0,561,
  	562,3,24,12,0,562,563,7,0,0,0,563,566,5,38,0,0,564,565,5,40,0,0,565,567,
  	5,6,0,0,566,564,1,0,0,0,566,567,1,0,0,0,567,570,1,0,0,0,568,569,5,22,
  	0,0,569,571,3,26,13,0,570,568,1,0,0,0,570,571,1,0,0,0,571,574,1,0,0,0,
  	572,573,5,65,0,0,573,575,3,28,14,0,574,572,1,0,0,0,574,575,1,0,0,0,575,
  	576,1,0,0,0,576,577,5,126,0,0,577,578,3,30,15,0,578,23,1,0,0,0,579,580,
  	3,318,159,0,580,25,1,0,0,0,581,582,3,318,159,0,582,27,1,0,0,0,583,584,
  	3,318,159,0,584,29,1,0,0,0,585,586,3,352,176,0,586,31,1,0,0,0,587,588,
  	3,2,1,0,588,33,1,0,0,0,589,590,5,138,0,0,590,591,5,63,0,0,591,592,3,32,
  	16,0,592,35,1,0,0,0,593,594,5,26,0,0,594,595,5,63,0,0,595,596,3,32,16,
  	0,596,37,1,0,0,0,597,598,5,179,0,0,598,599,5,64,0,0,599,39,1,0,0,0,600,
  	601,5,138,0,0,601,602,5,87,0,0,602,606,3,32,16,0,603,604,5,39,0,0,604,
  	605,5,131,0,0,605,607,3,318,159,0,606,603,1,0,0,0,606,607,1,0,0,0,607,
  	41,1,0,0,0,608,609,5,178,0,0,609,610,5,52,0,0,610,611,5,30,0,0,611,612,
  	3,32,16,0,612,613,5,78,0,0,613,614,3,318,159,0,614,43,1,0,0,0,615,616,
  	5,26,0,0,616,617,5,87,0,0,617,618,3,32,16,0,618,45,1,0,0,0,619,620,5,
  	179,0,0,620,621,5,88,0,0,621,47,1,0,0,0,622,623,5,178,0,0,623,624,5,63,
  	0,0,624,625,5,30,0,0,625,626,3,32,16,0,626,627,5,78,0,0,627,628,3,32,
  	16,0,628,49,1,0,0,0,629,630,5,13,0,0,630,631,5,63,0,0,631,632,5,30,0,
  	0,632,633,3,32,16,0,633,51,1,0,0,0,634,638,5,36,0,0,635,636,5,123,0,0,
  	636,639,5,54,0,0,637,639,3,60,30,0,638,635,1,0,0,0,638,637,1,0,0,0,639,
  	640,1,0,0,0,640,641,5,78,0,0,641,642,3,32,16,0,642,53,1,0,0,0,643,647,
  	5,24,0,0,644,645,5,123,0,0,645,648,5,54,0,0,646,648,3,60,30,0,647,644,
  	1,0,0,0,647,646,1,0,0,0,648,649,1,0,0,0,649,650,5,78,0,0,650,651,3,32,
  	16,0,651,55,1,0,0,0,652,656,5,62,0,0,653,654,5,123,0,0,654,657,5,54,0,
  	0,655,657,3,60,30,0,656,653,1,0,0,0,656,655,1,0,0,0,657,658,1,0,0,0,658,
  	659,5,34,0,0,659,660,3,32,16,0,660,57,1,0,0,0,661,662,7,1,0,0,662,59,
  	1,0,0,0,663,668,3,58,29,0,664,665,5,98,0,0,665,667,3,58,29,0,666,664,
  	1,0,0,0,667,670,1,0,0,0,668,666,1,0,0,0,668,669,1,0,0,0,669,61,1,0,0,
  	0,670,668,1,0,0,0,671,672,5,179,0,0,672,673,5,54,0,0,673,674,5,30,0,0,
  	674,675,3,32,16,0,675,63,1,0,0,0,676,677,5,179,0,0,677,678,5,63,0,0,678,
  	679,5,30,0,0,679,680,3,32,16,0,680,65,1,0,0,0,681,682,5,179,0,0,682,683,
  	5,88,0,0,683,684,5,30,0,0,684,685,3,32,16,0,685,67,1,0,0,0,686,687,5,
  	27,0,0,687,688,5,23,0,0,688,69,1,0,0,0,689,690,5,178,0,0,690,691,5,61,
  	0,0,691,692,5,63,0,0,692,693,5,78,0,0,693,697,7,2,0,0,694,695,5,191,0,
  	0,695,696,5,53,0,0,696,698,3,318,159,0,697,694,1,0,0,0,697,698,1,0,0,
  	0,698,71,1,0,0,0,699,700,5,179,0,0,700,701,5,61,0,0,701,702,5,63,0,0,
  	702,73,1,0,0,0,703,704,3,2,1,0,704,75,1,0,0,0,705,706,3,318,159,0,706,
  	77,1,0,0,0,707,708,5,58,0,0,708,709,5,59,0,0,709,710,3,74,37,0,710,711,
  	7,3,0,0,711,712,5,78,0,0,712,713,3,76,38,0,713,79,1,0,0,0,714,715,5,26,
  	0,0,715,716,5,59,0,0,716,717,3,74,37,0,717,81,1,0,0,0,718,719,5,179,0,
  	0,719,720,5,60,0,0,720,83,1,0,0,0,721,722,7,4,0,0,722,723,5,21,0,0,723,
  	724,5,25,0,0,724,85,1,0,0,0,725,726,5,32,0,0,726,727,5,163,0,0,727,87,
  	1,0,0,0,728,729,3,2,1,0,729,89,1,0,0,0,730,732,9,0,0,0,731,730,1,0,0,
  	0,732,735,1,0,0,0,733,734,1,0,0,0,733,731,1,0,0,0,734,91,1,0,0,0,735,
  	733,1,0,0,0,736,737,5,92,0,0,737,738,5,93,0,0,738,93,1,0,0,0,739,740,
  	3,264,132,0,740,741,3,264,132,0,741,742,3,262,131,0,742,95,1,0,0,0,743,
  	744,5,138,0,0,744,745,5,82,0,0,745,752,3,88,44,0,746,749,5,168,0,0,747,
  	750,3,92,46,0,748,750,3,94,47,0,749,747,1,0,0,0,749,748,1,0,0,0,749,750,
  	1,0,0,0,750,751,1,0,0,0,751,753,7,5,0,0,752,746,1,0,0,0,752,753,1,0,0,
  	0,753,754,1,0,0,0,754,755,7,6,0,0,755,756,5,14,0,0,756,757,5,29,0,0,757,
  	758,3,90,45,0,758,97,1,0,0,0,759,760,5,26,0,0,760,761,5,82,0,0,761,762,
  	3,88,44,0,762,99,1,0,0,0,763,764,5,179,0,0,764,765,5,83,0,0,765,101,1,
  	0,0,0,766,767,5,70,0,0,767,773,5,41,0,0,768,769,5,56,0,0,769,773,5,15,
  	0,0,770,771,5,56,0,0,771,773,5,84,0,0,772,766,1,0,0,0,772,768,1,0,0,0,
  	772,770,1,0,0,0,773,103,1,0,0,0,774,775,7,7,0,0,775,105,1,0,0,0,776,777,
  	5,178,0,0,777,778,3,104,52,0,778,779,5,80,0,0,779,780,5,41,0,0,780,781,
  	5,43,0,0,781,782,3,102,51,0,782,107,1,0,0,0,783,784,5,138,0,0,784,785,
  	5,70,0,0,785,109,1,0,0,0,786,787,3,2,1,0,787,111,1,0,0,0,788,793,3,2,
  	1,0,789,790,5,114,0,0,790,792,3,2,1,0,791,789,1,0,0,0,792,795,1,0,0,0,
  	793,791,1,0,0,0,793,794,1,0,0,0,794,113,1,0,0,0,795,793,1,0,0,0,796,801,
  	3,112,56,0,797,798,5,99,0,0,798,800,3,112,56,0,799,797,1,0,0,0,800,803,
  	1,0,0,0,801,799,1,0,0,0,801,802,1,0,0,0,802,115,1,0,0,0,803,801,1,0,0,
  	0,804,809,3,114,57,0,805,806,5,98,0,0,806,808,3,114,57,0,807,805,1,0,
  	0,0,808,811,1,0,0,0,809,807,1,0,0,0,809,810,1,0,0,0,810,117,1,0,0,0,811,
  	809,1,0,0,0,812,815,3,116,58,0,813,815,3,318,159,0,814,812,1,0,0,0,814,
  	813,1,0,0,0,815,119,1,0,0,0,816,817,5,81,0,0,817,823,3,218,109,0,818,
  	819,5,7,0,0,819,823,3,318,159,0,820,821,5,9,0,0,821,823,3,318,159,0,822,
  	816,1,0,0,0,822,818,1,0,0,0,822,820,1,0,0,0,823,121,1,0,0,0,824,827,3,
  	130,65,0,825,827,3,134,67,0,826,824,1,0,0,0,826,825,1,0,0,0,827,123,1,
  	0,0,0,828,829,3,318,159,0,829,830,5,101,0,0,830,831,3,318,159,0,831,125,
  	1,0,0,0,832,841,5,96,0,0,833,838,3,124,62,0,834,835,5,98,0,0,835,837,
  	3,124,62,0,836,834,1,0,0,0,837,840,1,0,0,0,838,836,1,0,0,0,838,839,1,
  	0,0,0,839,842,1,0,0,0,840,838,1,0,0,0,841,833,1,0,0,0,841,842,1,0,0,0,
  	842,843,1,0,0,0,843,844,5,97,0,0,844,127,1,0,0,0,845,846,5,79,0,0,846,
  	857,3,118,59,0,847,848,5,18,0,0,848,857,3,114,57,0,849,850,5,11,0,0,850,
  	857,3,318,159,0,851,852,5,17,0,0,852,857,3,126,63,0,853,854,5,19,0,0,
  	854,857,3,126,63,0,855,857,3,120,60,0,856,845,1,0,0,0,856,847,1,0,0,0,
  	856,849,1,0,0,0,856,851,1,0,0,0,856,853,1,0,0,0,856,855,1,0,0,0,857,129,
  	1,0,0,0,858,859,5,138,0,0,859,860,5,42,0,0,860,861,5,74,0,0,861,865,3,
  	110,55,0,862,864,3,128,64,0,863,862,1,0,0,0,864,867,1,0,0,0,865,863,1,
  	0,0,0,865,866,1,0,0,0,866,131,1,0,0,0,867,865,1,0,0,0,868,869,5,79,0,
  	0,869,874,3,118,59,0,870,871,5,66,0,0,871,874,3,318,159,0,872,874,3,120,
  	60,0,873,868,1,0,0,0,873,870,1,0,0,0,873,872,1,0,0,0,874,133,1,0,0,0,
  	875,876,5,138,0,0,876,877,5,55,0,0,877,878,5,74,0,0,878,882,3,110,55,
  	0,879,881,3,132,66,0,880,879,1,0,0,0,881,884,1,0,0,0,882,880,1,0,0,0,
  	882,883,1,0,0,0,883,135,1,0,0,0,884,882,1,0,0,0,885,886,5,26,0,0,886,
  	887,5,74,0,0,887,888,3,110,55,0,888,137,1,0,0,0,889,890,5,71,0,0,890,
  	891,5,74,0,0,891,894,3,110,55,0,892,893,5,8,0,0,893,895,3,318,159,0,894,
  	892,1,0,0,0,894,895,1,0,0,0,895,898,1,0,0,0,896,897,5,77,0,0,897,899,
  	3,318,159,0,898,896,1,0,0,0,898,899,1,0,0,0,899,139,1,0,0,0,900,901,5,
  	71,0,0,901,902,5,123,0,0,902,903,5,75,0,0,903,141,1,0,0,0,904,905,5,73,
  	0,0,905,906,5,74,0,0,906,907,3,110,55,0,907,143,1,0,0,0,908,909,5,73,
  	0,0,909,910,5,123,0,0,910,911,5,75,0,0,911,145,1,0,0,0,912,913,5,179,
  	0,0,913,914,5,75,0,0,914,147,1,0,0,0,915,916,5,12,0,0,916,917,5,74,0,
  	0,917,920,3,110,55,0,918,919,5,8,0,0,919,921,3,318,159,0,920,918,1,0,
  	0,0,920,921,1,0,0,0,921,924,1,0,0,0,922,923,5,77,0,0,923,925,3,318,159,
  	0,924,922,1,0,0,0,924,925,1,0,0,0,925,149,1,0,0,0,926,927,3,318,159,0,
  	927,151,1,0,0,0,928,929,3,318,159,0,929,153,1,0,0,0,930,931,5,178,0,0,
  	931,932,5,23,0,0,932,933,5,68,0,0,933,934,3,150,75,0,934,935,5,78,0,0,
  	935,936,3,152,76,0,936,155,1,0,0,0,937,938,5,179,0,0,938,939,5,23,0,0,
  	939,940,5,68,0,0,940,941,3,150,75,0,941,157,1,0,0,0,942,943,5,179,0,0,
  	943,944,5,23,0,0,944,945,5,69,0,0,945,159,1,0,0,0,946,947,5,179,0,0,947,
  	948,5,89,0,0,948,161,1,0,0,0,949,951,3,164,82,0,950,952,5,102,0,0,951,
  	950,1,0,0,0,951,952,1,0,0,0,952,953,1,0,0,0,953,954,5,0,0,1,954,163,1,
  	0,0,0,955,956,3,4,2,0,956,165,1,0,0,0,957,958,7,8,0,0,958,959,5,135,0,
  	0,959,960,5,168,0,0,960,961,3,168,84,0,961,167,1,0,0,0,962,963,5,92,0,
  	0,963,964,3,352,176,0,964,965,5,101,0,0,965,966,3,280,140,0,966,967,5,
  	93,0,0,967,968,5,129,0,0,968,969,5,148,0,0,969,970,5,92,0,0,970,971,3,
  	170,85,0,971,972,5,93,0,0,972,997,1,0,0,0,973,974,5,92,0,0,974,975,3,
  	352,176,0,975,976,5,101,0,0,976,977,3,280,140,0,977,978,5,93,0,0,978,
  	979,5,129,0,0,979,980,3,170,85,0,980,981,5,156,0,0,981,982,5,186,0,0,
  	982,997,1,0,0,0,983,984,5,92,0,0,984,985,3,352,176,0,985,986,5,101,0,
  	0,986,987,3,280,140,0,987,988,5,93,0,0,988,989,5,129,0,0,989,990,5,92,
  	0,0,990,991,3,170,85,0,991,992,5,93,0,0,992,993,5,156,0,0,993,994,5,165,
  	0,0,994,995,5,158,0,0,995,997,1,0,0,0,996,962,1,0,0,0,996,973,1,0,0,0,
  	996,983,1,0,0,0,997,169,1,0,0,0,998,999,3,352,176,0,999,1006,3,346,173,
  	0,1000,1001,5,98,0,0,1001,1002,3,352,176,0,1002,1003,3,346,173,0,1003,
  	1005,1,0,0,0,1004,1000,1,0,0,0,1005,1008,1,0,0,0,1006,1004,1,0,0,0,1006,
  	1007,1,0,0,0,1007,171,1,0,0,0,1008,1006,1,0,0,0,1009,1010,5,182,0,0,1010,
  	1011,5,155,0,0,1011,173,1,0,0,0,1012,1013,5,154,0,0,1013,1014,5,155,0,
  	0,1014,175,1,0,0,0,1015,1016,5,135,0,0,1016,1017,5,155,0,0,1017,177,1,
  	0,0,0,1018,1022,5,179,0,0,1019,1023,3,172,86,0,1020,1023,3,174,87,0,1021,
  	1023,3,176,88,0,1022,1019,1,0,0,0,1022,1020,1,0,0,0,1022,1021,1,0,0,0,
  	1023,179,1,0,0,0,1024,1025,5,149,0,0,1025,1026,3,184,92,0,1026,181,1,
  	0,0,0,1027,1028,5,173,0,0,1028,1029,3,184,92,0,1029,183,1,0,0,0,1030,
  	1034,3,188,94,0,1031,1033,3,190,95,0,1032,1031,1,0,0,0,1033,1036,1,0,
  	0,0,1034,1032,1,0,0,0,1034,1035,1,0,0,0,1035,1038,1,0,0,0,1036,1034,1,
  	0,0,0,1037,1039,3,224,112,0,1038,1037,1,0,0,0,1038,1039,1,0,0,0,1039,
  	185,1,0,0,0,1040,1043,3,366,183,0,1041,1043,3,368,184,0,1042,1040,1,0,
  	0,0,1042,1041,1,0,0,0,1043,187,1,0,0,0,1044,1048,3,12,6,0,1045,1047,3,
  	12,6,0,1046,1045,1,0,0,0,1047,1050,1,0,0,0,1048,1046,1,0,0,0,1048,1049,
  	1,0,0,0,1049,189,1,0,0,0,1050,1048,1,0,0,0,1051,1052,5,185,0,0,1052,1053,
  	5,123,0,0,1053,1057,3,188,94,0,1054,1055,5,185,0,0,1055,1057,3,188,94,
  	0,1056,1051,1,0,0,0,1056,1054,1,0,0,0,1057,191,1,0,0,0,1058,1060,5,169,
  	0,0,1059,1058,1,0,0,0,1059,1060,1,0,0,0,1060,1061,1,0,0,0,1061,1062,5,
  	161,0,0,1062,1064,3,246,123,0,1063,1065,3,244,122,0,1064,1063,1,0,0,0,
  	1064,1065,1,0,0,0,1065,193,1,0,0,0,1066,1067,5,188,0,0,1067,1068,3,284,
  	142,0,1068,1069,5,126,0,0,1069,1070,3,352,176,0,1070,195,1,0,0,0,1071,
  	1072,5,164,0,0,1072,1076,3,248,124,0,1073,1075,3,198,99,0,1074,1073,1,
  	0,0,0,1075,1078,1,0,0,0,1076,1074,1,0,0,0,1076,1077,1,0,0,0,1077,197,
  	1,0,0,0,1078,1076,1,0,0,0,1079,1080,5,168,0,0,1080,1081,5,161,0,0,1081,
  	1086,3,202,101,0,1082,1083,5,168,0,0,1083,1084,5,138,0,0,1084,1086,3,
  	202,101,0,1085,1079,1,0,0,0,1085,1082,1,0,0,0,1086,199,1,0,0,0,1087,1088,
  	5,138,0,0,1088,1089,3,246,123,0,1089,201,1,0,0,0,1090,1091,5,178,0,0,
  	1091,1096,3,204,102,0,1092,1093,5,98,0,0,1093,1095,3,204,102,0,1094,1092,
  	1,0,0,0,1095,1098,1,0,0,0,1096,1094,1,0,0,0,1096,1097,1,0,0,0,1097,203,
  	1,0,0,0,1098,1096,1,0,0,0,1099,1100,3,360,180,0,1100,1101,5,105,0,0,1101,
  	1102,3,284,142,0,1102,1115,1,0,0,0,1103,1104,3,352,176,0,1104,1105,5,
  	105,0,0,1105,1106,3,284,142,0,1106,1115,1,0,0,0,1107,1108,3,352,176,0,
  	1108,1109,5,119,0,0,1109,1110,3,284,142,0,1110,1115,1,0,0,0,1111,1112,
  	3,352,176,0,1112,1113,3,276,138,0,1113,1115,1,0,0,0,1114,1099,1,0,0,0,
  	1114,1103,1,0,0,0,1114,1107,1,0,0,0,1114,1111,1,0,0,0,1115,205,1,0,0,
  	0,1116,1118,5,143,0,0,1117,1116,1,0,0,0,1117,1118,1,0,0,0,1118,1119,1,
  	0,0,0,1119,1120,5,140,0,0,1120,1125,3,284,142,0,1121,1122,5,98,0,0,1122,
  	1124,3,284,142,0,1123,1121,1,0,0,0,1124,1127,1,0,0,0,1125,1123,1,0,0,
  	0,1125,1126,1,0,0,0,1126,207,1,0,0,0,1127,1125,1,0,0,0,1128,1129,5,176,
  	0,0,1129,1134,3,210,105,0,1130,1131,5,98,0,0,1131,1133,3,210,105,0,1132,
  	1130,1,0,0,0,1133,1136,1,0,0,0,1134,1132,1,0,0,0,1134,1135,1,0,0,0,1135,
  	209,1,0,0,0,1136,1134,1,0,0,0,1137,1138,3,352,176,0,1138,1139,3,276,138,
  	0,1139,1142,1,0,0,0,1140,1142,3,360,180,0,1141,1137,1,0,0,0,1141,1140,
  	1,0,0,0,1142,211,1,0,0,0,1143,1145,5,191,0,0,1144,1146,5,144,0,0,1145,
  	1144,1,0,0,0,1145,1146,1,0,0,0,1146,1147,1,0,0,0,1147,1149,3,230,115,
  	0,1148,1150,3,244,122,0,1149,1148,1,0,0,0,1149,1150,1,0,0,0,1150,213,
  	1,0,0,0,1151,1153,5,177,0,0,1152,1154,5,144,0,0,1153,1152,1,0,0,0,1153,
  	1154,1,0,0,0,1154,1155,1,0,0,0,1155,1156,3,230,115,0,1156,215,1,0,0,0,
  	1157,1158,5,132,0,0,1158,1159,3,218,109,0,1159,1168,5,92,0,0,1160,1165,
  	3,284,142,0,1161,1162,5,98,0,0,1162,1164,3,284,142,0,1163,1161,1,0,0,
  	0,1164,1167,1,0,0,0,1165,1163,1,0,0,0,1165,1166,1,0,0,0,1166,1169,1,0,
  	0,0,1167,1165,1,0,0,0,1168,1160,1,0,0,0,1168,1169,1,0,0,0,1169,1170,1,
  	0,0,0,1170,1172,5,93,0,0,1171,1173,3,226,113,0,1172,1171,1,0,0,0,1172,
  	1173,1,0,0,0,1173,1175,1,0,0,0,1174,1176,3,220,110,0,1175,1174,1,0,0,
  	0,1175,1176,1,0,0,0,1176,217,1,0,0,0,1177,1182,3,2,1,0,1178,1179,5,99,
  	0,0,1179,1181,3,2,1,0,1180,1178,1,0,0,0,1181,1184,1,0,0,0,1182,1180,1,
  	0,0,0,1182,1183,1,0,0,0,1183,219,1,0,0,0,1184,1182,1,0,0,0,1185,1195,
  	5,194,0,0,1186,1196,5,115,0,0,1187,1192,3,228,114,0,1188,1189,5,98,0,
  	0,1189,1191,3,228,114,0,1190,1188,1,0,0,0,1191,1194,1,0,0,0,1192,1190,
  	1,0,0,0,1192,1193,1,0,0,0,1193,1196,1,0,0,0,1194,1192,1,0,0,0,1195,1186,
  	1,0,0,0,1195,1187,1,0,0,0,1196,221,1,0,0,0,1197,1203,5,163,0,0,1198,1204,
  	5,187,0,0,1199,1200,5,159,0,0,1200,1201,3,318,159,0,1201,1202,7,9,0,0,
  	1202,1204,1,0,0,0,1203,1198,1,0,0,0,1203,1199,1,0,0,0,1204,223,1,0,0,
  	0,1205,1206,5,174,0,0,1206,1207,3,222,111,0,1207,225,1,0,0,0,1208,1209,
  	5,172,0,0,1209,1210,3,222,111,0,1210,227,1,0,0,0,1211,1212,3,352,176,
  	0,1212,1213,5,126,0,0,1213,1214,3,352,176,0,1214,1217,1,0,0,0,1215,1217,
  	3,352,176,0,1216,1211,1,0,0,0,1216,1215,1,0,0,0,1217,229,1,0,0,0,1218,
  	1220,3,232,116,0,1219,1221,3,236,118,0,1220,1219,1,0,0,0,1220,1221,1,
  	0,0,0,1221,1223,1,0,0,0,1222,1224,3,238,119,0,1223,1222,1,0,0,0,1223,
  	1224,1,0,0,0,1224,1226,1,0,0,0,1225,1227,3,240,120,0,1226,1225,1,0,0,
  	0,1226,1227,1,0,0,0,1227,231,1,0,0,0,1228,1233,5,115,0,0,1229,1230,5,
  	98,0,0,1230,1232,3,234,117,0,1231,1229,1,0,0,0,1232,1235,1,0,0,0,1233,
  	1231,1,0,0,0,1233,1234,1,0,0,0,1234,1245,1,0,0,0,1235,1233,1,0,0,0,1236,
  	1241,3,234,117,0,1237,1238,5,98,0,0,1238,1240,3,234,117,0,1239,1237,1,
  	0,0,0,1240,1243,1,0,0,0,1241,1239,1,0,0,0,1241,1242,1,0,0,0,1242,1245,
  	1,0,0,0,1243,1241,1,0,0,0,1244,1228,1,0,0,0,1244,1236,1,0,0,0,1245,233,
  	1,0,0,0,1246,1247,3,284,142,0,1247,1248,5,126,0,0,1248,1249,3,352,176,
  	0,1249,1252,1,0,0,0,1250,1252,3,284,142,0,1251,1246,1,0,0,0,1251,1250,
  	1,0,0,0,1252,235,1,0,0,0,1253,1254,5,171,0,0,1254,1255,5,131,0,0,1255,
  	1260,3,242,121,0,1256,1257,5,98,0,0,1257,1259,3,242,121,0,1258,1256,1,
  	0,0,0,1259,1262,1,0,0,0,1260,1258,1,0,0,0,1260,1261,1,0,0,0,1261,237,
  	1,0,0,0,1262,1260,1,0,0,0,1263,1264,5,160,0,0,1264,1265,3,284,142,0,1265,
  	239,1,0,0,0,1266,1267,5,159,0,0,1267,1268,3,284,142,0,1268,241,1,0,0,
  	0,1269,1271,3,284,142,0,1270,1272,7,10,0,0,1271,1270,1,0,0,0,1271,1272,
  	1,0,0,0,1272,243,1,0,0,0,1273,1274,5,190,0,0,1274,1275,3,284,142,0,1275,
  	245,1,0,0,0,1276,1281,3,248,124,0,1277,1278,5,98,0,0,1278,1280,3,248,
  	124,0,1279,1277,1,0,0,0,1280,1283,1,0,0,0,1281,1279,1,0,0,0,1281,1282,
  	1,0,0,0,1282,247,1,0,0,0,1283,1281,1,0,0,0,1284,1285,3,352,176,0,1285,
  	1286,5,105,0,0,1286,1287,3,250,125,0,1287,1290,1,0,0,0,1288,1290,3,250,
  	125,0,1289,1284,1,0,0,0,1289,1288,1,0,0,0,1290,249,1,0,0,0,1291,1292,
  	3,252,126,0,1292,251,1,0,0,0,1293,1297,3,254,127,0,1294,1296,3,256,128,
  	0,1295,1294,1,0,0,0,1296,1299,1,0,0,0,1297,1295,1,0,0,0,1297,1298,1,0,
  	0,0,1298,1305,1,0,0,0,1299,1297,1,0,0,0,1300,1301,5,92,0,0,1301,1302,
  	3,252,126,0,1302,1303,5,93,0,0,1303,1305,1,0,0,0,1304,1293,1,0,0,0,1304,
  	1300,1,0,0,0,1305,253,1,0,0,0,1306,1308,5,92,0,0,1307,1309,3,352,176,
  	0,1308,1307,1,0,0,0,1308,1309,1,0,0,0,1309,1311,1,0,0,0,1310,1312,3,276,
  	138,0,1311,1310,1,0,0,0,1311,1312,1,0,0,0,1312,1314,1,0,0,0,1313,1315,
  	3,272,136,0,1314,1313,1,0,0,0,1314,1315,1,0,0,0,1315,1316,1,0,0,0,1316,
  	1317,5,93,0,0,1317,255,1,0,0,0,1318,1319,3,258,129,0,1319,1320,3,254,
  	127,0,1320,257,1,0,0,0,1321,1322,3,260,130,0,1322,1324,3,264,132,0,1323,
  	1325,3,266,133,0,1324,1323,1,0,0,0,1324,1325,1,0,0,0,1325,1326,1,0,0,
  	0,1326,1327,3,264,132,0,1327,1328,3,262,131,0,1328,1350,1,0,0,0,1329,
  	1330,3,260,130,0,1330,1332,3,264,132,0,1331,1333,3,266,133,0,1332,1331,
  	1,0,0,0,1332,1333,1,0,0,0,1333,1334,1,0,0,0,1334,1335,3,264,132,0,1335,
  	1350,1,0,0,0,1336,1338,3,264,132,0,1337,1339,3,266,133,0,1338,1337,1,
  	0,0,0,1338,1339,1,0,0,0,1339,1340,1,0,0,0,1340,1341,3,264,132,0,1341,
  	1342,3,262,131,0,1342,1350,1,0,0,0,1343,1345,3,264,132,0,1344,1346,3,
  	266,133,0,1345,1344,1,0,0,0,1345,1346,1,0,0,0,1346,1347,1,0,0,0,1347,
  	1348,3,264,132,0,1348,1350,1,0,0,0,1349,1321,1,0,0,0,1349,1329,1,0,0,
  	0,1349,1336,1,0,0,0,1349,1343,1,0,0,0,1350,259,1,0,0,0,1351,1352,7,11,
  	0,0,1352,261,1,0,0,0,1353,1354,7,12,0,0,1354,263,1,0,0,0,1355,1356,7,
  	13,0,0,1356,265,1,0,0,0,1357,1359,5,94,0,0,1358,1360,3,352,176,0,1359,
  	1358,1,0,0,0,1359,1360,1,0,0,0,1360,1362,1,0,0,0,1361,1363,3,274,137,
  	0,1362,1361,1,0,0,0,1362,1363,1,0,0,0,1363,1365,1,0,0,0,1364,1366,3,270,
  	135,0,1365,1364,1,0,0,0,1365,1366,1,0,0,0,1366,1367,1,0,0,0,1367,1368,
  	3,272,136,0,1368,1369,5,95,0,0,1369,1415,1,0,0,0,1370,1372,5,94,0,0,1371,
  	1373,3,352,176,0,1372,1371,1,0,0,0,1372,1373,1,0,0,0,1373,1375,1,0,0,
  	0,1374,1376,3,274,137,0,1375,1374,1,0,0,0,1375,1376,1,0,0,0,1376,1378,
  	1,0,0,0,1377,1379,3,270,135,0,1378,1377,1,0,0,0,1378,1379,1,0,0,0,1379,
  	1380,1,0,0,0,1380,1382,3,268,134,0,1381,1383,3,352,176,0,1382,1381,1,
  	0,0,0,1382,1383,1,0,0,0,1383,1385,1,0,0,0,1384,1386,3,268,134,0,1385,
  	1384,1,0,0,0,1385,1386,1,0,0,0,1386,1387,1,0,0,0,1387,1388,5,95,0,0,1388,
  	1415,1,0,0,0,1389,1391,5,94,0,0,1390,1392,3,352,176,0,1391,1390,1,0,0,
  	0,1391,1392,1,0,0,0,1392,1394,1,0,0,0,1393,1395,3,274,137,0,1394,1393,
  	1,0,0,0,1394,1395,1,0,0,0,1395,1397,1,0,0,0,1396,1398,3,270,135,0,1397,
  	1396,1,0,0,0,1397,1398,1,0,0,0,1398,1402,1,0,0,0,1399,1401,3,272,136,
  	0,1400,1399,1,0,0,0,1401,1404,1,0,0,0,1402,1400,1,0,0,0,1402,1403,1,0,
  	0,0,1403,1408,1,0,0,0,1404,1402,1,0,0,0,1405,1406,3,268,134,0,1406,1407,
  	3,352,176,0,1407,1409,1,0,0,0,1408,1405,1,0,0,0,1408,1409,1,0,0,0,1409,
  	1411,1,0,0,0,1410,1412,3,268,134,0,1411,1410,1,0,0,0,1411,1412,1,0,0,
  	0,1412,1413,1,0,0,0,1413,1415,5,95,0,0,1414,1357,1,0,0,0,1414,1370,1,
  	0,0,0,1414,1389,1,0,0,0,1415,267,1,0,0,0,1416,1417,5,92,0,0,1417,1418,
  	3,352,176,0,1418,1419,5,98,0,0,1419,1420,3,352,176,0,1420,1421,5,104,
  	0,0,1421,1422,3,284,142,0,1422,1423,5,93,0,0,1423,269,1,0,0,0,1424,1426,
  	5,115,0,0,1425,1427,7,14,0,0,1426,1425,1,0,0,0,1426,1427,1,0,0,0,1427,
  	1429,1,0,0,0,1428,1430,3,284,142,0,1429,1428,1,0,0,0,1429,1430,1,0,0,
  	0,1430,1435,1,0,0,0,1431,1433,5,100,0,0,1432,1434,3,284,142,0,1433,1432,
  	1,0,0,0,1433,1434,1,0,0,0,1434,1436,1,0,0,0,1435,1431,1,0,0,0,1435,1436,
  	1,0,0,0,1436,271,1,0,0,0,1437,1440,3,356,178,0,1438,1440,3,358,179,0,
  	1439,1437,1,0,0,0,1439,1438,1,0,0,0,1440,273,1,0,0,0,1441,1442,5,101,
  	0,0,1442,1450,3,282,141,0,1443,1445,5,104,0,0,1444,1446,5,101,0,0,1445,
  	1444,1,0,0,0,1445,1446,1,0,0,0,1446,1447,1,0,0,0,1447,1449,3,282,141,
  	0,1448,1443,1,0,0,0,1449,1452,1,0,0,0,1450,1448,1,0,0,0,1450,1451,1,0,
  	0,0,1451,275,1,0,0,0,1452,1450,1,0,0,0,1453,1457,3,278,139,0,1454,1456,
  	3,278,139,0,1455,1454,1,0,0,0,1456,1459,1,0,0,0,1457,1455,1,0,0,0,1457,
  	1458,1,0,0,0,1458,277,1,0,0,0,1459,1457,1,0,0,0,1460,1461,5,101,0,0,1461,
  	1462,3,280,140,0,1462,279,1,0,0,0,1463,1464,3,2,1,0,1464,281,1,0,0,0,
  	1465,1466,3,2,1,0,1466,283,1,0,0,0,1467,1468,3,286,143,0,1468,285,1,0,
  	0,0,1469,1474,3,288,144,0,1470,1471,5,170,0,0,1471,1473,3,288,144,0,1472,
  	1470,1,0,0,0,1473,1476,1,0,0,0,1474,1472,1,0,0,0,1474,1475,1,0,0,0,1475,
  	287,1,0,0,0,1476,1474,1,0,0,0,1477,1482,3,290,145,0,1478,1479,5,193,0,
  	0,1479,1481,3,290,145,0,1480,1478,1,0,0,0,1481,1484,1,0,0,0,1482,1480,
  	1,0,0,0,1482,1483,1,0,0,0,1483,289,1,0,0,0,1484,1482,1,0,0,0,1485,1490,
  	3,292,146,0,1486,1487,5,124,0,0,1487,1489,3,292,146,0,1488,1486,1,0,0,
  	0,1489,1492,1,0,0,0,1490,1488,1,0,0,0,1490,1491,1,0,0,0,1491,291,1,0,
  	0,0,1492,1490,1,0,0,0,1493,1495,5,167,0,0,1494,1493,1,0,0,0,1495,1498,
  	1,0,0,0,1496,1494,1,0,0,0,1496,1497,1,0,0,0,1497,1499,1,0,0,0,1498,1496,
  	1,0,0,0,1499,1500,3,294,147,0,1500,293,1,0,0,0,1501,1505,3,296,148,0,
  	1502,1504,3,324,162,0,1503,1502,1,0,0,0,1504,1507,1,0,0,0,1505,1503,1,
  	0,0,0,1505,1506,1,0,0,0,1506,295,1,0,0,0,1507,1505,1,0,0,0,1508,1515,
  	3,298,149,0,1509,1510,5,113,0,0,1510,1514,3,298,149,0,1511,1512,5,114,
  	0,0,1512,1514,3,298,149,0,1513,1509,1,0,0,0,1513,1511,1,0,0,0,1514,1517,
  	1,0,0,0,1515,1513,1,0,0,0,1515,1516,1,0,0,0,1516,297,1,0,0,0,1517,1515,
  	1,0,0,0,1518,1527,3,300,150,0,1519,1520,5,115,0,0,1520,1526,3,300,150,
  	0,1521,1522,5,116,0,0,1522,1526,3,300,150,0,1523,1524,5,117,0,0,1524,
  	1526,3,300,150,0,1525,1519,1,0,0,0,1525,1521,1,0,0,0,1525,1523,1,0,0,
  	0,1526,1529,1,0,0,0,1527,1525,1,0,0,0,1527,1528,1,0,0,0,1528,299,1,0,
  	0,0,1529,1527,1,0,0,0,1530,1535,3,302,151,0,1531,1532,5,118,0,0,1532,
  	1534,3,302,151,0,1533,1531,1,0,0,0,1534,1537,1,0,0,0,1535,1533,1,0,0,
  	0,1535,1536,1,0,0,0,1536,301,1,0,0,0,1537,1535,1,0,0,0,1538,1540,7,15,
  	0,0,1539,1538,1,0,0,0,1540,1543,1,0,0,0,1541,1539,1,0,0,0,1541,1542,1,
  	0,0,0,1542,1544,1,0,0,0,1543,1541,1,0,0,0,1544,1545,3,304,152,0,1545,
  	303,1,0,0,0,1546,1550,3,308,154,0,1547,1549,3,306,153,0,1548,1547,1,0,
  	0,0,1549,1552,1,0,0,0,1550,1548,1,0,0,0,1550,1551,1,0,0,0,1551,305,1,
  	0,0,0,1552,1550,1,0,0,0,1553,1561,5,112,0,0,1554,1561,5,153,0,0,1555,
  	1556,5,181,0,0,1556,1561,5,191,0,0,1557,1558,5,147,0,0,1558,1561,5,191,
  	0,0,1559,1561,5,136,0,0,1560,1553,1,0,0,0,1560,1554,1,0,0,0,1560,1555,
  	1,0,0,0,1560,1557,1,0,0,0,1560,1559,1,0,0,0,1561,1562,1,0,0,0,1562,1569,
  	3,308,154,0,1563,1564,5,156,0,0,1564,1569,5,139,0,0,1565,1566,5,156,0,
  	0,1566,1567,5,167,0,0,1567,1569,5,139,0,0,1568,1560,1,0,0,0,1568,1563,
  	1,0,0,0,1568,1565,1,0,0,0,1569,307,1,0,0,0,1570,1574,3,312,156,0,1571,
  	1573,3,310,155,0,1572,1571,1,0,0,0,1573,1576,1,0,0,0,1574,1572,1,0,0,
  	0,1574,1575,1,0,0,0,1575,309,1,0,0,0,1576,1574,1,0,0,0,1577,1578,5,94,
  	0,0,1578,1579,3,284,142,0,1579,1580,5,95,0,0,1580,1591,1,0,0,0,1581,1583,
  	5,94,0,0,1582,1584,3,284,142,0,1583,1582,1,0,0,0,1583,1584,1,0,0,0,1584,
  	1585,1,0,0,0,1585,1587,5,100,0,0,1586,1588,3,284,142,0,1587,1586,1,0,
  	0,0,1587,1588,1,0,0,0,1588,1589,1,0,0,0,1589,1591,5,95,0,0,1590,1577,
  	1,0,0,0,1590,1581,1,0,0,0,1591,311,1,0,0,0,1592,1594,3,314,157,0,1593,
  	1595,3,276,138,0,1594,1593,1,0,0,0,1594,1595,1,0,0,0,1595,313,1,0,0,0,
  	1596,1600,3,316,158,0,1597,1599,3,346,173,0,1598,1597,1,0,0,0,1599,1602,
  	1,0,0,0,1600,1598,1,0,0,0,1600,1601,1,0,0,0,1601,315,1,0,0,0,1602,1600,
  	1,0,0,0,1603,1664,3,318,159,0,1604,1664,3,358,179,0,1605,1664,3,348,174,
  	0,1606,1607,5,137,0,0,1607,1608,5,92,0,0,1608,1609,5,115,0,0,1609,1664,
  	5,93,0,0,1610,1664,3,342,171,0,1611,1664,3,344,172,0,1612,1613,5,152,
  	0,0,1613,1614,5,92,0,0,1614,1615,3,330,165,0,1615,1616,5,93,0,0,1616,
  	1664,1,0,0,0,1617,1618,5,150,0,0,1618,1619,5,92,0,0,1619,1620,3,334,167,
  	0,1620,1621,5,93,0,0,1621,1664,1,0,0,0,1622,1623,5,175,0,0,1623,1624,
  	5,92,0,0,1624,1625,3,332,166,0,1625,1626,5,93,0,0,1626,1664,1,0,0,0,1627,
  	1628,5,134,0,0,1628,1629,5,92,0,0,1629,1634,3,284,142,0,1630,1631,5,98,
  	0,0,1631,1633,3,284,142,0,1632,1630,1,0,0,0,1633,1636,1,0,0,0,1634,1632,
  	1,0,0,0,1634,1635,1,0,0,0,1635,1637,1,0,0,0,1636,1634,1,0,0,0,1637,1638,
  	5,93,0,0,1638,1664,1,0,0,0,1639,1640,5,123,0,0,1640,1641,5,92,0,0,1641,
  	1642,3,330,165,0,1642,1643,5,93,0,0,1643,1664,1,0,0,0,1644,1645,5,125,
  	0,0,1645,1646,5,92,0,0,1646,1647,3,330,165,0,1647,1648,5,93,0,0,1648,
  	1664,1,0,0,0,1649,1650,5,166,0,0,1650,1651,5,92,0,0,1651,1652,3,330,165,
  	0,1652,1653,5,93,0,0,1653,1664,1,0,0,0,1654,1655,5,180,0,0,1655,1656,
  	5,92,0,0,1656,1657,3,330,165,0,1657,1658,5,93,0,0,1658,1664,1,0,0,0,1659,
  	1664,3,328,164,0,1660,1664,3,326,163,0,1661,1664,3,338,169,0,1662,1664,
  	3,352,176,0,1663,1603,1,0,0,0,1663,1604,1,0,0,0,1663,1605,1,0,0,0,1663,
  	1606,1,0,0,0,1663,1610,1,0,0,0,1663,1611,1,0,0,0,1663,1612,1,0,0,0,1663,
  	1617,1,0,0,0,1663,1622,1,0,0,0,1663,1627,1,0,0,0,1663,1639,1,0,0,0,1663,
  	1644,1,0,0,0,1663,1649,1,0,0,0,1663,1654,1,0,0,0,1663,1659,1,0,0,0,1663,
  	1660,1,0,0,0,1663,1661,1,0,0,0,1663,1662,1,0,0,0,1664,317,1,0,0,0,1665,
  	1672,3,354,177,0,1666,1672,5,195,0,0,1667,1672,3,320,160,0,1668,1672,
  	5,139,0,0,1669,1672,3,356,178,0,1670,1672,3,322,161,0,1671,1665,1,0,0,
  	0,1671,1666,1,0,0,0,1671,1667,1,0,0,0,1671,1668,1,0,0,0,1671,1669,1,0,
  	0,0,1671,1670,1,0,0,0,1672,319,1,0,0,0,1673,1674,7,16,0,0,1674,321,1,
  	0,0,0,1675,1684,5,94,0,0,1676,1681,3,284,142,0,1677,1678,5,98,0,0,1678,
  	1680,3,284,142,0,1679,1677,1,0,0,0,1680,1683,1,0,0,0,1681,1679,1,0,0,
  	0,1681,1682,1,0,0,0,1682,1685,1,0,0,0,1683,1681,1,0,0,0,1684,1676,1,0,
  	0,0,1684,1685,1,0,0,0,1685,1686,1,0,0,0,1686,1687,5,95,0,0,1687,323,1,
  	0,0,0,1688,1689,5,105,0,0,1689,1703,3,296,148,0,1690,1691,5,110,0,0,1691,
  	1703,3,296,148,0,1692,1693,5,111,0,0,1693,1703,3,296,148,0,1694,1695,
  	5,106,0,0,1695,1703,3,296,148,0,1696,1697,5,107,0,0,1697,1703,3,296,148,
  	0,1698,1699,5,108,0,0,1699,1703,3,296,148,0,1700,1701,5,109,0,0,1701,
  	1703,3,296,148,0,1702,1688,1,0,0,0,1702,1690,1,0,0,0,1702,1692,1,0,0,
  	0,1702,1694,1,0,0,0,1702,1696,1,0,0,0,1702,1698,1,0,0,0,1702,1700,1,0,
  	0,0,1703,325,1,0,0,0,1704,1705,5,92,0,0,1705,1706,3,284,142,0,1706,1707,
  	5,93,0,0,1707,327,1,0,0,0,1708,1710,3,254,127,0,1709,1711,3,256,128,0,
  	1710,1709,1,0,0,0,1711,1712,1,0,0,0,1712,1710,1,0,0,0,1712,1713,1,0,0,
  	0,1713,329,1,0,0,0,1714,1716,3,336,168,0,1715,1717,3,244,122,0,1716,1715,
  	1,0,0,0,1716,1717,1,0,0,0,1717,331,1,0,0,0,1718,1719,3,352,176,0,1719,
  	1720,5,105,0,0,1720,1721,3,284,142,0,1721,1722,5,98,0,0,1722,1723,3,336,
  	168,0,1723,1724,5,104,0,0,1724,1725,3,284,142,0,1725,333,1,0,0,0,1726,
  	1727,3,336,168,0,1727,1728,5,104,0,0,1728,1729,3,284,142,0,1729,335,1,
  	0,0,0,1730,1731,3,352,176,0,1731,1732,5,153,0,0,1732,1733,3,284,142,0,
  	1733,337,1,0,0,0,1734,1735,3,340,170,0,1735,1737,5,92,0,0,1736,1738,5,
  	144,0,0,1737,1736,1,0,0,0,1737,1738,1,0,0,0,1738,1747,1,0,0,0,1739,1744,
  	3,284,142,0,1740,1741,5,98,0,0,1741,1743,3,284,142,0,1742,1740,1,0,0,
  	0,1743,1746,1,0,0,0,1744,1742,1,0,0,0,1744,1745,1,0,0,0,1745,1748,1,0,
  	0,0,1746,1744,1,0,0,0,1747,1739,1,0,0,0,1747,1748,1,0,0,0,1748,1749,1,
  	0,0,0,1749,1750,5,93,0,0,1750,339,1,0,0,0,1751,1756,3,2,1,0,1752,1753,
  	5,99,0,0,1753,1755,3,2,1,0,1754,1752,1,0,0,0,1755,1758,1,0,0,0,1756,1754,
  	1,0,0,0,1756,1757,1,0,0,0,1757,341,1,0,0,0,1758,1756,1,0,0,0,1759,1760,
  	5,94,0,0,1760,1763,3,330,165,0,1761,1762,5,104,0,0,1762,1764,3,284,142,
  	0,1763,1761,1,0,0,0,1763,1764,1,0,0,0,1764,1765,1,0,0,0,1765,1766,5,95,
  	0,0,1766,343,1,0,0,0,1767,1771,5,94,0,0,1768,1769,3,352,176,0,1769,1770,
  	5,105,0,0,1770,1772,1,0,0,0,1771,1768,1,0,0,0,1771,1772,1,0,0,0,1772,
  	1773,1,0,0,0,1773,1776,3,328,164,0,1774,1775,5,190,0,0,1775,1777,3,284,
  	142,0,1776,1774,1,0,0,0,1776,1777,1,0,0,0,1777,1778,1,0,0,0,1778,1779,
  	5,104,0,0,1779,1780,3,284,142,0,1780,1781,5,95,0,0,1781,345,1,0,0,0,1782,
  	1783,5,99,0,0,1783,1784,3,362,181,0,1784,347,1,0,0,0,1785,1787,5,133,
  	0,0,1786,1788,3,350,175,0,1787,1786,1,0,0,0,1788,1789,1,0,0,0,1789,1787,
  	1,0,0,0,1789,1790,1,0,0,0,1790,1799,1,0,0,0,1791,1792,5,133,0,0,1792,
  	1794,3,284,142,0,1793,1795,3,350,175,0,1794,1793,1,0,0,0,1795,1796,1,
  	0,0,0,1796,1794,1,0,0,0,1796,1797,1,0,0,0,1797,1799,1,0,0,0,1798,1785,
  	1,0,0,0,1798,1791,1,0,0,0,1799,1802,1,0,0,0,1800,1801,5,145,0,0,1801,
  	1803,3,284,142,0,1802,1800,1,0,0,0,1802,1803,1,0,0,0,1803,1804,1,0,0,
  	0,1804,1805,5,146,0,0,1805,349,1,0,0,0,1806,1807,5,189,0,0,1807,1808,
  	3,284,142,0,1808,1809,5,183,0,0,1809,1810,3,284,142,0,1810,351,1,0,0,
  	0,1811,1812,3,2,1,0,1812,353,1,0,0,0,1813,1816,3,370,185,0,1814,1816,
  	3,364,182,0,1815,1813,1,0,0,0,1815,1814,1,0,0,0,1816,355,1,0,0,0,1817,
  	1831,5,96,0,0,1818,1819,3,362,181,0,1819,1820,5,101,0,0,1820,1828,3,284,
  	142,0,1821,1822,5,98,0,0,1822,1823,3,362,181,0,1823,1824,5,101,0,0,1824,
  	1825,3,284,142,0,1825,1827,1,0,0,0,1826,1821,1,0,0,0,1827,1830,1,0,0,
  	0,1828,1826,1,0,0,0,1828,1829,1,0,0,0,1829,1832,1,0,0,0,1830,1828,1,0,
  	0,0,1831,1818,1,0,0,0,1831,1832,1,0,0,0,1832,1833,1,0,0,0,1833,1834,5,
  	97,0,0,1834,357,1,0,0,0,1835,1838,5,103,0,0,1836,1839,3,2,1,0,1837,1839,
  	5,196,0,0,1838,1836,1,0,0,0,1838,1837,1,0,0,0,1839,359,1,0,0,0,1840,1842,
  	3,316,158,0,1841,1843,3,346,173,0,1842,1841,1,0,0,0,1843,1844,1,0,0,0,
  	1844,1842,1,0,0,0,1844,1845,1,0,0,0,1845,361,1,0,0,0,1846,1847,3,2,1,
  	0,1847,363,1,0,0,0,1848,1849,7,17,0,0,1849,365,1,0,0,0,1850,1851,5,138,
  	0,0,1851,1852,5,154,0,0,1852,1853,5,168,0,0,1853,1854,5,101,0,0,1854,
  	1859,3,280,140,0,1855,1856,5,92,0,0,1856,1857,3,362,181,0,1857,1858,5,
  	93,0,0,1858,1860,1,0,0,0,1859,1855,1,0,0,0,1859,1860,1,0,0,0,1860,367,
  	1,0,0,0,1861,1862,5,26,0,0,1862,1863,5,154,0,0,1863,1864,5,168,0,0,1864,
  	1865,5,101,0,0,1865,1870,3,280,140,0,1866,1867,5,92,0,0,1867,1868,3,362,
  	181,0,1868,1869,5,93,0,0,1869,1871,1,0,0,0,1870,1866,1,0,0,0,1870,1871,
  	1,0,0,0,1871,369,1,0,0,0,1872,1873,5,199,0,0,1873,371,1,0,0,0,1874,1875,
  	7,18,0,0,1875,373,1,0,0,0,161,453,458,477,494,501,506,520,528,539,551,
  	556,566,570,574,606,638,647,656,668,697,733,749,752,772,793,801,809,814,
  	822,826,838,841,856,865,873,882,894,898,920,924,951,996,1006,1022,1034,
  	1038,1042,1048,1056,1059,1064,1076,1085,1096,1114,1117,1125,1134,1141,
  	1145,1149,1153,1165,1168,1172,1175,1182,1192,1195,1203,1216,1220,1223,
  	1226,1233,1241,1244,1251,1260,1271,1281,1289,1297,1304,1308,1311,1314,
  	1324,1332,1338,1345,1349,1359,1362,1365,1372,1375,1378,1382,1385,1391,
  	1394,1397,1402,1408,1411,1414,1426,1429,1433,1435,1439,1445,1450,1457,
  	1474,1482,1490,1496,1505,1513,1515,1525,1527,1535,1541,1550,1560,1568,
  	1574,1583,1587,1590,1594,1600,1634,1663,1671,1681,1684,1702,1712,1716,
  	1737,1744,1747,1756,1763,1771,1776,1789,1796,1798,1802,1815,1828,1831,
  	1838,1844,1859,1870
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  memgraphcypherParserStaticData = staticData.release();
}

}

MemgraphCypher::MemgraphCypher(TokenStream *input) : MemgraphCypher(input, antlr4::atn::ParserATNSimulatorOptions()) {}

MemgraphCypher::MemgraphCypher(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  MemgraphCypher::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *memgraphcypherParserStaticData->atn, memgraphcypherParserStaticData->decisionToDFA, memgraphcypherParserStaticData->sharedContextCache, options);
}

MemgraphCypher::~MemgraphCypher() {
  delete _interpreter;
}

const atn::ATN& MemgraphCypher::getATN() const {
  return *memgraphcypherParserStaticData->atn;
}

std::string MemgraphCypher::getGrammarFileName() const {
  return "MemgraphCypher.g4";
}

const std::vector<std::string>& MemgraphCypher::getRuleNames() const {
  return memgraphcypherParserStaticData->ruleNames;
}

const dfa::Vocabulary& MemgraphCypher::getVocabulary() const {
  return memgraphcypherParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView MemgraphCypher::getSerializedATN() const {
  return memgraphcypherParserStaticData->serializedATN;
}


//----------------- MemgraphCypherKeywordContext ------------------------------------------------------------------

MemgraphCypher::MemgraphCypherKeywordContext::MemgraphCypherKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::CypherKeywordContext* MemgraphCypher::MemgraphCypherKeywordContext::cypherKeyword() {
  return getRuleContext<MemgraphCypher::CypherKeywordContext>(0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::AFTER() {
  return getToken(MemgraphCypher::AFTER, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::ALTER() {
  return getToken(MemgraphCypher::ALTER, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::ASYNC() {
  return getToken(MemgraphCypher::ASYNC, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::AUTH() {
  return getToken(MemgraphCypher::AUTH, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::BAD() {
  return getToken(MemgraphCypher::BAD, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::BATCH_INTERVAL() {
  return getToken(MemgraphCypher::BATCH_INTERVAL, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::BATCH_LIMIT() {
  return getToken(MemgraphCypher::BATCH_LIMIT, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::BATCH_SIZE() {
  return getToken(MemgraphCypher::BATCH_SIZE, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::BEFORE() {
  return getToken(MemgraphCypher::BEFORE, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::BOOTSTRAP_SERVERS() {
  return getToken(MemgraphCypher::BOOTSTRAP_SERVERS, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::CHECK() {
  return getToken(MemgraphCypher::CHECK, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::CLEAR() {
  return getToken(MemgraphCypher::CLEAR, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::COMMIT() {
  return getToken(MemgraphCypher::COMMIT, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::COMMITTED() {
  return getToken(MemgraphCypher::COMMITTED, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::CONFIG() {
  return getToken(MemgraphCypher::CONFIG, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::CONFIGS() {
  return getToken(MemgraphCypher::CONFIGS, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::CONSUMER_GROUP() {
  return getToken(MemgraphCypher::CONSUMER_GROUP, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::CREDENTIALS() {
  return getToken(MemgraphCypher::CREDENTIALS, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::CSV() {
  return getToken(MemgraphCypher::CSV, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::DATA() {
  return getToken(MemgraphCypher::DATA, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::DELIMITER() {
  return getToken(MemgraphCypher::DELIMITER, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::DATABASE() {
  return getToken(MemgraphCypher::DATABASE, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::DENY() {
  return getToken(MemgraphCypher::DENY, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::DROP() {
  return getToken(MemgraphCypher::DROP, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::DUMP() {
  return getToken(MemgraphCypher::DUMP, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::EXECUTE() {
  return getToken(MemgraphCypher::EXECUTE, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::FOR() {
  return getToken(MemgraphCypher::FOR, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::FOREACH() {
  return getToken(MemgraphCypher::FOREACH, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::FREE() {
  return getToken(MemgraphCypher::FREE, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::FROM() {
  return getToken(MemgraphCypher::FROM, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::GLOBAL() {
  return getToken(MemgraphCypher::GLOBAL, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::GRANT() {
  return getToken(MemgraphCypher::GRANT, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::HEADER() {
  return getToken(MemgraphCypher::HEADER, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::IDENTIFIED() {
  return getToken(MemgraphCypher::IDENTIFIED, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::ISOLATION() {
  return getToken(MemgraphCypher::ISOLATION, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::KAFKA() {
  return getToken(MemgraphCypher::KAFKA, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::LEVEL() {
  return getToken(MemgraphCypher::LEVEL, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::LOAD() {
  return getToken(MemgraphCypher::LOAD, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::LOCK() {
  return getToken(MemgraphCypher::LOCK, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::MAIN() {
  return getToken(MemgraphCypher::MAIN, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::MODE() {
  return getToken(MemgraphCypher::MODE, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::NEXT() {
  return getToken(MemgraphCypher::NEXT, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::NO() {
  return getToken(MemgraphCypher::NO, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::PASSWORD() {
  return getToken(MemgraphCypher::PASSWORD, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::PULSAR() {
  return getToken(MemgraphCypher::PULSAR, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::PORT() {
  return getToken(MemgraphCypher::PORT, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::PRIVILEGES() {
  return getToken(MemgraphCypher::PRIVILEGES, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::READ() {
  return getToken(MemgraphCypher::READ, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::REGISTER() {
  return getToken(MemgraphCypher::REGISTER, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::REPLICA() {
  return getToken(MemgraphCypher::REPLICA, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::REPLICAS() {
  return getToken(MemgraphCypher::REPLICAS, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::REPLICATION() {
  return getToken(MemgraphCypher::REPLICATION, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::REVOKE() {
  return getToken(MemgraphCypher::REVOKE, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::ROLE() {
  return getToken(MemgraphCypher::ROLE, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::ROLES() {
  return getToken(MemgraphCypher::ROLES, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::QUOTE() {
  return getToken(MemgraphCypher::QUOTE, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::SESSION() {
  return getToken(MemgraphCypher::SESSION, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::SETTING() {
  return getToken(MemgraphCypher::SETTING, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::SETTINGS() {
  return getToken(MemgraphCypher::SETTINGS, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::SNAPSHOT() {
  return getToken(MemgraphCypher::SNAPSHOT, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::START() {
  return getToken(MemgraphCypher::START, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::STATS() {
  return getToken(MemgraphCypher::STATS, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::STREAM() {
  return getToken(MemgraphCypher::STREAM, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::STREAMS() {
  return getToken(MemgraphCypher::STREAMS, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::SYNC() {
  return getToken(MemgraphCypher::SYNC, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::TIMEOUT() {
  return getToken(MemgraphCypher::TIMEOUT, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::TO() {
  return getToken(MemgraphCypher::TO, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::TOPICS() {
  return getToken(MemgraphCypher::TOPICS, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::TRANSACTION() {
  return getToken(MemgraphCypher::TRANSACTION, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::TRANSFORM() {
  return getToken(MemgraphCypher::TRANSFORM, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::TRIGGER() {
  return getToken(MemgraphCypher::TRIGGER, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::TRIGGERS() {
  return getToken(MemgraphCypher::TRIGGERS, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::UNCOMMITTED() {
  return getToken(MemgraphCypher::UNCOMMITTED, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::UNLOCK() {
  return getToken(MemgraphCypher::UNLOCK, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::UPDATE() {
  return getToken(MemgraphCypher::UPDATE, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::USER() {
  return getToken(MemgraphCypher::USER, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::USERS() {
  return getToken(MemgraphCypher::USERS, 0);
}

tree::TerminalNode* MemgraphCypher::MemgraphCypherKeywordContext::VERSION() {
  return getToken(MemgraphCypher::VERSION, 0);
}


size_t MemgraphCypher::MemgraphCypherKeywordContext::getRuleIndex() const {
  return MemgraphCypher::RuleMemgraphCypherKeyword;
}

void MemgraphCypher::MemgraphCypherKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemgraphCypherKeyword(this);
}

void MemgraphCypher::MemgraphCypherKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemgraphCypherKeyword(this);
}


std::any MemgraphCypher::MemgraphCypherKeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitMemgraphCypherKeyword(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::MemgraphCypherKeywordContext* MemgraphCypher::memgraphCypherKeyword() {
  MemgraphCypherKeywordContext *_localctx = _tracker.createInstance<MemgraphCypherKeywordContext>(_ctx, getState());
  enterRule(_localctx, 0, MemgraphCypher::RuleMemgraphCypherKeyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(453);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MemgraphCypher::ALL:
      case MemgraphCypher::AND:
      case MemgraphCypher::ANY:
      case MemgraphCypher::AS:
      case MemgraphCypher::ASC:
      case MemgraphCypher::ASCENDING:
      case MemgraphCypher::ASSERT:
      case MemgraphCypher::BFS:
      case MemgraphCypher::BY:
      case MemgraphCypher::CALL:
      case MemgraphCypher::CASE:
      case MemgraphCypher::CONSTRAINT:
      case MemgraphCypher::CONTAINS:
      case MemgraphCypher::COUNT:
      case MemgraphCypher::CREATE:
      case MemgraphCypher::CYPHERNULL:
      case MemgraphCypher::DELETE:
      case MemgraphCypher::DESC:
      case MemgraphCypher::DESCENDING:
      case MemgraphCypher::DETACH:
      case MemgraphCypher::DISTINCT:
      case MemgraphCypher::ELSE:
      case MemgraphCypher::END:
      case MemgraphCypher::ENDS:
      case MemgraphCypher::EXISTS:
      case MemgraphCypher::EXPLAIN:
      case MemgraphCypher::EXTRACT:
      case MemgraphCypher::FALSE:
      case MemgraphCypher::FILTER:
      case MemgraphCypher::IN:
      case MemgraphCypher::INDEX:
      case MemgraphCypher::INFO:
      case MemgraphCypher::IS:
      case MemgraphCypher::KEY:
      case MemgraphCypher::LIMIT:
      case MemgraphCypher::L_SKIP:
      case MemgraphCypher::MATCH:
      case MemgraphCypher::MERGE:
      case MemgraphCypher::NODE:
      case MemgraphCypher::NONE:
      case MemgraphCypher::NOT:
      case MemgraphCypher::ON:
      case MemgraphCypher::OPTIONAL:
      case MemgraphCypher::OR:
      case MemgraphCypher::ORDER:
      case MemgraphCypher::PROCEDURE:
      case MemgraphCypher::PROFILE:
      case MemgraphCypher::QUERY:
      case MemgraphCypher::REDUCE:
      case MemgraphCypher::REMOVE:
      case MemgraphCypher::RETURN:
      case MemgraphCypher::SET:
      case MemgraphCypher::SHOW:
      case MemgraphCypher::SINGLE:
      case MemgraphCypher::STARTS:
      case MemgraphCypher::STORAGE:
      case MemgraphCypher::THEN:
      case MemgraphCypher::TRUE:
      case MemgraphCypher::UNION:
      case MemgraphCypher::UNIQUE:
      case MemgraphCypher::UNWIND:
      case MemgraphCypher::WHEN:
      case MemgraphCypher::WHERE:
      case MemgraphCypher::WITH:
      case MemgraphCypher::WSHORTEST:
      case MemgraphCypher::XOR:
      case MemgraphCypher::YIELD: {
        enterOuterAlt(_localctx, 1);
        setState(374);
        cypherKeyword();
        break;
      }

      case MemgraphCypher::AFTER: {
        enterOuterAlt(_localctx, 2);
        setState(375);
        match(MemgraphCypher::AFTER);
        break;
      }

      case MemgraphCypher::ALTER: {
        enterOuterAlt(_localctx, 3);
        setState(376);
        match(MemgraphCypher::ALTER);
        break;
      }

      case MemgraphCypher::ASYNC: {
        enterOuterAlt(_localctx, 4);
        setState(377);
        match(MemgraphCypher::ASYNC);
        break;
      }

      case MemgraphCypher::AUTH: {
        enterOuterAlt(_localctx, 5);
        setState(378);
        match(MemgraphCypher::AUTH);
        break;
      }

      case MemgraphCypher::BAD: {
        enterOuterAlt(_localctx, 6);
        setState(379);
        match(MemgraphCypher::BAD);
        break;
      }

      case MemgraphCypher::BATCH_INTERVAL: {
        enterOuterAlt(_localctx, 7);
        setState(380);
        match(MemgraphCypher::BATCH_INTERVAL);
        break;
      }

      case MemgraphCypher::BATCH_LIMIT: {
        enterOuterAlt(_localctx, 8);
        setState(381);
        match(MemgraphCypher::BATCH_LIMIT);
        break;
      }

      case MemgraphCypher::BATCH_SIZE: {
        enterOuterAlt(_localctx, 9);
        setState(382);
        match(MemgraphCypher::BATCH_SIZE);
        break;
      }

      case MemgraphCypher::BEFORE: {
        enterOuterAlt(_localctx, 10);
        setState(383);
        match(MemgraphCypher::BEFORE);
        break;
      }

      case MemgraphCypher::BOOTSTRAP_SERVERS: {
        enterOuterAlt(_localctx, 11);
        setState(384);
        match(MemgraphCypher::BOOTSTRAP_SERVERS);
        break;
      }

      case MemgraphCypher::CHECK: {
        enterOuterAlt(_localctx, 12);
        setState(385);
        match(MemgraphCypher::CHECK);
        break;
      }

      case MemgraphCypher::CLEAR: {
        enterOuterAlt(_localctx, 13);
        setState(386);
        match(MemgraphCypher::CLEAR);
        break;
      }

      case MemgraphCypher::COMMIT: {
        enterOuterAlt(_localctx, 14);
        setState(387);
        match(MemgraphCypher::COMMIT);
        break;
      }

      case MemgraphCypher::COMMITTED: {
        enterOuterAlt(_localctx, 15);
        setState(388);
        match(MemgraphCypher::COMMITTED);
        break;
      }

      case MemgraphCypher::CONFIG: {
        enterOuterAlt(_localctx, 16);
        setState(389);
        match(MemgraphCypher::CONFIG);
        break;
      }

      case MemgraphCypher::CONFIGS: {
        enterOuterAlt(_localctx, 17);
        setState(390);
        match(MemgraphCypher::CONFIGS);
        break;
      }

      case MemgraphCypher::CONSUMER_GROUP: {
        enterOuterAlt(_localctx, 18);
        setState(391);
        match(MemgraphCypher::CONSUMER_GROUP);
        break;
      }

      case MemgraphCypher::CREDENTIALS: {
        enterOuterAlt(_localctx, 19);
        setState(392);
        match(MemgraphCypher::CREDENTIALS);
        break;
      }

      case MemgraphCypher::CSV: {
        enterOuterAlt(_localctx, 20);
        setState(393);
        match(MemgraphCypher::CSV);
        break;
      }

      case MemgraphCypher::DATA: {
        enterOuterAlt(_localctx, 21);
        setState(394);
        match(MemgraphCypher::DATA);
        break;
      }

      case MemgraphCypher::DELIMITER: {
        enterOuterAlt(_localctx, 22);
        setState(395);
        match(MemgraphCypher::DELIMITER);
        break;
      }

      case MemgraphCypher::DATABASE: {
        enterOuterAlt(_localctx, 23);
        setState(396);
        match(MemgraphCypher::DATABASE);
        break;
      }

      case MemgraphCypher::DENY: {
        enterOuterAlt(_localctx, 24);
        setState(397);
        match(MemgraphCypher::DENY);
        break;
      }

      case MemgraphCypher::DROP: {
        enterOuterAlt(_localctx, 25);
        setState(398);
        match(MemgraphCypher::DROP);
        break;
      }

      case MemgraphCypher::DUMP: {
        enterOuterAlt(_localctx, 26);
        setState(399);
        match(MemgraphCypher::DUMP);
        break;
      }

      case MemgraphCypher::EXECUTE: {
        enterOuterAlt(_localctx, 27);
        setState(400);
        match(MemgraphCypher::EXECUTE);
        break;
      }

      case MemgraphCypher::FOR: {
        enterOuterAlt(_localctx, 28);
        setState(401);
        match(MemgraphCypher::FOR);
        break;
      }

      case MemgraphCypher::FOREACH: {
        enterOuterAlt(_localctx, 29);
        setState(402);
        match(MemgraphCypher::FOREACH);
        break;
      }

      case MemgraphCypher::FREE: {
        enterOuterAlt(_localctx, 30);
        setState(403);
        match(MemgraphCypher::FREE);
        break;
      }

      case MemgraphCypher::FROM: {
        enterOuterAlt(_localctx, 31);
        setState(404);
        match(MemgraphCypher::FROM);
        break;
      }

      case MemgraphCypher::GLOBAL: {
        enterOuterAlt(_localctx, 32);
        setState(405);
        match(MemgraphCypher::GLOBAL);
        break;
      }

      case MemgraphCypher::GRANT: {
        enterOuterAlt(_localctx, 33);
        setState(406);
        match(MemgraphCypher::GRANT);
        break;
      }

      case MemgraphCypher::HEADER: {
        enterOuterAlt(_localctx, 34);
        setState(407);
        match(MemgraphCypher::HEADER);
        break;
      }

      case MemgraphCypher::IDENTIFIED: {
        enterOuterAlt(_localctx, 35);
        setState(408);
        match(MemgraphCypher::IDENTIFIED);
        break;
      }

      case MemgraphCypher::ISOLATION: {
        enterOuterAlt(_localctx, 36);
        setState(409);
        match(MemgraphCypher::ISOLATION);
        break;
      }

      case MemgraphCypher::KAFKA: {
        enterOuterAlt(_localctx, 37);
        setState(410);
        match(MemgraphCypher::KAFKA);
        break;
      }

      case MemgraphCypher::LEVEL: {
        enterOuterAlt(_localctx, 38);
        setState(411);
        match(MemgraphCypher::LEVEL);
        break;
      }

      case MemgraphCypher::LOAD: {
        enterOuterAlt(_localctx, 39);
        setState(412);
        match(MemgraphCypher::LOAD);
        break;
      }

      case MemgraphCypher::LOCK: {
        enterOuterAlt(_localctx, 40);
        setState(413);
        match(MemgraphCypher::LOCK);
        break;
      }

      case MemgraphCypher::MAIN: {
        enterOuterAlt(_localctx, 41);
        setState(414);
        match(MemgraphCypher::MAIN);
        break;
      }

      case MemgraphCypher::MODE: {
        enterOuterAlt(_localctx, 42);
        setState(415);
        match(MemgraphCypher::MODE);
        break;
      }

      case MemgraphCypher::NEXT: {
        enterOuterAlt(_localctx, 43);
        setState(416);
        match(MemgraphCypher::NEXT);
        break;
      }

      case MemgraphCypher::NO: {
        enterOuterAlt(_localctx, 44);
        setState(417);
        match(MemgraphCypher::NO);
        break;
      }

      case MemgraphCypher::PASSWORD: {
        enterOuterAlt(_localctx, 45);
        setState(418);
        match(MemgraphCypher::PASSWORD);
        break;
      }

      case MemgraphCypher::PULSAR: {
        enterOuterAlt(_localctx, 46);
        setState(419);
        match(MemgraphCypher::PULSAR);
        break;
      }

      case MemgraphCypher::PORT: {
        enterOuterAlt(_localctx, 47);
        setState(420);
        match(MemgraphCypher::PORT);
        break;
      }

      case MemgraphCypher::PRIVILEGES: {
        enterOuterAlt(_localctx, 48);
        setState(421);
        match(MemgraphCypher::PRIVILEGES);
        break;
      }

      case MemgraphCypher::READ: {
        enterOuterAlt(_localctx, 49);
        setState(422);
        match(MemgraphCypher::READ);
        break;
      }

      case MemgraphCypher::REGISTER: {
        enterOuterAlt(_localctx, 50);
        setState(423);
        match(MemgraphCypher::REGISTER);
        break;
      }

      case MemgraphCypher::REPLICA: {
        enterOuterAlt(_localctx, 51);
        setState(424);
        match(MemgraphCypher::REPLICA);
        break;
      }

      case MemgraphCypher::REPLICAS: {
        enterOuterAlt(_localctx, 52);
        setState(425);
        match(MemgraphCypher::REPLICAS);
        break;
      }

      case MemgraphCypher::REPLICATION: {
        enterOuterAlt(_localctx, 53);
        setState(426);
        match(MemgraphCypher::REPLICATION);
        break;
      }

      case MemgraphCypher::REVOKE: {
        enterOuterAlt(_localctx, 54);
        setState(427);
        match(MemgraphCypher::REVOKE);
        break;
      }

      case MemgraphCypher::ROLE: {
        enterOuterAlt(_localctx, 55);
        setState(428);
        match(MemgraphCypher::ROLE);
        break;
      }

      case MemgraphCypher::ROLES: {
        enterOuterAlt(_localctx, 56);
        setState(429);
        match(MemgraphCypher::ROLES);
        break;
      }

      case MemgraphCypher::QUOTE: {
        enterOuterAlt(_localctx, 57);
        setState(430);
        match(MemgraphCypher::QUOTE);
        break;
      }

      case MemgraphCypher::SESSION: {
        enterOuterAlt(_localctx, 58);
        setState(431);
        match(MemgraphCypher::SESSION);
        break;
      }

      case MemgraphCypher::SETTING: {
        enterOuterAlt(_localctx, 59);
        setState(432);
        match(MemgraphCypher::SETTING);
        break;
      }

      case MemgraphCypher::SETTINGS: {
        enterOuterAlt(_localctx, 60);
        setState(433);
        match(MemgraphCypher::SETTINGS);
        break;
      }

      case MemgraphCypher::SNAPSHOT: {
        enterOuterAlt(_localctx, 61);
        setState(434);
        match(MemgraphCypher::SNAPSHOT);
        break;
      }

      case MemgraphCypher::START: {
        enterOuterAlt(_localctx, 62);
        setState(435);
        match(MemgraphCypher::START);
        break;
      }

      case MemgraphCypher::STATS: {
        enterOuterAlt(_localctx, 63);
        setState(436);
        match(MemgraphCypher::STATS);
        break;
      }

      case MemgraphCypher::STREAM: {
        enterOuterAlt(_localctx, 64);
        setState(437);
        match(MemgraphCypher::STREAM);
        break;
      }

      case MemgraphCypher::STREAMS: {
        enterOuterAlt(_localctx, 65);
        setState(438);
        match(MemgraphCypher::STREAMS);
        break;
      }

      case MemgraphCypher::SYNC: {
        enterOuterAlt(_localctx, 66);
        setState(439);
        match(MemgraphCypher::SYNC);
        break;
      }

      case MemgraphCypher::TIMEOUT: {
        enterOuterAlt(_localctx, 67);
        setState(440);
        match(MemgraphCypher::TIMEOUT);
        break;
      }

      case MemgraphCypher::TO: {
        enterOuterAlt(_localctx, 68);
        setState(441);
        match(MemgraphCypher::TO);
        break;
      }

      case MemgraphCypher::TOPICS: {
        enterOuterAlt(_localctx, 69);
        setState(442);
        match(MemgraphCypher::TOPICS);
        break;
      }

      case MemgraphCypher::TRANSACTION: {
        enterOuterAlt(_localctx, 70);
        setState(443);
        match(MemgraphCypher::TRANSACTION);
        break;
      }

      case MemgraphCypher::TRANSFORM: {
        enterOuterAlt(_localctx, 71);
        setState(444);
        match(MemgraphCypher::TRANSFORM);
        break;
      }

      case MemgraphCypher::TRIGGER: {
        enterOuterAlt(_localctx, 72);
        setState(445);
        match(MemgraphCypher::TRIGGER);
        break;
      }

      case MemgraphCypher::TRIGGERS: {
        enterOuterAlt(_localctx, 73);
        setState(446);
        match(MemgraphCypher::TRIGGERS);
        break;
      }

      case MemgraphCypher::UNCOMMITTED: {
        enterOuterAlt(_localctx, 74);
        setState(447);
        match(MemgraphCypher::UNCOMMITTED);
        break;
      }

      case MemgraphCypher::UNLOCK: {
        enterOuterAlt(_localctx, 75);
        setState(448);
        match(MemgraphCypher::UNLOCK);
        break;
      }

      case MemgraphCypher::UPDATE: {
        enterOuterAlt(_localctx, 76);
        setState(449);
        match(MemgraphCypher::UPDATE);
        break;
      }

      case MemgraphCypher::USER: {
        enterOuterAlt(_localctx, 77);
        setState(450);
        match(MemgraphCypher::USER);
        break;
      }

      case MemgraphCypher::USERS: {
        enterOuterAlt(_localctx, 78);
        setState(451);
        match(MemgraphCypher::USERS);
        break;
      }

      case MemgraphCypher::VERSION: {
        enterOuterAlt(_localctx, 79);
        setState(452);
        match(MemgraphCypher::VERSION);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SymbolicNameContext ------------------------------------------------------------------

MemgraphCypher::SymbolicNameContext::SymbolicNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::SymbolicNameContext::UnescapedSymbolicName() {
  return getToken(MemgraphCypher::UnescapedSymbolicName, 0);
}

tree::TerminalNode* MemgraphCypher::SymbolicNameContext::EscapedSymbolicName() {
  return getToken(MemgraphCypher::EscapedSymbolicName, 0);
}

MemgraphCypher::MemgraphCypherKeywordContext* MemgraphCypher::SymbolicNameContext::memgraphCypherKeyword() {
  return getRuleContext<MemgraphCypher::MemgraphCypherKeywordContext>(0);
}


size_t MemgraphCypher::SymbolicNameContext::getRuleIndex() const {
  return MemgraphCypher::RuleSymbolicName;
}

void MemgraphCypher::SymbolicNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSymbolicName(this);
}

void MemgraphCypher::SymbolicNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSymbolicName(this);
}


std::any MemgraphCypher::SymbolicNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitSymbolicName(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::SymbolicNameContext* MemgraphCypher::symbolicName() {
  SymbolicNameContext *_localctx = _tracker.createInstance<SymbolicNameContext>(_ctx, getState());
  enterRule(_localctx, 2, MemgraphCypher::RuleSymbolicName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(458);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MemgraphCypher::UnescapedSymbolicName: {
        enterOuterAlt(_localctx, 1);
        setState(455);
        match(MemgraphCypher::UnescapedSymbolicName);
        break;
      }

      case MemgraphCypher::EscapedSymbolicName: {
        enterOuterAlt(_localctx, 2);
        setState(456);
        match(MemgraphCypher::EscapedSymbolicName);
        break;
      }

      case MemgraphCypher::AFTER:
      case MemgraphCypher::ALTER:
      case MemgraphCypher::ASYNC:
      case MemgraphCypher::AUTH:
      case MemgraphCypher::BAD:
      case MemgraphCypher::BATCH_INTERVAL:
      case MemgraphCypher::BATCH_LIMIT:
      case MemgraphCypher::BATCH_SIZE:
      case MemgraphCypher::BEFORE:
      case MemgraphCypher::BOOTSTRAP_SERVERS:
      case MemgraphCypher::CHECK:
      case MemgraphCypher::CLEAR:
      case MemgraphCypher::COMMIT:
      case MemgraphCypher::COMMITTED:
      case MemgraphCypher::CONFIG:
      case MemgraphCypher::CONFIGS:
      case MemgraphCypher::CONSUMER_GROUP:
      case MemgraphCypher::CREDENTIALS:
      case MemgraphCypher::CSV:
      case MemgraphCypher::DATA:
      case MemgraphCypher::DELIMITER:
      case MemgraphCypher::DATABASE:
      case MemgraphCypher::DENY:
      case MemgraphCypher::DROP:
      case MemgraphCypher::DUMP:
      case MemgraphCypher::EXECUTE:
      case MemgraphCypher::FOR:
      case MemgraphCypher::FOREACH:
      case MemgraphCypher::FREE:
      case MemgraphCypher::FROM:
      case MemgraphCypher::GLOBAL:
      case MemgraphCypher::GRANT:
      case MemgraphCypher::HEADER:
      case MemgraphCypher::IDENTIFIED:
      case MemgraphCypher::ISOLATION:
      case MemgraphCypher::KAFKA:
      case MemgraphCypher::LEVEL:
      case MemgraphCypher::LOAD:
      case MemgraphCypher::LOCK:
      case MemgraphCypher::MAIN:
      case MemgraphCypher::MODE:
      case MemgraphCypher::NEXT:
      case MemgraphCypher::NO:
      case MemgraphCypher::PASSWORD:
      case MemgraphCypher::PORT:
      case MemgraphCypher::PRIVILEGES:
      case MemgraphCypher::PULSAR:
      case MemgraphCypher::READ:
      case MemgraphCypher::REGISTER:
      case MemgraphCypher::REPLICA:
      case MemgraphCypher::REPLICAS:
      case MemgraphCypher::REPLICATION:
      case MemgraphCypher::REVOKE:
      case MemgraphCypher::ROLE:
      case MemgraphCypher::ROLES:
      case MemgraphCypher::QUOTE:
      case MemgraphCypher::SESSION:
      case MemgraphCypher::SETTING:
      case MemgraphCypher::SETTINGS:
      case MemgraphCypher::SNAPSHOT:
      case MemgraphCypher::START:
      case MemgraphCypher::STATS:
      case MemgraphCypher::STREAM:
      case MemgraphCypher::STREAMS:
      case MemgraphCypher::SYNC:
      case MemgraphCypher::TIMEOUT:
      case MemgraphCypher::TO:
      case MemgraphCypher::TOPICS:
      case MemgraphCypher::TRANSACTION:
      case MemgraphCypher::TRANSFORM:
      case MemgraphCypher::TRIGGER:
      case MemgraphCypher::TRIGGERS:
      case MemgraphCypher::UNCOMMITTED:
      case MemgraphCypher::UNLOCK:
      case MemgraphCypher::UPDATE:
      case MemgraphCypher::USER:
      case MemgraphCypher::USERS:
      case MemgraphCypher::VERSION:
      case MemgraphCypher::ALL:
      case MemgraphCypher::AND:
      case MemgraphCypher::ANY:
      case MemgraphCypher::AS:
      case MemgraphCypher::ASC:
      case MemgraphCypher::ASCENDING:
      case MemgraphCypher::ASSERT:
      case MemgraphCypher::BFS:
      case MemgraphCypher::BY:
      case MemgraphCypher::CALL:
      case MemgraphCypher::CASE:
      case MemgraphCypher::CONSTRAINT:
      case MemgraphCypher::CONTAINS:
      case MemgraphCypher::COUNT:
      case MemgraphCypher::CREATE:
      case MemgraphCypher::CYPHERNULL:
      case MemgraphCypher::DELETE:
      case MemgraphCypher::DESC:
      case MemgraphCypher::DESCENDING:
      case MemgraphCypher::DETACH:
      case MemgraphCypher::DISTINCT:
      case MemgraphCypher::ELSE:
      case MemgraphCypher::END:
      case MemgraphCypher::ENDS:
      case MemgraphCypher::EXISTS:
      case MemgraphCypher::EXPLAIN:
      case MemgraphCypher::EXTRACT:
      case MemgraphCypher::FALSE:
      case MemgraphCypher::FILTER:
      case MemgraphCypher::IN:
      case MemgraphCypher::INDEX:
      case MemgraphCypher::INFO:
      case MemgraphCypher::IS:
      case MemgraphCypher::KEY:
      case MemgraphCypher::LIMIT:
      case MemgraphCypher::L_SKIP:
      case MemgraphCypher::MATCH:
      case MemgraphCypher::MERGE:
      case MemgraphCypher::NODE:
      case MemgraphCypher::NONE:
      case MemgraphCypher::NOT:
      case MemgraphCypher::ON:
      case MemgraphCypher::OPTIONAL:
      case MemgraphCypher::OR:
      case MemgraphCypher::ORDER:
      case MemgraphCypher::PROCEDURE:
      case MemgraphCypher::PROFILE:
      case MemgraphCypher::QUERY:
      case MemgraphCypher::REDUCE:
      case MemgraphCypher::REMOVE:
      case MemgraphCypher::RETURN:
      case MemgraphCypher::SET:
      case MemgraphCypher::SHOW:
      case MemgraphCypher::SINGLE:
      case MemgraphCypher::STARTS:
      case MemgraphCypher::STORAGE:
      case MemgraphCypher::THEN:
      case MemgraphCypher::TRUE:
      case MemgraphCypher::UNION:
      case MemgraphCypher::UNIQUE:
      case MemgraphCypher::UNWIND:
      case MemgraphCypher::WHEN:
      case MemgraphCypher::WHERE:
      case MemgraphCypher::WITH:
      case MemgraphCypher::WSHORTEST:
      case MemgraphCypher::XOR:
      case MemgraphCypher::YIELD: {
        enterOuterAlt(_localctx, 3);
        setState(457);
        memgraphCypherKeyword();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryContext ------------------------------------------------------------------

MemgraphCypher::QueryContext::QueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::CypherQueryContext* MemgraphCypher::QueryContext::cypherQuery() {
  return getRuleContext<MemgraphCypher::CypherQueryContext>(0);
}

MemgraphCypher::IndexQueryContext* MemgraphCypher::QueryContext::indexQuery() {
  return getRuleContext<MemgraphCypher::IndexQueryContext>(0);
}

MemgraphCypher::ExplainQueryContext* MemgraphCypher::QueryContext::explainQuery() {
  return getRuleContext<MemgraphCypher::ExplainQueryContext>(0);
}

MemgraphCypher::ProfileQueryContext* MemgraphCypher::QueryContext::profileQuery() {
  return getRuleContext<MemgraphCypher::ProfileQueryContext>(0);
}

MemgraphCypher::InfoQueryContext* MemgraphCypher::QueryContext::infoQuery() {
  return getRuleContext<MemgraphCypher::InfoQueryContext>(0);
}

MemgraphCypher::ConstraintQueryContext* MemgraphCypher::QueryContext::constraintQuery() {
  return getRuleContext<MemgraphCypher::ConstraintQueryContext>(0);
}

MemgraphCypher::AuthQueryContext* MemgraphCypher::QueryContext::authQuery() {
  return getRuleContext<MemgraphCypher::AuthQueryContext>(0);
}

MemgraphCypher::DumpQueryContext* MemgraphCypher::QueryContext::dumpQuery() {
  return getRuleContext<MemgraphCypher::DumpQueryContext>(0);
}

MemgraphCypher::ReplicationQueryContext* MemgraphCypher::QueryContext::replicationQuery() {
  return getRuleContext<MemgraphCypher::ReplicationQueryContext>(0);
}

MemgraphCypher::LockPathQueryContext* MemgraphCypher::QueryContext::lockPathQuery() {
  return getRuleContext<MemgraphCypher::LockPathQueryContext>(0);
}

MemgraphCypher::FreeMemoryQueryContext* MemgraphCypher::QueryContext::freeMemoryQuery() {
  return getRuleContext<MemgraphCypher::FreeMemoryQueryContext>(0);
}

MemgraphCypher::TriggerQueryContext* MemgraphCypher::QueryContext::triggerQuery() {
  return getRuleContext<MemgraphCypher::TriggerQueryContext>(0);
}

MemgraphCypher::IsolationLevelQueryContext* MemgraphCypher::QueryContext::isolationLevelQuery() {
  return getRuleContext<MemgraphCypher::IsolationLevelQueryContext>(0);
}

MemgraphCypher::CreateSnapshotQueryContext* MemgraphCypher::QueryContext::createSnapshotQuery() {
  return getRuleContext<MemgraphCypher::CreateSnapshotQueryContext>(0);
}

MemgraphCypher::StreamQueryContext* MemgraphCypher::QueryContext::streamQuery() {
  return getRuleContext<MemgraphCypher::StreamQueryContext>(0);
}

MemgraphCypher::SettingQueryContext* MemgraphCypher::QueryContext::settingQuery() {
  return getRuleContext<MemgraphCypher::SettingQueryContext>(0);
}

MemgraphCypher::VersionQueryContext* MemgraphCypher::QueryContext::versionQuery() {
  return getRuleContext<MemgraphCypher::VersionQueryContext>(0);
}


size_t MemgraphCypher::QueryContext::getRuleIndex() const {
  return MemgraphCypher::RuleQuery;
}

void MemgraphCypher::QueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuery(this);
}

void MemgraphCypher::QueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuery(this);
}


std::any MemgraphCypher::QueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitQuery(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::QueryContext* MemgraphCypher::query() {
  QueryContext *_localctx = _tracker.createInstance<QueryContext>(_ctx, getState());
  enterRule(_localctx, 4, MemgraphCypher::RuleQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(477);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(460);
      cypherQuery();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(461);
      indexQuery();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(462);
      explainQuery();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(463);
      profileQuery();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(464);
      infoQuery();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(465);
      constraintQuery();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(466);
      authQuery();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(467);
      dumpQuery();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(468);
      replicationQuery();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(469);
      lockPathQuery();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(470);
      freeMemoryQuery();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(471);
      triggerQuery();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(472);
      isolationLevelQuery();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(473);
      createSnapshotQuery();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(474);
      streamQuery();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(475);
      settingQuery();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(476);
      versionQuery();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AuthQueryContext ------------------------------------------------------------------

MemgraphCypher::AuthQueryContext::AuthQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::CreateRoleContext* MemgraphCypher::AuthQueryContext::createRole() {
  return getRuleContext<MemgraphCypher::CreateRoleContext>(0);
}

MemgraphCypher::DropRoleContext* MemgraphCypher::AuthQueryContext::dropRole() {
  return getRuleContext<MemgraphCypher::DropRoleContext>(0);
}

MemgraphCypher::ShowRolesContext* MemgraphCypher::AuthQueryContext::showRoles() {
  return getRuleContext<MemgraphCypher::ShowRolesContext>(0);
}

MemgraphCypher::CreateUserContext* MemgraphCypher::AuthQueryContext::createUser() {
  return getRuleContext<MemgraphCypher::CreateUserContext>(0);
}

MemgraphCypher::SetPasswordContext* MemgraphCypher::AuthQueryContext::setPassword() {
  return getRuleContext<MemgraphCypher::SetPasswordContext>(0);
}

MemgraphCypher::DropUserContext* MemgraphCypher::AuthQueryContext::dropUser() {
  return getRuleContext<MemgraphCypher::DropUserContext>(0);
}

MemgraphCypher::ShowUsersContext* MemgraphCypher::AuthQueryContext::showUsers() {
  return getRuleContext<MemgraphCypher::ShowUsersContext>(0);
}

MemgraphCypher::SetRoleContext* MemgraphCypher::AuthQueryContext::setRole() {
  return getRuleContext<MemgraphCypher::SetRoleContext>(0);
}

MemgraphCypher::ClearRoleContext* MemgraphCypher::AuthQueryContext::clearRole() {
  return getRuleContext<MemgraphCypher::ClearRoleContext>(0);
}

MemgraphCypher::GrantPrivilegeContext* MemgraphCypher::AuthQueryContext::grantPrivilege() {
  return getRuleContext<MemgraphCypher::GrantPrivilegeContext>(0);
}

MemgraphCypher::DenyPrivilegeContext* MemgraphCypher::AuthQueryContext::denyPrivilege() {
  return getRuleContext<MemgraphCypher::DenyPrivilegeContext>(0);
}

MemgraphCypher::RevokePrivilegeContext* MemgraphCypher::AuthQueryContext::revokePrivilege() {
  return getRuleContext<MemgraphCypher::RevokePrivilegeContext>(0);
}

MemgraphCypher::ShowPrivilegesContext* MemgraphCypher::AuthQueryContext::showPrivileges() {
  return getRuleContext<MemgraphCypher::ShowPrivilegesContext>(0);
}

MemgraphCypher::ShowRoleForUserContext* MemgraphCypher::AuthQueryContext::showRoleForUser() {
  return getRuleContext<MemgraphCypher::ShowRoleForUserContext>(0);
}

MemgraphCypher::ShowUsersForRoleContext* MemgraphCypher::AuthQueryContext::showUsersForRole() {
  return getRuleContext<MemgraphCypher::ShowUsersForRoleContext>(0);
}


size_t MemgraphCypher::AuthQueryContext::getRuleIndex() const {
  return MemgraphCypher::RuleAuthQuery;
}

void MemgraphCypher::AuthQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAuthQuery(this);
}

void MemgraphCypher::AuthQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAuthQuery(this);
}


std::any MemgraphCypher::AuthQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitAuthQuery(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::AuthQueryContext* MemgraphCypher::authQuery() {
  AuthQueryContext *_localctx = _tracker.createInstance<AuthQueryContext>(_ctx, getState());
  enterRule(_localctx, 6, MemgraphCypher::RuleAuthQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(494);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(479);
      createRole();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(480);
      dropRole();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(481);
      showRoles();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(482);
      createUser();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(483);
      setPassword();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(484);
      dropUser();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(485);
      showUsers();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(486);
      setRole();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(487);
      clearRole();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(488);
      grantPrivilege();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(489);
      denyPrivilege();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(490);
      revokePrivilege();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(491);
      showPrivileges();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(492);
      showRoleForUser();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(493);
      showUsersForRole();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplicationQueryContext ------------------------------------------------------------------

MemgraphCypher::ReplicationQueryContext::ReplicationQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::SetReplicationRoleContext* MemgraphCypher::ReplicationQueryContext::setReplicationRole() {
  return getRuleContext<MemgraphCypher::SetReplicationRoleContext>(0);
}

MemgraphCypher::ShowReplicationRoleContext* MemgraphCypher::ReplicationQueryContext::showReplicationRole() {
  return getRuleContext<MemgraphCypher::ShowReplicationRoleContext>(0);
}

MemgraphCypher::RegisterReplicaContext* MemgraphCypher::ReplicationQueryContext::registerReplica() {
  return getRuleContext<MemgraphCypher::RegisterReplicaContext>(0);
}

MemgraphCypher::DropReplicaContext* MemgraphCypher::ReplicationQueryContext::dropReplica() {
  return getRuleContext<MemgraphCypher::DropReplicaContext>(0);
}

MemgraphCypher::ShowReplicasContext* MemgraphCypher::ReplicationQueryContext::showReplicas() {
  return getRuleContext<MemgraphCypher::ShowReplicasContext>(0);
}


size_t MemgraphCypher::ReplicationQueryContext::getRuleIndex() const {
  return MemgraphCypher::RuleReplicationQuery;
}

void MemgraphCypher::ReplicationQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplicationQuery(this);
}

void MemgraphCypher::ReplicationQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplicationQuery(this);
}


std::any MemgraphCypher::ReplicationQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitReplicationQuery(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ReplicationQueryContext* MemgraphCypher::replicationQuery() {
  ReplicationQueryContext *_localctx = _tracker.createInstance<ReplicationQueryContext>(_ctx, getState());
  enterRule(_localctx, 8, MemgraphCypher::RuleReplicationQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(501);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(496);
      setReplicationRole();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(497);
      showReplicationRole();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(498);
      registerReplica();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(499);
      dropReplica();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(500);
      showReplicas();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerQueryContext ------------------------------------------------------------------

MemgraphCypher::TriggerQueryContext::TriggerQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::CreateTriggerContext* MemgraphCypher::TriggerQueryContext::createTrigger() {
  return getRuleContext<MemgraphCypher::CreateTriggerContext>(0);
}

MemgraphCypher::DropTriggerContext* MemgraphCypher::TriggerQueryContext::dropTrigger() {
  return getRuleContext<MemgraphCypher::DropTriggerContext>(0);
}

MemgraphCypher::ShowTriggersContext* MemgraphCypher::TriggerQueryContext::showTriggers() {
  return getRuleContext<MemgraphCypher::ShowTriggersContext>(0);
}


size_t MemgraphCypher::TriggerQueryContext::getRuleIndex() const {
  return MemgraphCypher::RuleTriggerQuery;
}

void MemgraphCypher::TriggerQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTriggerQuery(this);
}

void MemgraphCypher::TriggerQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTriggerQuery(this);
}


std::any MemgraphCypher::TriggerQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitTriggerQuery(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::TriggerQueryContext* MemgraphCypher::triggerQuery() {
  TriggerQueryContext *_localctx = _tracker.createInstance<TriggerQueryContext>(_ctx, getState());
  enterRule(_localctx, 10, MemgraphCypher::RuleTriggerQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(506);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MemgraphCypher::CREATE: {
        enterOuterAlt(_localctx, 1);
        setState(503);
        createTrigger();
        break;
      }

      case MemgraphCypher::DROP: {
        enterOuterAlt(_localctx, 2);
        setState(504);
        dropTrigger();
        break;
      }

      case MemgraphCypher::SHOW: {
        enterOuterAlt(_localctx, 3);
        setState(505);
        showTriggers();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClauseContext ------------------------------------------------------------------

MemgraphCypher::ClauseContext::ClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::CypherMatchContext* MemgraphCypher::ClauseContext::cypherMatch() {
  return getRuleContext<MemgraphCypher::CypherMatchContext>(0);
}

MemgraphCypher::UnwindContext* MemgraphCypher::ClauseContext::unwind() {
  return getRuleContext<MemgraphCypher::UnwindContext>(0);
}

MemgraphCypher::MergeContext* MemgraphCypher::ClauseContext::merge() {
  return getRuleContext<MemgraphCypher::MergeContext>(0);
}

MemgraphCypher::CreateContext* MemgraphCypher::ClauseContext::create() {
  return getRuleContext<MemgraphCypher::CreateContext>(0);
}

MemgraphCypher::SetContext* MemgraphCypher::ClauseContext::set() {
  return getRuleContext<MemgraphCypher::SetContext>(0);
}

MemgraphCypher::CypherDeleteContext* MemgraphCypher::ClauseContext::cypherDelete() {
  return getRuleContext<MemgraphCypher::CypherDeleteContext>(0);
}

MemgraphCypher::RemoveContext* MemgraphCypher::ClauseContext::remove() {
  return getRuleContext<MemgraphCypher::RemoveContext>(0);
}

MemgraphCypher::WithContext* MemgraphCypher::ClauseContext::with() {
  return getRuleContext<MemgraphCypher::WithContext>(0);
}

MemgraphCypher::CypherReturnContext* MemgraphCypher::ClauseContext::cypherReturn() {
  return getRuleContext<MemgraphCypher::CypherReturnContext>(0);
}

MemgraphCypher::CallProcedureContext* MemgraphCypher::ClauseContext::callProcedure() {
  return getRuleContext<MemgraphCypher::CallProcedureContext>(0);
}

MemgraphCypher::LoadCsvContext* MemgraphCypher::ClauseContext::loadCsv() {
  return getRuleContext<MemgraphCypher::LoadCsvContext>(0);
}

MemgraphCypher::ForeachContext* MemgraphCypher::ClauseContext::foreach() {
  return getRuleContext<MemgraphCypher::ForeachContext>(0);
}


size_t MemgraphCypher::ClauseContext::getRuleIndex() const {
  return MemgraphCypher::RuleClause;
}

void MemgraphCypher::ClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClause(this);
}

void MemgraphCypher::ClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClause(this);
}


std::any MemgraphCypher::ClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitClause(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ClauseContext* MemgraphCypher::clause() {
  ClauseContext *_localctx = _tracker.createInstance<ClauseContext>(_ctx, getState());
  enterRule(_localctx, 12, MemgraphCypher::RuleClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(520);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MemgraphCypher::MATCH:
      case MemgraphCypher::OPTIONAL: {
        enterOuterAlt(_localctx, 1);
        setState(508);
        cypherMatch();
        break;
      }

      case MemgraphCypher::UNWIND: {
        enterOuterAlt(_localctx, 2);
        setState(509);
        unwind();
        break;
      }

      case MemgraphCypher::MERGE: {
        enterOuterAlt(_localctx, 3);
        setState(510);
        merge();
        break;
      }

      case MemgraphCypher::CREATE: {
        enterOuterAlt(_localctx, 4);
        setState(511);
        create();
        break;
      }

      case MemgraphCypher::SET: {
        enterOuterAlt(_localctx, 5);
        setState(512);
        set();
        break;
      }

      case MemgraphCypher::DELETE:
      case MemgraphCypher::DETACH: {
        enterOuterAlt(_localctx, 6);
        setState(513);
        cypherDelete();
        break;
      }

      case MemgraphCypher::REMOVE: {
        enterOuterAlt(_localctx, 7);
        setState(514);
        remove();
        break;
      }

      case MemgraphCypher::WITH: {
        enterOuterAlt(_localctx, 8);
        setState(515);
        with();
        break;
      }

      case MemgraphCypher::RETURN: {
        enterOuterAlt(_localctx, 9);
        setState(516);
        cypherReturn();
        break;
      }

      case MemgraphCypher::CALL: {
        enterOuterAlt(_localctx, 10);
        setState(517);
        callProcedure();
        break;
      }

      case MemgraphCypher::LOAD: {
        enterOuterAlt(_localctx, 11);
        setState(518);
        loadCsv();
        break;
      }

      case MemgraphCypher::FOREACH: {
        enterOuterAlt(_localctx, 12);
        setState(519);
        foreach();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UpdateClauseContext ------------------------------------------------------------------

MemgraphCypher::UpdateClauseContext::UpdateClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::SetContext* MemgraphCypher::UpdateClauseContext::set() {
  return getRuleContext<MemgraphCypher::SetContext>(0);
}

MemgraphCypher::RemoveContext* MemgraphCypher::UpdateClauseContext::remove() {
  return getRuleContext<MemgraphCypher::RemoveContext>(0);
}

MemgraphCypher::CreateContext* MemgraphCypher::UpdateClauseContext::create() {
  return getRuleContext<MemgraphCypher::CreateContext>(0);
}

MemgraphCypher::MergeContext* MemgraphCypher::UpdateClauseContext::merge() {
  return getRuleContext<MemgraphCypher::MergeContext>(0);
}

MemgraphCypher::CypherDeleteContext* MemgraphCypher::UpdateClauseContext::cypherDelete() {
  return getRuleContext<MemgraphCypher::CypherDeleteContext>(0);
}

MemgraphCypher::ForeachContext* MemgraphCypher::UpdateClauseContext::foreach() {
  return getRuleContext<MemgraphCypher::ForeachContext>(0);
}


size_t MemgraphCypher::UpdateClauseContext::getRuleIndex() const {
  return MemgraphCypher::RuleUpdateClause;
}

void MemgraphCypher::UpdateClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdateClause(this);
}

void MemgraphCypher::UpdateClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdateClause(this);
}


std::any MemgraphCypher::UpdateClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitUpdateClause(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::UpdateClauseContext* MemgraphCypher::updateClause() {
  UpdateClauseContext *_localctx = _tracker.createInstance<UpdateClauseContext>(_ctx, getState());
  enterRule(_localctx, 14, MemgraphCypher::RuleUpdateClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(528);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MemgraphCypher::SET: {
        enterOuterAlt(_localctx, 1);
        setState(522);
        set();
        break;
      }

      case MemgraphCypher::REMOVE: {
        enterOuterAlt(_localctx, 2);
        setState(523);
        remove();
        break;
      }

      case MemgraphCypher::CREATE: {
        enterOuterAlt(_localctx, 3);
        setState(524);
        create();
        break;
      }

      case MemgraphCypher::MERGE: {
        enterOuterAlt(_localctx, 4);
        setState(525);
        merge();
        break;
      }

      case MemgraphCypher::DELETE:
      case MemgraphCypher::DETACH: {
        enterOuterAlt(_localctx, 5);
        setState(526);
        cypherDelete();
        break;
      }

      case MemgraphCypher::FOREACH: {
        enterOuterAlt(_localctx, 6);
        setState(527);
        foreach();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForeachContext ------------------------------------------------------------------

MemgraphCypher::ForeachContext::ForeachContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ForeachContext::FOREACH() {
  return getToken(MemgraphCypher::FOREACH, 0);
}

tree::TerminalNode* MemgraphCypher::ForeachContext::LPAREN() {
  return getToken(MemgraphCypher::LPAREN, 0);
}

MemgraphCypher::VariableContext* MemgraphCypher::ForeachContext::variable() {
  return getRuleContext<MemgraphCypher::VariableContext>(0);
}

tree::TerminalNode* MemgraphCypher::ForeachContext::IN() {
  return getToken(MemgraphCypher::IN, 0);
}

MemgraphCypher::ExpressionContext* MemgraphCypher::ForeachContext::expression() {
  return getRuleContext<MemgraphCypher::ExpressionContext>(0);
}

tree::TerminalNode* MemgraphCypher::ForeachContext::PIPE() {
  return getToken(MemgraphCypher::PIPE, 0);
}

tree::TerminalNode* MemgraphCypher::ForeachContext::RPAREN() {
  return getToken(MemgraphCypher::RPAREN, 0);
}

std::vector<MemgraphCypher::UpdateClauseContext *> MemgraphCypher::ForeachContext::updateClause() {
  return getRuleContexts<MemgraphCypher::UpdateClauseContext>();
}

MemgraphCypher::UpdateClauseContext* MemgraphCypher::ForeachContext::updateClause(size_t i) {
  return getRuleContext<MemgraphCypher::UpdateClauseContext>(i);
}


size_t MemgraphCypher::ForeachContext::getRuleIndex() const {
  return MemgraphCypher::RuleForeach;
}

void MemgraphCypher::ForeachContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForeach(this);
}

void MemgraphCypher::ForeachContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForeach(this);
}


std::any MemgraphCypher::ForeachContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitForeach(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ForeachContext* MemgraphCypher::foreach() {
  ForeachContext *_localctx = _tracker.createInstance<ForeachContext>(_ctx, getState());
  enterRule(_localctx, 16, MemgraphCypher::RuleForeach);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(530);
    match(MemgraphCypher::FOREACH);
    setState(531);
    match(MemgraphCypher::LPAREN);
    setState(532);
    variable();
    setState(533);
    match(MemgraphCypher::IN);
    setState(534);
    expression();
    setState(535);
    match(MemgraphCypher::PIPE);
    setState(537); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(536);
      updateClause();
      setState(539); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == MemgraphCypher::FOREACH || ((((_la - 138) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 138)) & ((1ULL << (MemgraphCypher::CREATE - 138))
      | (1ULL << (MemgraphCypher::DELETE - 138))
      | (1ULL << (MemgraphCypher::DETACH - 138))
      | (1ULL << (MemgraphCypher::MERGE - 138))
      | (1ULL << (MemgraphCypher::REMOVE - 138))
      | (1ULL << (MemgraphCypher::SET - 138)))) != 0));
    setState(541);
    match(MemgraphCypher::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StreamQueryContext ------------------------------------------------------------------

MemgraphCypher::StreamQueryContext::StreamQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::CheckStreamContext* MemgraphCypher::StreamQueryContext::checkStream() {
  return getRuleContext<MemgraphCypher::CheckStreamContext>(0);
}

MemgraphCypher::CreateStreamContext* MemgraphCypher::StreamQueryContext::createStream() {
  return getRuleContext<MemgraphCypher::CreateStreamContext>(0);
}

MemgraphCypher::DropStreamContext* MemgraphCypher::StreamQueryContext::dropStream() {
  return getRuleContext<MemgraphCypher::DropStreamContext>(0);
}

MemgraphCypher::StartStreamContext* MemgraphCypher::StreamQueryContext::startStream() {
  return getRuleContext<MemgraphCypher::StartStreamContext>(0);
}

MemgraphCypher::StartAllStreamsContext* MemgraphCypher::StreamQueryContext::startAllStreams() {
  return getRuleContext<MemgraphCypher::StartAllStreamsContext>(0);
}

MemgraphCypher::StopStreamContext* MemgraphCypher::StreamQueryContext::stopStream() {
  return getRuleContext<MemgraphCypher::StopStreamContext>(0);
}

MemgraphCypher::StopAllStreamsContext* MemgraphCypher::StreamQueryContext::stopAllStreams() {
  return getRuleContext<MemgraphCypher::StopAllStreamsContext>(0);
}

MemgraphCypher::ShowStreamsContext* MemgraphCypher::StreamQueryContext::showStreams() {
  return getRuleContext<MemgraphCypher::ShowStreamsContext>(0);
}


size_t MemgraphCypher::StreamQueryContext::getRuleIndex() const {
  return MemgraphCypher::RuleStreamQuery;
}

void MemgraphCypher::StreamQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStreamQuery(this);
}

void MemgraphCypher::StreamQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStreamQuery(this);
}


std::any MemgraphCypher::StreamQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitStreamQuery(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::StreamQueryContext* MemgraphCypher::streamQuery() {
  StreamQueryContext *_localctx = _tracker.createInstance<StreamQueryContext>(_ctx, getState());
  enterRule(_localctx, 18, MemgraphCypher::RuleStreamQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(551);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(543);
      checkStream();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(544);
      createStream();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(545);
      dropStream();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(546);
      startStream();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(547);
      startAllStreams();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(548);
      stopStream();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(549);
      stopAllStreams();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(550);
      showStreams();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SettingQueryContext ------------------------------------------------------------------

MemgraphCypher::SettingQueryContext::SettingQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::SetSettingContext* MemgraphCypher::SettingQueryContext::setSetting() {
  return getRuleContext<MemgraphCypher::SetSettingContext>(0);
}

MemgraphCypher::ShowSettingContext* MemgraphCypher::SettingQueryContext::showSetting() {
  return getRuleContext<MemgraphCypher::ShowSettingContext>(0);
}

MemgraphCypher::ShowSettingsContext* MemgraphCypher::SettingQueryContext::showSettings() {
  return getRuleContext<MemgraphCypher::ShowSettingsContext>(0);
}


size_t MemgraphCypher::SettingQueryContext::getRuleIndex() const {
  return MemgraphCypher::RuleSettingQuery;
}

void MemgraphCypher::SettingQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSettingQuery(this);
}

void MemgraphCypher::SettingQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSettingQuery(this);
}


std::any MemgraphCypher::SettingQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitSettingQuery(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::SettingQueryContext* MemgraphCypher::settingQuery() {
  SettingQueryContext *_localctx = _tracker.createInstance<SettingQueryContext>(_ctx, getState());
  enterRule(_localctx, 20, MemgraphCypher::RuleSettingQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(556);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(553);
      setSetting();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(554);
      showSetting();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(555);
      showSettings();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoadCsvContext ------------------------------------------------------------------

MemgraphCypher::LoadCsvContext::LoadCsvContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::LoadCsvContext::LOAD() {
  return getToken(MemgraphCypher::LOAD, 0);
}

tree::TerminalNode* MemgraphCypher::LoadCsvContext::CSV() {
  return getToken(MemgraphCypher::CSV, 0);
}

tree::TerminalNode* MemgraphCypher::LoadCsvContext::FROM() {
  return getToken(MemgraphCypher::FROM, 0);
}

MemgraphCypher::CsvFileContext* MemgraphCypher::LoadCsvContext::csvFile() {
  return getRuleContext<MemgraphCypher::CsvFileContext>(0);
}

tree::TerminalNode* MemgraphCypher::LoadCsvContext::HEADER() {
  return getToken(MemgraphCypher::HEADER, 0);
}

tree::TerminalNode* MemgraphCypher::LoadCsvContext::AS() {
  return getToken(MemgraphCypher::AS, 0);
}

MemgraphCypher::RowVarContext* MemgraphCypher::LoadCsvContext::rowVar() {
  return getRuleContext<MemgraphCypher::RowVarContext>(0);
}

tree::TerminalNode* MemgraphCypher::LoadCsvContext::WITH() {
  return getToken(MemgraphCypher::WITH, 0);
}

tree::TerminalNode* MemgraphCypher::LoadCsvContext::NO() {
  return getToken(MemgraphCypher::NO, 0);
}

tree::TerminalNode* MemgraphCypher::LoadCsvContext::IGNORE() {
  return getToken(MemgraphCypher::IGNORE, 0);
}

tree::TerminalNode* MemgraphCypher::LoadCsvContext::BAD() {
  return getToken(MemgraphCypher::BAD, 0);
}

tree::TerminalNode* MemgraphCypher::LoadCsvContext::DELIMITER() {
  return getToken(MemgraphCypher::DELIMITER, 0);
}

MemgraphCypher::DelimiterContext* MemgraphCypher::LoadCsvContext::delimiter() {
  return getRuleContext<MemgraphCypher::DelimiterContext>(0);
}

tree::TerminalNode* MemgraphCypher::LoadCsvContext::QUOTE() {
  return getToken(MemgraphCypher::QUOTE, 0);
}

MemgraphCypher::QuoteContext* MemgraphCypher::LoadCsvContext::quote() {
  return getRuleContext<MemgraphCypher::QuoteContext>(0);
}


size_t MemgraphCypher::LoadCsvContext::getRuleIndex() const {
  return MemgraphCypher::RuleLoadCsv;
}

void MemgraphCypher::LoadCsvContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoadCsv(this);
}

void MemgraphCypher::LoadCsvContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoadCsv(this);
}


std::any MemgraphCypher::LoadCsvContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitLoadCsv(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::LoadCsvContext* MemgraphCypher::loadCsv() {
  LoadCsvContext *_localctx = _tracker.createInstance<LoadCsvContext>(_ctx, getState());
  enterRule(_localctx, 22, MemgraphCypher::RuleLoadCsv);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(558);
    match(MemgraphCypher::LOAD);
    setState(559);
    match(MemgraphCypher::CSV);
    setState(560);
    match(MemgraphCypher::FROM);
    setState(561);
    csvFile();
    setState(562);
    _la = _input->LA(1);
    if (!(_la == MemgraphCypher::NO || _la == MemgraphCypher::WITH)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(563);
    match(MemgraphCypher::HEADER);
    setState(566);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::IGNORE) {
      setState(564);
      match(MemgraphCypher::IGNORE);
      setState(565);
      match(MemgraphCypher::BAD);
    }
    setState(570);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::DELIMITER) {
      setState(568);
      match(MemgraphCypher::DELIMITER);
      setState(569);
      delimiter();
    }
    setState(574);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::QUOTE) {
      setState(572);
      match(MemgraphCypher::QUOTE);
      setState(573);
      quote();
    }
    setState(576);
    match(MemgraphCypher::AS);
    setState(577);
    rowVar();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CsvFileContext ------------------------------------------------------------------

MemgraphCypher::CsvFileContext::CsvFileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::LiteralContext* MemgraphCypher::CsvFileContext::literal() {
  return getRuleContext<MemgraphCypher::LiteralContext>(0);
}


size_t MemgraphCypher::CsvFileContext::getRuleIndex() const {
  return MemgraphCypher::RuleCsvFile;
}

void MemgraphCypher::CsvFileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCsvFile(this);
}

void MemgraphCypher::CsvFileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCsvFile(this);
}


std::any MemgraphCypher::CsvFileContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitCsvFile(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::CsvFileContext* MemgraphCypher::csvFile() {
  CsvFileContext *_localctx = _tracker.createInstance<CsvFileContext>(_ctx, getState());
  enterRule(_localctx, 24, MemgraphCypher::RuleCsvFile);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(579);
    literal();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DelimiterContext ------------------------------------------------------------------

MemgraphCypher::DelimiterContext::DelimiterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::LiteralContext* MemgraphCypher::DelimiterContext::literal() {
  return getRuleContext<MemgraphCypher::LiteralContext>(0);
}


size_t MemgraphCypher::DelimiterContext::getRuleIndex() const {
  return MemgraphCypher::RuleDelimiter;
}

void MemgraphCypher::DelimiterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelimiter(this);
}

void MemgraphCypher::DelimiterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelimiter(this);
}


std::any MemgraphCypher::DelimiterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitDelimiter(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::DelimiterContext* MemgraphCypher::delimiter() {
  DelimiterContext *_localctx = _tracker.createInstance<DelimiterContext>(_ctx, getState());
  enterRule(_localctx, 26, MemgraphCypher::RuleDelimiter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(581);
    literal();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuoteContext ------------------------------------------------------------------

MemgraphCypher::QuoteContext::QuoteContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::LiteralContext* MemgraphCypher::QuoteContext::literal() {
  return getRuleContext<MemgraphCypher::LiteralContext>(0);
}


size_t MemgraphCypher::QuoteContext::getRuleIndex() const {
  return MemgraphCypher::RuleQuote;
}

void MemgraphCypher::QuoteContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuote(this);
}

void MemgraphCypher::QuoteContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuote(this);
}


std::any MemgraphCypher::QuoteContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitQuote(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::QuoteContext* MemgraphCypher::quote() {
  QuoteContext *_localctx = _tracker.createInstance<QuoteContext>(_ctx, getState());
  enterRule(_localctx, 28, MemgraphCypher::RuleQuote);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(583);
    literal();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RowVarContext ------------------------------------------------------------------

MemgraphCypher::RowVarContext::RowVarContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::VariableContext* MemgraphCypher::RowVarContext::variable() {
  return getRuleContext<MemgraphCypher::VariableContext>(0);
}


size_t MemgraphCypher::RowVarContext::getRuleIndex() const {
  return MemgraphCypher::RuleRowVar;
}

void MemgraphCypher::RowVarContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRowVar(this);
}

void MemgraphCypher::RowVarContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRowVar(this);
}


std::any MemgraphCypher::RowVarContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitRowVar(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::RowVarContext* MemgraphCypher::rowVar() {
  RowVarContext *_localctx = _tracker.createInstance<RowVarContext>(_ctx, getState());
  enterRule(_localctx, 30, MemgraphCypher::RuleRowVar);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(585);
    variable();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserOrRoleNameContext ------------------------------------------------------------------

MemgraphCypher::UserOrRoleNameContext::UserOrRoleNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::SymbolicNameContext* MemgraphCypher::UserOrRoleNameContext::symbolicName() {
  return getRuleContext<MemgraphCypher::SymbolicNameContext>(0);
}


size_t MemgraphCypher::UserOrRoleNameContext::getRuleIndex() const {
  return MemgraphCypher::RuleUserOrRoleName;
}

void MemgraphCypher::UserOrRoleNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserOrRoleName(this);
}

void MemgraphCypher::UserOrRoleNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserOrRoleName(this);
}


std::any MemgraphCypher::UserOrRoleNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitUserOrRoleName(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::UserOrRoleNameContext* MemgraphCypher::userOrRoleName() {
  UserOrRoleNameContext *_localctx = _tracker.createInstance<UserOrRoleNameContext>(_ctx, getState());
  enterRule(_localctx, 32, MemgraphCypher::RuleUserOrRoleName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(587);
    symbolicName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateRoleContext ------------------------------------------------------------------

MemgraphCypher::CreateRoleContext::CreateRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::CreateRoleContext::CREATE() {
  return getToken(MemgraphCypher::CREATE, 0);
}

tree::TerminalNode* MemgraphCypher::CreateRoleContext::ROLE() {
  return getToken(MemgraphCypher::ROLE, 0);
}

MemgraphCypher::UserOrRoleNameContext* MemgraphCypher::CreateRoleContext::userOrRoleName() {
  return getRuleContext<MemgraphCypher::UserOrRoleNameContext>(0);
}


size_t MemgraphCypher::CreateRoleContext::getRuleIndex() const {
  return MemgraphCypher::RuleCreateRole;
}

void MemgraphCypher::CreateRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateRole(this);
}

void MemgraphCypher::CreateRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateRole(this);
}


std::any MemgraphCypher::CreateRoleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitCreateRole(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::CreateRoleContext* MemgraphCypher::createRole() {
  CreateRoleContext *_localctx = _tracker.createInstance<CreateRoleContext>(_ctx, getState());
  enterRule(_localctx, 34, MemgraphCypher::RuleCreateRole);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(589);
    match(MemgraphCypher::CREATE);
    setState(590);
    match(MemgraphCypher::ROLE);
    setState(591);
    antlrcpp::downCast<CreateRoleContext *>(_localctx)->role = userOrRoleName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropRoleContext ------------------------------------------------------------------

MemgraphCypher::DropRoleContext::DropRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::DropRoleContext::DROP() {
  return getToken(MemgraphCypher::DROP, 0);
}

tree::TerminalNode* MemgraphCypher::DropRoleContext::ROLE() {
  return getToken(MemgraphCypher::ROLE, 0);
}

MemgraphCypher::UserOrRoleNameContext* MemgraphCypher::DropRoleContext::userOrRoleName() {
  return getRuleContext<MemgraphCypher::UserOrRoleNameContext>(0);
}


size_t MemgraphCypher::DropRoleContext::getRuleIndex() const {
  return MemgraphCypher::RuleDropRole;
}

void MemgraphCypher::DropRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropRole(this);
}

void MemgraphCypher::DropRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropRole(this);
}


std::any MemgraphCypher::DropRoleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitDropRole(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::DropRoleContext* MemgraphCypher::dropRole() {
  DropRoleContext *_localctx = _tracker.createInstance<DropRoleContext>(_ctx, getState());
  enterRule(_localctx, 36, MemgraphCypher::RuleDropRole);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(593);
    match(MemgraphCypher::DROP);
    setState(594);
    match(MemgraphCypher::ROLE);
    setState(595);
    antlrcpp::downCast<DropRoleContext *>(_localctx)->role = userOrRoleName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowRolesContext ------------------------------------------------------------------

MemgraphCypher::ShowRolesContext::ShowRolesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ShowRolesContext::SHOW() {
  return getToken(MemgraphCypher::SHOW, 0);
}

tree::TerminalNode* MemgraphCypher::ShowRolesContext::ROLES() {
  return getToken(MemgraphCypher::ROLES, 0);
}


size_t MemgraphCypher::ShowRolesContext::getRuleIndex() const {
  return MemgraphCypher::RuleShowRoles;
}

void MemgraphCypher::ShowRolesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowRoles(this);
}

void MemgraphCypher::ShowRolesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowRoles(this);
}


std::any MemgraphCypher::ShowRolesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitShowRoles(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ShowRolesContext* MemgraphCypher::showRoles() {
  ShowRolesContext *_localctx = _tracker.createInstance<ShowRolesContext>(_ctx, getState());
  enterRule(_localctx, 38, MemgraphCypher::RuleShowRoles);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(597);
    match(MemgraphCypher::SHOW);
    setState(598);
    match(MemgraphCypher::ROLES);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUserContext ------------------------------------------------------------------

MemgraphCypher::CreateUserContext::CreateUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::CreateUserContext::CREATE() {
  return getToken(MemgraphCypher::CREATE, 0);
}

tree::TerminalNode* MemgraphCypher::CreateUserContext::USER() {
  return getToken(MemgraphCypher::USER, 0);
}

MemgraphCypher::UserOrRoleNameContext* MemgraphCypher::CreateUserContext::userOrRoleName() {
  return getRuleContext<MemgraphCypher::UserOrRoleNameContext>(0);
}

tree::TerminalNode* MemgraphCypher::CreateUserContext::IDENTIFIED() {
  return getToken(MemgraphCypher::IDENTIFIED, 0);
}

tree::TerminalNode* MemgraphCypher::CreateUserContext::BY() {
  return getToken(MemgraphCypher::BY, 0);
}

MemgraphCypher::LiteralContext* MemgraphCypher::CreateUserContext::literal() {
  return getRuleContext<MemgraphCypher::LiteralContext>(0);
}


size_t MemgraphCypher::CreateUserContext::getRuleIndex() const {
  return MemgraphCypher::RuleCreateUser;
}

void MemgraphCypher::CreateUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUser(this);
}

void MemgraphCypher::CreateUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUser(this);
}


std::any MemgraphCypher::CreateUserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitCreateUser(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::CreateUserContext* MemgraphCypher::createUser() {
  CreateUserContext *_localctx = _tracker.createInstance<CreateUserContext>(_ctx, getState());
  enterRule(_localctx, 40, MemgraphCypher::RuleCreateUser);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(600);
    match(MemgraphCypher::CREATE);
    setState(601);
    match(MemgraphCypher::USER);
    setState(602);
    antlrcpp::downCast<CreateUserContext *>(_localctx)->user = userOrRoleName();
    setState(606);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::IDENTIFIED) {
      setState(603);
      match(MemgraphCypher::IDENTIFIED);
      setState(604);
      match(MemgraphCypher::BY);
      setState(605);
      antlrcpp::downCast<CreateUserContext *>(_localctx)->password = literal();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetPasswordContext ------------------------------------------------------------------

MemgraphCypher::SetPasswordContext::SetPasswordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::SetPasswordContext::SET() {
  return getToken(MemgraphCypher::SET, 0);
}

tree::TerminalNode* MemgraphCypher::SetPasswordContext::PASSWORD() {
  return getToken(MemgraphCypher::PASSWORD, 0);
}

tree::TerminalNode* MemgraphCypher::SetPasswordContext::FOR() {
  return getToken(MemgraphCypher::FOR, 0);
}

tree::TerminalNode* MemgraphCypher::SetPasswordContext::TO() {
  return getToken(MemgraphCypher::TO, 0);
}

MemgraphCypher::UserOrRoleNameContext* MemgraphCypher::SetPasswordContext::userOrRoleName() {
  return getRuleContext<MemgraphCypher::UserOrRoleNameContext>(0);
}

MemgraphCypher::LiteralContext* MemgraphCypher::SetPasswordContext::literal() {
  return getRuleContext<MemgraphCypher::LiteralContext>(0);
}


size_t MemgraphCypher::SetPasswordContext::getRuleIndex() const {
  return MemgraphCypher::RuleSetPassword;
}

void MemgraphCypher::SetPasswordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetPassword(this);
}

void MemgraphCypher::SetPasswordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetPassword(this);
}


std::any MemgraphCypher::SetPasswordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitSetPassword(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::SetPasswordContext* MemgraphCypher::setPassword() {
  SetPasswordContext *_localctx = _tracker.createInstance<SetPasswordContext>(_ctx, getState());
  enterRule(_localctx, 42, MemgraphCypher::RuleSetPassword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(608);
    match(MemgraphCypher::SET);
    setState(609);
    match(MemgraphCypher::PASSWORD);
    setState(610);
    match(MemgraphCypher::FOR);
    setState(611);
    antlrcpp::downCast<SetPasswordContext *>(_localctx)->user = userOrRoleName();
    setState(612);
    match(MemgraphCypher::TO);
    setState(613);
    antlrcpp::downCast<SetPasswordContext *>(_localctx)->password = literal();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropUserContext ------------------------------------------------------------------

MemgraphCypher::DropUserContext::DropUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::DropUserContext::DROP() {
  return getToken(MemgraphCypher::DROP, 0);
}

tree::TerminalNode* MemgraphCypher::DropUserContext::USER() {
  return getToken(MemgraphCypher::USER, 0);
}

MemgraphCypher::UserOrRoleNameContext* MemgraphCypher::DropUserContext::userOrRoleName() {
  return getRuleContext<MemgraphCypher::UserOrRoleNameContext>(0);
}


size_t MemgraphCypher::DropUserContext::getRuleIndex() const {
  return MemgraphCypher::RuleDropUser;
}

void MemgraphCypher::DropUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropUser(this);
}

void MemgraphCypher::DropUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropUser(this);
}


std::any MemgraphCypher::DropUserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitDropUser(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::DropUserContext* MemgraphCypher::dropUser() {
  DropUserContext *_localctx = _tracker.createInstance<DropUserContext>(_ctx, getState());
  enterRule(_localctx, 44, MemgraphCypher::RuleDropUser);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(615);
    match(MemgraphCypher::DROP);
    setState(616);
    match(MemgraphCypher::USER);
    setState(617);
    antlrcpp::downCast<DropUserContext *>(_localctx)->user = userOrRoleName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowUsersContext ------------------------------------------------------------------

MemgraphCypher::ShowUsersContext::ShowUsersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ShowUsersContext::SHOW() {
  return getToken(MemgraphCypher::SHOW, 0);
}

tree::TerminalNode* MemgraphCypher::ShowUsersContext::USERS() {
  return getToken(MemgraphCypher::USERS, 0);
}


size_t MemgraphCypher::ShowUsersContext::getRuleIndex() const {
  return MemgraphCypher::RuleShowUsers;
}

void MemgraphCypher::ShowUsersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowUsers(this);
}

void MemgraphCypher::ShowUsersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowUsers(this);
}


std::any MemgraphCypher::ShowUsersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitShowUsers(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ShowUsersContext* MemgraphCypher::showUsers() {
  ShowUsersContext *_localctx = _tracker.createInstance<ShowUsersContext>(_ctx, getState());
  enterRule(_localctx, 46, MemgraphCypher::RuleShowUsers);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(619);
    match(MemgraphCypher::SHOW);
    setState(620);
    match(MemgraphCypher::USERS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetRoleContext ------------------------------------------------------------------

MemgraphCypher::SetRoleContext::SetRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::SetRoleContext::SET() {
  return getToken(MemgraphCypher::SET, 0);
}

tree::TerminalNode* MemgraphCypher::SetRoleContext::ROLE() {
  return getToken(MemgraphCypher::ROLE, 0);
}

tree::TerminalNode* MemgraphCypher::SetRoleContext::FOR() {
  return getToken(MemgraphCypher::FOR, 0);
}

tree::TerminalNode* MemgraphCypher::SetRoleContext::TO() {
  return getToken(MemgraphCypher::TO, 0);
}

std::vector<MemgraphCypher::UserOrRoleNameContext *> MemgraphCypher::SetRoleContext::userOrRoleName() {
  return getRuleContexts<MemgraphCypher::UserOrRoleNameContext>();
}

MemgraphCypher::UserOrRoleNameContext* MemgraphCypher::SetRoleContext::userOrRoleName(size_t i) {
  return getRuleContext<MemgraphCypher::UserOrRoleNameContext>(i);
}


size_t MemgraphCypher::SetRoleContext::getRuleIndex() const {
  return MemgraphCypher::RuleSetRole;
}

void MemgraphCypher::SetRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetRole(this);
}

void MemgraphCypher::SetRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetRole(this);
}


std::any MemgraphCypher::SetRoleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitSetRole(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::SetRoleContext* MemgraphCypher::setRole() {
  SetRoleContext *_localctx = _tracker.createInstance<SetRoleContext>(_ctx, getState());
  enterRule(_localctx, 48, MemgraphCypher::RuleSetRole);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(622);
    match(MemgraphCypher::SET);
    setState(623);
    match(MemgraphCypher::ROLE);
    setState(624);
    match(MemgraphCypher::FOR);
    setState(625);
    antlrcpp::downCast<SetRoleContext *>(_localctx)->user = userOrRoleName();
    setState(626);
    match(MemgraphCypher::TO);
    setState(627);
    antlrcpp::downCast<SetRoleContext *>(_localctx)->role = userOrRoleName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClearRoleContext ------------------------------------------------------------------

MemgraphCypher::ClearRoleContext::ClearRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ClearRoleContext::CLEAR() {
  return getToken(MemgraphCypher::CLEAR, 0);
}

tree::TerminalNode* MemgraphCypher::ClearRoleContext::ROLE() {
  return getToken(MemgraphCypher::ROLE, 0);
}

tree::TerminalNode* MemgraphCypher::ClearRoleContext::FOR() {
  return getToken(MemgraphCypher::FOR, 0);
}

MemgraphCypher::UserOrRoleNameContext* MemgraphCypher::ClearRoleContext::userOrRoleName() {
  return getRuleContext<MemgraphCypher::UserOrRoleNameContext>(0);
}


size_t MemgraphCypher::ClearRoleContext::getRuleIndex() const {
  return MemgraphCypher::RuleClearRole;
}

void MemgraphCypher::ClearRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClearRole(this);
}

void MemgraphCypher::ClearRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClearRole(this);
}


std::any MemgraphCypher::ClearRoleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitClearRole(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ClearRoleContext* MemgraphCypher::clearRole() {
  ClearRoleContext *_localctx = _tracker.createInstance<ClearRoleContext>(_ctx, getState());
  enterRule(_localctx, 50, MemgraphCypher::RuleClearRole);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(629);
    match(MemgraphCypher::CLEAR);
    setState(630);
    match(MemgraphCypher::ROLE);
    setState(631);
    match(MemgraphCypher::FOR);
    setState(632);
    antlrcpp::downCast<ClearRoleContext *>(_localctx)->user = userOrRoleName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantPrivilegeContext ------------------------------------------------------------------

MemgraphCypher::GrantPrivilegeContext::GrantPrivilegeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::GrantPrivilegeContext::GRANT() {
  return getToken(MemgraphCypher::GRANT, 0);
}

tree::TerminalNode* MemgraphCypher::GrantPrivilegeContext::TO() {
  return getToken(MemgraphCypher::TO, 0);
}

MemgraphCypher::UserOrRoleNameContext* MemgraphCypher::GrantPrivilegeContext::userOrRoleName() {
  return getRuleContext<MemgraphCypher::UserOrRoleNameContext>(0);
}

tree::TerminalNode* MemgraphCypher::GrantPrivilegeContext::ALL() {
  return getToken(MemgraphCypher::ALL, 0);
}

tree::TerminalNode* MemgraphCypher::GrantPrivilegeContext::PRIVILEGES() {
  return getToken(MemgraphCypher::PRIVILEGES, 0);
}

MemgraphCypher::PrivilegeListContext* MemgraphCypher::GrantPrivilegeContext::privilegeList() {
  return getRuleContext<MemgraphCypher::PrivilegeListContext>(0);
}


size_t MemgraphCypher::GrantPrivilegeContext::getRuleIndex() const {
  return MemgraphCypher::RuleGrantPrivilege;
}

void MemgraphCypher::GrantPrivilegeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrantPrivilege(this);
}

void MemgraphCypher::GrantPrivilegeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrantPrivilege(this);
}


std::any MemgraphCypher::GrantPrivilegeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitGrantPrivilege(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::GrantPrivilegeContext* MemgraphCypher::grantPrivilege() {
  GrantPrivilegeContext *_localctx = _tracker.createInstance<GrantPrivilegeContext>(_ctx, getState());
  enterRule(_localctx, 52, MemgraphCypher::RuleGrantPrivilege);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(634);
    match(MemgraphCypher::GRANT);
    setState(638);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MemgraphCypher::ALL: {
        setState(635);
        match(MemgraphCypher::ALL);
        setState(636);
        match(MemgraphCypher::PRIVILEGES);
        break;
      }

      case MemgraphCypher::AUTH:
      case MemgraphCypher::CONFIG:
      case MemgraphCypher::DUMP:
      case MemgraphCypher::DURABILITY:
      case MemgraphCypher::FREE_MEMORY:
      case MemgraphCypher::MODULE_READ:
      case MemgraphCypher::MODULE_WRITE:
      case MemgraphCypher::READ_FILE:
      case MemgraphCypher::REPLICATION:
      case MemgraphCypher::STATS:
      case MemgraphCypher::STREAM:
      case MemgraphCypher::TRIGGER:
      case MemgraphCypher::WEBSOCKET:
      case MemgraphCypher::CONSTRAINT:
      case MemgraphCypher::CREATE:
      case MemgraphCypher::DELETE:
      case MemgraphCypher::INDEX:
      case MemgraphCypher::MATCH:
      case MemgraphCypher::MERGE:
      case MemgraphCypher::REMOVE:
      case MemgraphCypher::SET: {
        setState(637);
        antlrcpp::downCast<GrantPrivilegeContext *>(_localctx)->privileges = privilegeList();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(640);
    match(MemgraphCypher::TO);
    setState(641);
    antlrcpp::downCast<GrantPrivilegeContext *>(_localctx)->userOrRole = userOrRoleName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DenyPrivilegeContext ------------------------------------------------------------------

MemgraphCypher::DenyPrivilegeContext::DenyPrivilegeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::DenyPrivilegeContext::DENY() {
  return getToken(MemgraphCypher::DENY, 0);
}

tree::TerminalNode* MemgraphCypher::DenyPrivilegeContext::TO() {
  return getToken(MemgraphCypher::TO, 0);
}

MemgraphCypher::UserOrRoleNameContext* MemgraphCypher::DenyPrivilegeContext::userOrRoleName() {
  return getRuleContext<MemgraphCypher::UserOrRoleNameContext>(0);
}

tree::TerminalNode* MemgraphCypher::DenyPrivilegeContext::ALL() {
  return getToken(MemgraphCypher::ALL, 0);
}

tree::TerminalNode* MemgraphCypher::DenyPrivilegeContext::PRIVILEGES() {
  return getToken(MemgraphCypher::PRIVILEGES, 0);
}

MemgraphCypher::PrivilegeListContext* MemgraphCypher::DenyPrivilegeContext::privilegeList() {
  return getRuleContext<MemgraphCypher::PrivilegeListContext>(0);
}


size_t MemgraphCypher::DenyPrivilegeContext::getRuleIndex() const {
  return MemgraphCypher::RuleDenyPrivilege;
}

void MemgraphCypher::DenyPrivilegeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDenyPrivilege(this);
}

void MemgraphCypher::DenyPrivilegeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDenyPrivilege(this);
}


std::any MemgraphCypher::DenyPrivilegeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitDenyPrivilege(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::DenyPrivilegeContext* MemgraphCypher::denyPrivilege() {
  DenyPrivilegeContext *_localctx = _tracker.createInstance<DenyPrivilegeContext>(_ctx, getState());
  enterRule(_localctx, 54, MemgraphCypher::RuleDenyPrivilege);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(643);
    match(MemgraphCypher::DENY);
    setState(647);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MemgraphCypher::ALL: {
        setState(644);
        match(MemgraphCypher::ALL);
        setState(645);
        match(MemgraphCypher::PRIVILEGES);
        break;
      }

      case MemgraphCypher::AUTH:
      case MemgraphCypher::CONFIG:
      case MemgraphCypher::DUMP:
      case MemgraphCypher::DURABILITY:
      case MemgraphCypher::FREE_MEMORY:
      case MemgraphCypher::MODULE_READ:
      case MemgraphCypher::MODULE_WRITE:
      case MemgraphCypher::READ_FILE:
      case MemgraphCypher::REPLICATION:
      case MemgraphCypher::STATS:
      case MemgraphCypher::STREAM:
      case MemgraphCypher::TRIGGER:
      case MemgraphCypher::WEBSOCKET:
      case MemgraphCypher::CONSTRAINT:
      case MemgraphCypher::CREATE:
      case MemgraphCypher::DELETE:
      case MemgraphCypher::INDEX:
      case MemgraphCypher::MATCH:
      case MemgraphCypher::MERGE:
      case MemgraphCypher::REMOVE:
      case MemgraphCypher::SET: {
        setState(646);
        antlrcpp::downCast<DenyPrivilegeContext *>(_localctx)->privileges = privilegeList();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(649);
    match(MemgraphCypher::TO);
    setState(650);
    antlrcpp::downCast<DenyPrivilegeContext *>(_localctx)->userOrRole = userOrRoleName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RevokePrivilegeContext ------------------------------------------------------------------

MemgraphCypher::RevokePrivilegeContext::RevokePrivilegeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::RevokePrivilegeContext::REVOKE() {
  return getToken(MemgraphCypher::REVOKE, 0);
}

tree::TerminalNode* MemgraphCypher::RevokePrivilegeContext::FROM() {
  return getToken(MemgraphCypher::FROM, 0);
}

MemgraphCypher::UserOrRoleNameContext* MemgraphCypher::RevokePrivilegeContext::userOrRoleName() {
  return getRuleContext<MemgraphCypher::UserOrRoleNameContext>(0);
}

tree::TerminalNode* MemgraphCypher::RevokePrivilegeContext::ALL() {
  return getToken(MemgraphCypher::ALL, 0);
}

tree::TerminalNode* MemgraphCypher::RevokePrivilegeContext::PRIVILEGES() {
  return getToken(MemgraphCypher::PRIVILEGES, 0);
}

MemgraphCypher::PrivilegeListContext* MemgraphCypher::RevokePrivilegeContext::privilegeList() {
  return getRuleContext<MemgraphCypher::PrivilegeListContext>(0);
}


size_t MemgraphCypher::RevokePrivilegeContext::getRuleIndex() const {
  return MemgraphCypher::RuleRevokePrivilege;
}

void MemgraphCypher::RevokePrivilegeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRevokePrivilege(this);
}

void MemgraphCypher::RevokePrivilegeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRevokePrivilege(this);
}


std::any MemgraphCypher::RevokePrivilegeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitRevokePrivilege(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::RevokePrivilegeContext* MemgraphCypher::revokePrivilege() {
  RevokePrivilegeContext *_localctx = _tracker.createInstance<RevokePrivilegeContext>(_ctx, getState());
  enterRule(_localctx, 56, MemgraphCypher::RuleRevokePrivilege);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(652);
    match(MemgraphCypher::REVOKE);
    setState(656);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MemgraphCypher::ALL: {
        setState(653);
        match(MemgraphCypher::ALL);
        setState(654);
        match(MemgraphCypher::PRIVILEGES);
        break;
      }

      case MemgraphCypher::AUTH:
      case MemgraphCypher::CONFIG:
      case MemgraphCypher::DUMP:
      case MemgraphCypher::DURABILITY:
      case MemgraphCypher::FREE_MEMORY:
      case MemgraphCypher::MODULE_READ:
      case MemgraphCypher::MODULE_WRITE:
      case MemgraphCypher::READ_FILE:
      case MemgraphCypher::REPLICATION:
      case MemgraphCypher::STATS:
      case MemgraphCypher::STREAM:
      case MemgraphCypher::TRIGGER:
      case MemgraphCypher::WEBSOCKET:
      case MemgraphCypher::CONSTRAINT:
      case MemgraphCypher::CREATE:
      case MemgraphCypher::DELETE:
      case MemgraphCypher::INDEX:
      case MemgraphCypher::MATCH:
      case MemgraphCypher::MERGE:
      case MemgraphCypher::REMOVE:
      case MemgraphCypher::SET: {
        setState(655);
        antlrcpp::downCast<RevokePrivilegeContext *>(_localctx)->privileges = privilegeList();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(658);
    match(MemgraphCypher::FROM);
    setState(659);
    antlrcpp::downCast<RevokePrivilegeContext *>(_localctx)->userOrRole = userOrRoleName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrivilegeContext ------------------------------------------------------------------

MemgraphCypher::PrivilegeContext::PrivilegeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::PrivilegeContext::CREATE() {
  return getToken(MemgraphCypher::CREATE, 0);
}

tree::TerminalNode* MemgraphCypher::PrivilegeContext::DELETE() {
  return getToken(MemgraphCypher::DELETE, 0);
}

tree::TerminalNode* MemgraphCypher::PrivilegeContext::MATCH() {
  return getToken(MemgraphCypher::MATCH, 0);
}

tree::TerminalNode* MemgraphCypher::PrivilegeContext::MERGE() {
  return getToken(MemgraphCypher::MERGE, 0);
}

tree::TerminalNode* MemgraphCypher::PrivilegeContext::SET() {
  return getToken(MemgraphCypher::SET, 0);
}

tree::TerminalNode* MemgraphCypher::PrivilegeContext::REMOVE() {
  return getToken(MemgraphCypher::REMOVE, 0);
}

tree::TerminalNode* MemgraphCypher::PrivilegeContext::INDEX() {
  return getToken(MemgraphCypher::INDEX, 0);
}

tree::TerminalNode* MemgraphCypher::PrivilegeContext::STATS() {
  return getToken(MemgraphCypher::STATS, 0);
}

tree::TerminalNode* MemgraphCypher::PrivilegeContext::AUTH() {
  return getToken(MemgraphCypher::AUTH, 0);
}

tree::TerminalNode* MemgraphCypher::PrivilegeContext::CONSTRAINT() {
  return getToken(MemgraphCypher::CONSTRAINT, 0);
}

tree::TerminalNode* MemgraphCypher::PrivilegeContext::DUMP() {
  return getToken(MemgraphCypher::DUMP, 0);
}

tree::TerminalNode* MemgraphCypher::PrivilegeContext::REPLICATION() {
  return getToken(MemgraphCypher::REPLICATION, 0);
}

tree::TerminalNode* MemgraphCypher::PrivilegeContext::READ_FILE() {
  return getToken(MemgraphCypher::READ_FILE, 0);
}

tree::TerminalNode* MemgraphCypher::PrivilegeContext::FREE_MEMORY() {
  return getToken(MemgraphCypher::FREE_MEMORY, 0);
}

tree::TerminalNode* MemgraphCypher::PrivilegeContext::TRIGGER() {
  return getToken(MemgraphCypher::TRIGGER, 0);
}

tree::TerminalNode* MemgraphCypher::PrivilegeContext::CONFIG() {
  return getToken(MemgraphCypher::CONFIG, 0);
}

tree::TerminalNode* MemgraphCypher::PrivilegeContext::DURABILITY() {
  return getToken(MemgraphCypher::DURABILITY, 0);
}

tree::TerminalNode* MemgraphCypher::PrivilegeContext::STREAM() {
  return getToken(MemgraphCypher::STREAM, 0);
}

tree::TerminalNode* MemgraphCypher::PrivilegeContext::MODULE_READ() {
  return getToken(MemgraphCypher::MODULE_READ, 0);
}

tree::TerminalNode* MemgraphCypher::PrivilegeContext::MODULE_WRITE() {
  return getToken(MemgraphCypher::MODULE_WRITE, 0);
}

tree::TerminalNode* MemgraphCypher::PrivilegeContext::WEBSOCKET() {
  return getToken(MemgraphCypher::WEBSOCKET, 0);
}


size_t MemgraphCypher::PrivilegeContext::getRuleIndex() const {
  return MemgraphCypher::RulePrivilege;
}

void MemgraphCypher::PrivilegeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrivilege(this);
}

void MemgraphCypher::PrivilegeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrivilege(this);
}


std::any MemgraphCypher::PrivilegeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitPrivilege(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::PrivilegeContext* MemgraphCypher::privilege() {
  PrivilegeContext *_localctx = _tracker.createInstance<PrivilegeContext>(_ctx, getState());
  enterRule(_localctx, 58, MemgraphCypher::RulePrivilege);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(661);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MemgraphCypher::AUTH)
      | (1ULL << MemgraphCypher::CONFIG)
      | (1ULL << MemgraphCypher::DUMP)
      | (1ULL << MemgraphCypher::DURABILITY)
      | (1ULL << MemgraphCypher::FREE_MEMORY)
      | (1ULL << MemgraphCypher::MODULE_READ)
      | (1ULL << MemgraphCypher::MODULE_WRITE)
      | (1ULL << MemgraphCypher::READ_FILE)
      | (1ULL << MemgraphCypher::REPLICATION))) != 0) || ((((_la - 72) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 72)) & ((1ULL << (MemgraphCypher::STATS - 72))
      | (1ULL << (MemgraphCypher::STREAM - 72))
      | (1ULL << (MemgraphCypher::TRIGGER - 72))
      | (1ULL << (MemgraphCypher::WEBSOCKET - 72))
      | (1ULL << (MemgraphCypher::CONSTRAINT - 72)))) != 0) || ((((_la - 138) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 138)) & ((1ULL << (MemgraphCypher::CREATE - 138))
      | (1ULL << (MemgraphCypher::DELETE - 138))
      | (1ULL << (MemgraphCypher::INDEX - 138))
      | (1ULL << (MemgraphCypher::MATCH - 138))
      | (1ULL << (MemgraphCypher::MERGE - 138))
      | (1ULL << (MemgraphCypher::REMOVE - 138))
      | (1ULL << (MemgraphCypher::SET - 138)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrivilegeListContext ------------------------------------------------------------------

MemgraphCypher::PrivilegeListContext::PrivilegeListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MemgraphCypher::PrivilegeContext *> MemgraphCypher::PrivilegeListContext::privilege() {
  return getRuleContexts<MemgraphCypher::PrivilegeContext>();
}

MemgraphCypher::PrivilegeContext* MemgraphCypher::PrivilegeListContext::privilege(size_t i) {
  return getRuleContext<MemgraphCypher::PrivilegeContext>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::PrivilegeListContext::COMMA() {
  return getTokens(MemgraphCypher::COMMA);
}

tree::TerminalNode* MemgraphCypher::PrivilegeListContext::COMMA(size_t i) {
  return getToken(MemgraphCypher::COMMA, i);
}


size_t MemgraphCypher::PrivilegeListContext::getRuleIndex() const {
  return MemgraphCypher::RulePrivilegeList;
}

void MemgraphCypher::PrivilegeListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrivilegeList(this);
}

void MemgraphCypher::PrivilegeListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrivilegeList(this);
}


std::any MemgraphCypher::PrivilegeListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitPrivilegeList(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::PrivilegeListContext* MemgraphCypher::privilegeList() {
  PrivilegeListContext *_localctx = _tracker.createInstance<PrivilegeListContext>(_ctx, getState());
  enterRule(_localctx, 60, MemgraphCypher::RulePrivilegeList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(663);
    privilege();
    setState(668);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::COMMA) {
      setState(664);
      match(MemgraphCypher::COMMA);
      setState(665);
      privilege();
      setState(670);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowPrivilegesContext ------------------------------------------------------------------

MemgraphCypher::ShowPrivilegesContext::ShowPrivilegesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ShowPrivilegesContext::SHOW() {
  return getToken(MemgraphCypher::SHOW, 0);
}

tree::TerminalNode* MemgraphCypher::ShowPrivilegesContext::PRIVILEGES() {
  return getToken(MemgraphCypher::PRIVILEGES, 0);
}

tree::TerminalNode* MemgraphCypher::ShowPrivilegesContext::FOR() {
  return getToken(MemgraphCypher::FOR, 0);
}

MemgraphCypher::UserOrRoleNameContext* MemgraphCypher::ShowPrivilegesContext::userOrRoleName() {
  return getRuleContext<MemgraphCypher::UserOrRoleNameContext>(0);
}


size_t MemgraphCypher::ShowPrivilegesContext::getRuleIndex() const {
  return MemgraphCypher::RuleShowPrivileges;
}

void MemgraphCypher::ShowPrivilegesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowPrivileges(this);
}

void MemgraphCypher::ShowPrivilegesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowPrivileges(this);
}


std::any MemgraphCypher::ShowPrivilegesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitShowPrivileges(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ShowPrivilegesContext* MemgraphCypher::showPrivileges() {
  ShowPrivilegesContext *_localctx = _tracker.createInstance<ShowPrivilegesContext>(_ctx, getState());
  enterRule(_localctx, 62, MemgraphCypher::RuleShowPrivileges);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(671);
    match(MemgraphCypher::SHOW);
    setState(672);
    match(MemgraphCypher::PRIVILEGES);
    setState(673);
    match(MemgraphCypher::FOR);
    setState(674);
    antlrcpp::downCast<ShowPrivilegesContext *>(_localctx)->userOrRole = userOrRoleName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowRoleForUserContext ------------------------------------------------------------------

MemgraphCypher::ShowRoleForUserContext::ShowRoleForUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ShowRoleForUserContext::SHOW() {
  return getToken(MemgraphCypher::SHOW, 0);
}

tree::TerminalNode* MemgraphCypher::ShowRoleForUserContext::ROLE() {
  return getToken(MemgraphCypher::ROLE, 0);
}

tree::TerminalNode* MemgraphCypher::ShowRoleForUserContext::FOR() {
  return getToken(MemgraphCypher::FOR, 0);
}

MemgraphCypher::UserOrRoleNameContext* MemgraphCypher::ShowRoleForUserContext::userOrRoleName() {
  return getRuleContext<MemgraphCypher::UserOrRoleNameContext>(0);
}


size_t MemgraphCypher::ShowRoleForUserContext::getRuleIndex() const {
  return MemgraphCypher::RuleShowRoleForUser;
}

void MemgraphCypher::ShowRoleForUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowRoleForUser(this);
}

void MemgraphCypher::ShowRoleForUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowRoleForUser(this);
}


std::any MemgraphCypher::ShowRoleForUserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitShowRoleForUser(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ShowRoleForUserContext* MemgraphCypher::showRoleForUser() {
  ShowRoleForUserContext *_localctx = _tracker.createInstance<ShowRoleForUserContext>(_ctx, getState());
  enterRule(_localctx, 64, MemgraphCypher::RuleShowRoleForUser);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(676);
    match(MemgraphCypher::SHOW);
    setState(677);
    match(MemgraphCypher::ROLE);
    setState(678);
    match(MemgraphCypher::FOR);
    setState(679);
    antlrcpp::downCast<ShowRoleForUserContext *>(_localctx)->user = userOrRoleName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowUsersForRoleContext ------------------------------------------------------------------

MemgraphCypher::ShowUsersForRoleContext::ShowUsersForRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ShowUsersForRoleContext::SHOW() {
  return getToken(MemgraphCypher::SHOW, 0);
}

tree::TerminalNode* MemgraphCypher::ShowUsersForRoleContext::USERS() {
  return getToken(MemgraphCypher::USERS, 0);
}

tree::TerminalNode* MemgraphCypher::ShowUsersForRoleContext::FOR() {
  return getToken(MemgraphCypher::FOR, 0);
}

MemgraphCypher::UserOrRoleNameContext* MemgraphCypher::ShowUsersForRoleContext::userOrRoleName() {
  return getRuleContext<MemgraphCypher::UserOrRoleNameContext>(0);
}


size_t MemgraphCypher::ShowUsersForRoleContext::getRuleIndex() const {
  return MemgraphCypher::RuleShowUsersForRole;
}

void MemgraphCypher::ShowUsersForRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowUsersForRole(this);
}

void MemgraphCypher::ShowUsersForRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowUsersForRole(this);
}


std::any MemgraphCypher::ShowUsersForRoleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitShowUsersForRole(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ShowUsersForRoleContext* MemgraphCypher::showUsersForRole() {
  ShowUsersForRoleContext *_localctx = _tracker.createInstance<ShowUsersForRoleContext>(_ctx, getState());
  enterRule(_localctx, 66, MemgraphCypher::RuleShowUsersForRole);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(681);
    match(MemgraphCypher::SHOW);
    setState(682);
    match(MemgraphCypher::USERS);
    setState(683);
    match(MemgraphCypher::FOR);
    setState(684);
    antlrcpp::downCast<ShowUsersForRoleContext *>(_localctx)->role = userOrRoleName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DumpQueryContext ------------------------------------------------------------------

MemgraphCypher::DumpQueryContext::DumpQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::DumpQueryContext::DUMP() {
  return getToken(MemgraphCypher::DUMP, 0);
}

tree::TerminalNode* MemgraphCypher::DumpQueryContext::DATABASE() {
  return getToken(MemgraphCypher::DATABASE, 0);
}


size_t MemgraphCypher::DumpQueryContext::getRuleIndex() const {
  return MemgraphCypher::RuleDumpQuery;
}

void MemgraphCypher::DumpQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDumpQuery(this);
}

void MemgraphCypher::DumpQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDumpQuery(this);
}


std::any MemgraphCypher::DumpQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitDumpQuery(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::DumpQueryContext* MemgraphCypher::dumpQuery() {
  DumpQueryContext *_localctx = _tracker.createInstance<DumpQueryContext>(_ctx, getState());
  enterRule(_localctx, 68, MemgraphCypher::RuleDumpQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(686);
    match(MemgraphCypher::DUMP);
    setState(687);
    match(MemgraphCypher::DATABASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetReplicationRoleContext ------------------------------------------------------------------

MemgraphCypher::SetReplicationRoleContext::SetReplicationRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::SetReplicationRoleContext::SET() {
  return getToken(MemgraphCypher::SET, 0);
}

tree::TerminalNode* MemgraphCypher::SetReplicationRoleContext::REPLICATION() {
  return getToken(MemgraphCypher::REPLICATION, 0);
}

tree::TerminalNode* MemgraphCypher::SetReplicationRoleContext::ROLE() {
  return getToken(MemgraphCypher::ROLE, 0);
}

tree::TerminalNode* MemgraphCypher::SetReplicationRoleContext::TO() {
  return getToken(MemgraphCypher::TO, 0);
}

tree::TerminalNode* MemgraphCypher::SetReplicationRoleContext::MAIN() {
  return getToken(MemgraphCypher::MAIN, 0);
}

tree::TerminalNode* MemgraphCypher::SetReplicationRoleContext::REPLICA() {
  return getToken(MemgraphCypher::REPLICA, 0);
}

tree::TerminalNode* MemgraphCypher::SetReplicationRoleContext::WITH() {
  return getToken(MemgraphCypher::WITH, 0);
}

tree::TerminalNode* MemgraphCypher::SetReplicationRoleContext::PORT() {
  return getToken(MemgraphCypher::PORT, 0);
}

MemgraphCypher::LiteralContext* MemgraphCypher::SetReplicationRoleContext::literal() {
  return getRuleContext<MemgraphCypher::LiteralContext>(0);
}


size_t MemgraphCypher::SetReplicationRoleContext::getRuleIndex() const {
  return MemgraphCypher::RuleSetReplicationRole;
}

void MemgraphCypher::SetReplicationRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetReplicationRole(this);
}

void MemgraphCypher::SetReplicationRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetReplicationRole(this);
}


std::any MemgraphCypher::SetReplicationRoleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitSetReplicationRole(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::SetReplicationRoleContext* MemgraphCypher::setReplicationRole() {
  SetReplicationRoleContext *_localctx = _tracker.createInstance<SetReplicationRoleContext>(_ctx, getState());
  enterRule(_localctx, 70, MemgraphCypher::RuleSetReplicationRole);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(689);
    match(MemgraphCypher::SET);
    setState(690);
    match(MemgraphCypher::REPLICATION);
    setState(691);
    match(MemgraphCypher::ROLE);
    setState(692);
    match(MemgraphCypher::TO);
    setState(693);
    _la = _input->LA(1);
    if (!(_la == MemgraphCypher::MAIN

    || _la == MemgraphCypher::REPLICA)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(697);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::WITH) {
      setState(694);
      match(MemgraphCypher::WITH);
      setState(695);
      match(MemgraphCypher::PORT);
      setState(696);
      antlrcpp::downCast<SetReplicationRoleContext *>(_localctx)->port = literal();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowReplicationRoleContext ------------------------------------------------------------------

MemgraphCypher::ShowReplicationRoleContext::ShowReplicationRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ShowReplicationRoleContext::SHOW() {
  return getToken(MemgraphCypher::SHOW, 0);
}

tree::TerminalNode* MemgraphCypher::ShowReplicationRoleContext::REPLICATION() {
  return getToken(MemgraphCypher::REPLICATION, 0);
}

tree::TerminalNode* MemgraphCypher::ShowReplicationRoleContext::ROLE() {
  return getToken(MemgraphCypher::ROLE, 0);
}


size_t MemgraphCypher::ShowReplicationRoleContext::getRuleIndex() const {
  return MemgraphCypher::RuleShowReplicationRole;
}

void MemgraphCypher::ShowReplicationRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowReplicationRole(this);
}

void MemgraphCypher::ShowReplicationRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowReplicationRole(this);
}


std::any MemgraphCypher::ShowReplicationRoleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitShowReplicationRole(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ShowReplicationRoleContext* MemgraphCypher::showReplicationRole() {
  ShowReplicationRoleContext *_localctx = _tracker.createInstance<ShowReplicationRoleContext>(_ctx, getState());
  enterRule(_localctx, 72, MemgraphCypher::RuleShowReplicationRole);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(699);
    match(MemgraphCypher::SHOW);
    setState(700);
    match(MemgraphCypher::REPLICATION);
    setState(701);
    match(MemgraphCypher::ROLE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplicaNameContext ------------------------------------------------------------------

MemgraphCypher::ReplicaNameContext::ReplicaNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::SymbolicNameContext* MemgraphCypher::ReplicaNameContext::symbolicName() {
  return getRuleContext<MemgraphCypher::SymbolicNameContext>(0);
}


size_t MemgraphCypher::ReplicaNameContext::getRuleIndex() const {
  return MemgraphCypher::RuleReplicaName;
}

void MemgraphCypher::ReplicaNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplicaName(this);
}

void MemgraphCypher::ReplicaNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplicaName(this);
}


std::any MemgraphCypher::ReplicaNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitReplicaName(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ReplicaNameContext* MemgraphCypher::replicaName() {
  ReplicaNameContext *_localctx = _tracker.createInstance<ReplicaNameContext>(_ctx, getState());
  enterRule(_localctx, 74, MemgraphCypher::RuleReplicaName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(703);
    symbolicName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SocketAddressContext ------------------------------------------------------------------

MemgraphCypher::SocketAddressContext::SocketAddressContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::LiteralContext* MemgraphCypher::SocketAddressContext::literal() {
  return getRuleContext<MemgraphCypher::LiteralContext>(0);
}


size_t MemgraphCypher::SocketAddressContext::getRuleIndex() const {
  return MemgraphCypher::RuleSocketAddress;
}

void MemgraphCypher::SocketAddressContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSocketAddress(this);
}

void MemgraphCypher::SocketAddressContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSocketAddress(this);
}


std::any MemgraphCypher::SocketAddressContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitSocketAddress(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::SocketAddressContext* MemgraphCypher::socketAddress() {
  SocketAddressContext *_localctx = _tracker.createInstance<SocketAddressContext>(_ctx, getState());
  enterRule(_localctx, 76, MemgraphCypher::RuleSocketAddress);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(705);
    literal();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RegisterReplicaContext ------------------------------------------------------------------

MemgraphCypher::RegisterReplicaContext::RegisterReplicaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::RegisterReplicaContext::REGISTER() {
  return getToken(MemgraphCypher::REGISTER, 0);
}

tree::TerminalNode* MemgraphCypher::RegisterReplicaContext::REPLICA() {
  return getToken(MemgraphCypher::REPLICA, 0);
}

MemgraphCypher::ReplicaNameContext* MemgraphCypher::RegisterReplicaContext::replicaName() {
  return getRuleContext<MemgraphCypher::ReplicaNameContext>(0);
}

tree::TerminalNode* MemgraphCypher::RegisterReplicaContext::TO() {
  return getToken(MemgraphCypher::TO, 0);
}

MemgraphCypher::SocketAddressContext* MemgraphCypher::RegisterReplicaContext::socketAddress() {
  return getRuleContext<MemgraphCypher::SocketAddressContext>(0);
}

tree::TerminalNode* MemgraphCypher::RegisterReplicaContext::SYNC() {
  return getToken(MemgraphCypher::SYNC, 0);
}

tree::TerminalNode* MemgraphCypher::RegisterReplicaContext::ASYNC() {
  return getToken(MemgraphCypher::ASYNC, 0);
}


size_t MemgraphCypher::RegisterReplicaContext::getRuleIndex() const {
  return MemgraphCypher::RuleRegisterReplica;
}

void MemgraphCypher::RegisterReplicaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRegisterReplica(this);
}

void MemgraphCypher::RegisterReplicaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRegisterReplica(this);
}


std::any MemgraphCypher::RegisterReplicaContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitRegisterReplica(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::RegisterReplicaContext* MemgraphCypher::registerReplica() {
  RegisterReplicaContext *_localctx = _tracker.createInstance<RegisterReplicaContext>(_ctx, getState());
  enterRule(_localctx, 78, MemgraphCypher::RuleRegisterReplica);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(707);
    match(MemgraphCypher::REGISTER);
    setState(708);
    match(MemgraphCypher::REPLICA);
    setState(709);
    replicaName();
    setState(710);
    _la = _input->LA(1);
    if (!(_la == MemgraphCypher::ASYNC || _la == MemgraphCypher::SYNC)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(711);
    match(MemgraphCypher::TO);
    setState(712);
    socketAddress();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropReplicaContext ------------------------------------------------------------------

MemgraphCypher::DropReplicaContext::DropReplicaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::DropReplicaContext::DROP() {
  return getToken(MemgraphCypher::DROP, 0);
}

tree::TerminalNode* MemgraphCypher::DropReplicaContext::REPLICA() {
  return getToken(MemgraphCypher::REPLICA, 0);
}

MemgraphCypher::ReplicaNameContext* MemgraphCypher::DropReplicaContext::replicaName() {
  return getRuleContext<MemgraphCypher::ReplicaNameContext>(0);
}


size_t MemgraphCypher::DropReplicaContext::getRuleIndex() const {
  return MemgraphCypher::RuleDropReplica;
}

void MemgraphCypher::DropReplicaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropReplica(this);
}

void MemgraphCypher::DropReplicaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropReplica(this);
}


std::any MemgraphCypher::DropReplicaContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitDropReplica(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::DropReplicaContext* MemgraphCypher::dropReplica() {
  DropReplicaContext *_localctx = _tracker.createInstance<DropReplicaContext>(_ctx, getState());
  enterRule(_localctx, 80, MemgraphCypher::RuleDropReplica);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(714);
    match(MemgraphCypher::DROP);
    setState(715);
    match(MemgraphCypher::REPLICA);
    setState(716);
    replicaName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowReplicasContext ------------------------------------------------------------------

MemgraphCypher::ShowReplicasContext::ShowReplicasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ShowReplicasContext::SHOW() {
  return getToken(MemgraphCypher::SHOW, 0);
}

tree::TerminalNode* MemgraphCypher::ShowReplicasContext::REPLICAS() {
  return getToken(MemgraphCypher::REPLICAS, 0);
}


size_t MemgraphCypher::ShowReplicasContext::getRuleIndex() const {
  return MemgraphCypher::RuleShowReplicas;
}

void MemgraphCypher::ShowReplicasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowReplicas(this);
}

void MemgraphCypher::ShowReplicasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowReplicas(this);
}


std::any MemgraphCypher::ShowReplicasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitShowReplicas(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ShowReplicasContext* MemgraphCypher::showReplicas() {
  ShowReplicasContext *_localctx = _tracker.createInstance<ShowReplicasContext>(_ctx, getState());
  enterRule(_localctx, 82, MemgraphCypher::RuleShowReplicas);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(718);
    match(MemgraphCypher::SHOW);
    setState(719);
    match(MemgraphCypher::REPLICAS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockPathQueryContext ------------------------------------------------------------------

MemgraphCypher::LockPathQueryContext::LockPathQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::LockPathQueryContext::DATA() {
  return getToken(MemgraphCypher::DATA, 0);
}

tree::TerminalNode* MemgraphCypher::LockPathQueryContext::DIRECTORY() {
  return getToken(MemgraphCypher::DIRECTORY, 0);
}

tree::TerminalNode* MemgraphCypher::LockPathQueryContext::LOCK() {
  return getToken(MemgraphCypher::LOCK, 0);
}

tree::TerminalNode* MemgraphCypher::LockPathQueryContext::UNLOCK() {
  return getToken(MemgraphCypher::UNLOCK, 0);
}


size_t MemgraphCypher::LockPathQueryContext::getRuleIndex() const {
  return MemgraphCypher::RuleLockPathQuery;
}

void MemgraphCypher::LockPathQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockPathQuery(this);
}

void MemgraphCypher::LockPathQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockPathQuery(this);
}


std::any MemgraphCypher::LockPathQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitLockPathQuery(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::LockPathQueryContext* MemgraphCypher::lockPathQuery() {
  LockPathQueryContext *_localctx = _tracker.createInstance<LockPathQueryContext>(_ctx, getState());
  enterRule(_localctx, 84, MemgraphCypher::RuleLockPathQuery);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(721);
    _la = _input->LA(1);
    if (!(_la == MemgraphCypher::LOCK

    || _la == MemgraphCypher::UNLOCK)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(722);
    match(MemgraphCypher::DATA);
    setState(723);
    match(MemgraphCypher::DIRECTORY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FreeMemoryQueryContext ------------------------------------------------------------------

MemgraphCypher::FreeMemoryQueryContext::FreeMemoryQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::FreeMemoryQueryContext::FREE() {
  return getToken(MemgraphCypher::FREE, 0);
}

tree::TerminalNode* MemgraphCypher::FreeMemoryQueryContext::MEMORY() {
  return getToken(MemgraphCypher::MEMORY, 0);
}


size_t MemgraphCypher::FreeMemoryQueryContext::getRuleIndex() const {
  return MemgraphCypher::RuleFreeMemoryQuery;
}

void MemgraphCypher::FreeMemoryQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFreeMemoryQuery(this);
}

void MemgraphCypher::FreeMemoryQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFreeMemoryQuery(this);
}


std::any MemgraphCypher::FreeMemoryQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitFreeMemoryQuery(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::FreeMemoryQueryContext* MemgraphCypher::freeMemoryQuery() {
  FreeMemoryQueryContext *_localctx = _tracker.createInstance<FreeMemoryQueryContext>(_ctx, getState());
  enterRule(_localctx, 86, MemgraphCypher::RuleFreeMemoryQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(725);
    match(MemgraphCypher::FREE);
    setState(726);
    match(MemgraphCypher::MEMORY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerNameContext ------------------------------------------------------------------

MemgraphCypher::TriggerNameContext::TriggerNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::SymbolicNameContext* MemgraphCypher::TriggerNameContext::symbolicName() {
  return getRuleContext<MemgraphCypher::SymbolicNameContext>(0);
}


size_t MemgraphCypher::TriggerNameContext::getRuleIndex() const {
  return MemgraphCypher::RuleTriggerName;
}

void MemgraphCypher::TriggerNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTriggerName(this);
}

void MemgraphCypher::TriggerNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTriggerName(this);
}


std::any MemgraphCypher::TriggerNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitTriggerName(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::TriggerNameContext* MemgraphCypher::triggerName() {
  TriggerNameContext *_localctx = _tracker.createInstance<TriggerNameContext>(_ctx, getState());
  enterRule(_localctx, 88, MemgraphCypher::RuleTriggerName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(728);
    symbolicName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerStatementContext ------------------------------------------------------------------

MemgraphCypher::TriggerStatementContext::TriggerStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MemgraphCypher::TriggerStatementContext::getRuleIndex() const {
  return MemgraphCypher::RuleTriggerStatement;
}

void MemgraphCypher::TriggerStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTriggerStatement(this);
}

void MemgraphCypher::TriggerStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTriggerStatement(this);
}


std::any MemgraphCypher::TriggerStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitTriggerStatement(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::TriggerStatementContext* MemgraphCypher::triggerStatement() {
  TriggerStatementContext *_localctx = _tracker.createInstance<TriggerStatementContext>(_ctx, getState());
  enterRule(_localctx, 90, MemgraphCypher::RuleTriggerStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(733);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(730);
        matchWildcard(); 
      }
      setState(735);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmptyVertexContext ------------------------------------------------------------------

MemgraphCypher::EmptyVertexContext::EmptyVertexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::EmptyVertexContext::LPAREN() {
  return getToken(MemgraphCypher::LPAREN, 0);
}

tree::TerminalNode* MemgraphCypher::EmptyVertexContext::RPAREN() {
  return getToken(MemgraphCypher::RPAREN, 0);
}


size_t MemgraphCypher::EmptyVertexContext::getRuleIndex() const {
  return MemgraphCypher::RuleEmptyVertex;
}

void MemgraphCypher::EmptyVertexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEmptyVertex(this);
}

void MemgraphCypher::EmptyVertexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEmptyVertex(this);
}


std::any MemgraphCypher::EmptyVertexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitEmptyVertex(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::EmptyVertexContext* MemgraphCypher::emptyVertex() {
  EmptyVertexContext *_localctx = _tracker.createInstance<EmptyVertexContext>(_ctx, getState());
  enterRule(_localctx, 92, MemgraphCypher::RuleEmptyVertex);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(736);
    match(MemgraphCypher::LPAREN);
    setState(737);
    match(MemgraphCypher::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmptyEdgeContext ------------------------------------------------------------------

MemgraphCypher::EmptyEdgeContext::EmptyEdgeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MemgraphCypher::DashContext *> MemgraphCypher::EmptyEdgeContext::dash() {
  return getRuleContexts<MemgraphCypher::DashContext>();
}

MemgraphCypher::DashContext* MemgraphCypher::EmptyEdgeContext::dash(size_t i) {
  return getRuleContext<MemgraphCypher::DashContext>(i);
}

MemgraphCypher::RightArrowHeadContext* MemgraphCypher::EmptyEdgeContext::rightArrowHead() {
  return getRuleContext<MemgraphCypher::RightArrowHeadContext>(0);
}


size_t MemgraphCypher::EmptyEdgeContext::getRuleIndex() const {
  return MemgraphCypher::RuleEmptyEdge;
}

void MemgraphCypher::EmptyEdgeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEmptyEdge(this);
}

void MemgraphCypher::EmptyEdgeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEmptyEdge(this);
}


std::any MemgraphCypher::EmptyEdgeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitEmptyEdge(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::EmptyEdgeContext* MemgraphCypher::emptyEdge() {
  EmptyEdgeContext *_localctx = _tracker.createInstance<EmptyEdgeContext>(_ctx, getState());
  enterRule(_localctx, 94, MemgraphCypher::RuleEmptyEdge);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(739);
    dash();
    setState(740);
    dash();
    setState(741);
    rightArrowHead();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTriggerContext ------------------------------------------------------------------

MemgraphCypher::CreateTriggerContext::CreateTriggerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MemgraphCypher::CreateTriggerContext::CREATE() {
  return getTokens(MemgraphCypher::CREATE);
}

tree::TerminalNode* MemgraphCypher::CreateTriggerContext::CREATE(size_t i) {
  return getToken(MemgraphCypher::CREATE, i);
}

tree::TerminalNode* MemgraphCypher::CreateTriggerContext::TRIGGER() {
  return getToken(MemgraphCypher::TRIGGER, 0);
}

MemgraphCypher::TriggerNameContext* MemgraphCypher::CreateTriggerContext::triggerName() {
  return getRuleContext<MemgraphCypher::TriggerNameContext>(0);
}

tree::TerminalNode* MemgraphCypher::CreateTriggerContext::COMMIT() {
  return getToken(MemgraphCypher::COMMIT, 0);
}

tree::TerminalNode* MemgraphCypher::CreateTriggerContext::EXECUTE() {
  return getToken(MemgraphCypher::EXECUTE, 0);
}

MemgraphCypher::TriggerStatementContext* MemgraphCypher::CreateTriggerContext::triggerStatement() {
  return getRuleContext<MemgraphCypher::TriggerStatementContext>(0);
}

tree::TerminalNode* MemgraphCypher::CreateTriggerContext::AFTER() {
  return getToken(MemgraphCypher::AFTER, 0);
}

tree::TerminalNode* MemgraphCypher::CreateTriggerContext::BEFORE() {
  return getToken(MemgraphCypher::BEFORE, 0);
}

tree::TerminalNode* MemgraphCypher::CreateTriggerContext::ON() {
  return getToken(MemgraphCypher::ON, 0);
}

tree::TerminalNode* MemgraphCypher::CreateTriggerContext::UPDATE() {
  return getToken(MemgraphCypher::UPDATE, 0);
}

tree::TerminalNode* MemgraphCypher::CreateTriggerContext::DELETE() {
  return getToken(MemgraphCypher::DELETE, 0);
}

MemgraphCypher::EmptyVertexContext* MemgraphCypher::CreateTriggerContext::emptyVertex() {
  return getRuleContext<MemgraphCypher::EmptyVertexContext>(0);
}

MemgraphCypher::EmptyEdgeContext* MemgraphCypher::CreateTriggerContext::emptyEdge() {
  return getRuleContext<MemgraphCypher::EmptyEdgeContext>(0);
}


size_t MemgraphCypher::CreateTriggerContext::getRuleIndex() const {
  return MemgraphCypher::RuleCreateTrigger;
}

void MemgraphCypher::CreateTriggerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTrigger(this);
}

void MemgraphCypher::CreateTriggerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTrigger(this);
}


std::any MemgraphCypher::CreateTriggerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitCreateTrigger(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::CreateTriggerContext* MemgraphCypher::createTrigger() {
  CreateTriggerContext *_localctx = _tracker.createInstance<CreateTriggerContext>(_ctx, getState());
  enterRule(_localctx, 96, MemgraphCypher::RuleCreateTrigger);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(743);
    match(MemgraphCypher::CREATE);
    setState(744);
    match(MemgraphCypher::TRIGGER);
    setState(745);
    triggerName();
    setState(752);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::ON) {
      setState(746);
      match(MemgraphCypher::ON);
      setState(749);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MemgraphCypher::LPAREN: {
          setState(747);
          emptyVertex();
          break;
        }

        case MemgraphCypher::MINUS:
        case MemgraphCypher::DashPart: {
          setState(748);
          emptyEdge();
          break;
        }

        case MemgraphCypher::UPDATE:
        case MemgraphCypher::CREATE:
        case MemgraphCypher::DELETE: {
          break;
        }

      default:
        break;
      }
      setState(751);
      _la = _input->LA(1);
      if (!(((((_la - 86) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 86)) & ((1ULL << (MemgraphCypher::UPDATE - 86))
        | (1ULL << (MemgraphCypher::CREATE - 86))
        | (1ULL << (MemgraphCypher::DELETE - 86)))) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(754);
    _la = _input->LA(1);
    if (!(_la == MemgraphCypher::AFTER

    || _la == MemgraphCypher::BEFORE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(755);
    match(MemgraphCypher::COMMIT);
    setState(756);
    match(MemgraphCypher::EXECUTE);
    setState(757);
    triggerStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropTriggerContext ------------------------------------------------------------------

MemgraphCypher::DropTriggerContext::DropTriggerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::DropTriggerContext::DROP() {
  return getToken(MemgraphCypher::DROP, 0);
}

tree::TerminalNode* MemgraphCypher::DropTriggerContext::TRIGGER() {
  return getToken(MemgraphCypher::TRIGGER, 0);
}

MemgraphCypher::TriggerNameContext* MemgraphCypher::DropTriggerContext::triggerName() {
  return getRuleContext<MemgraphCypher::TriggerNameContext>(0);
}


size_t MemgraphCypher::DropTriggerContext::getRuleIndex() const {
  return MemgraphCypher::RuleDropTrigger;
}

void MemgraphCypher::DropTriggerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropTrigger(this);
}

void MemgraphCypher::DropTriggerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropTrigger(this);
}


std::any MemgraphCypher::DropTriggerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitDropTrigger(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::DropTriggerContext* MemgraphCypher::dropTrigger() {
  DropTriggerContext *_localctx = _tracker.createInstance<DropTriggerContext>(_ctx, getState());
  enterRule(_localctx, 98, MemgraphCypher::RuleDropTrigger);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(759);
    match(MemgraphCypher::DROP);
    setState(760);
    match(MemgraphCypher::TRIGGER);
    setState(761);
    triggerName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowTriggersContext ------------------------------------------------------------------

MemgraphCypher::ShowTriggersContext::ShowTriggersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ShowTriggersContext::SHOW() {
  return getToken(MemgraphCypher::SHOW, 0);
}

tree::TerminalNode* MemgraphCypher::ShowTriggersContext::TRIGGERS() {
  return getToken(MemgraphCypher::TRIGGERS, 0);
}


size_t MemgraphCypher::ShowTriggersContext::getRuleIndex() const {
  return MemgraphCypher::RuleShowTriggers;
}

void MemgraphCypher::ShowTriggersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowTriggers(this);
}

void MemgraphCypher::ShowTriggersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowTriggers(this);
}


std::any MemgraphCypher::ShowTriggersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitShowTriggers(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ShowTriggersContext* MemgraphCypher::showTriggers() {
  ShowTriggersContext *_localctx = _tracker.createInstance<ShowTriggersContext>(_ctx, getState());
  enterRule(_localctx, 100, MemgraphCypher::RuleShowTriggers);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(763);
    match(MemgraphCypher::SHOW);
    setState(764);
    match(MemgraphCypher::TRIGGERS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IsolationLevelContext ------------------------------------------------------------------

MemgraphCypher::IsolationLevelContext::IsolationLevelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::IsolationLevelContext::SNAPSHOT() {
  return getToken(MemgraphCypher::SNAPSHOT, 0);
}

tree::TerminalNode* MemgraphCypher::IsolationLevelContext::ISOLATION() {
  return getToken(MemgraphCypher::ISOLATION, 0);
}

tree::TerminalNode* MemgraphCypher::IsolationLevelContext::READ() {
  return getToken(MemgraphCypher::READ, 0);
}

tree::TerminalNode* MemgraphCypher::IsolationLevelContext::COMMITTED() {
  return getToken(MemgraphCypher::COMMITTED, 0);
}

tree::TerminalNode* MemgraphCypher::IsolationLevelContext::UNCOMMITTED() {
  return getToken(MemgraphCypher::UNCOMMITTED, 0);
}


size_t MemgraphCypher::IsolationLevelContext::getRuleIndex() const {
  return MemgraphCypher::RuleIsolationLevel;
}

void MemgraphCypher::IsolationLevelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIsolationLevel(this);
}

void MemgraphCypher::IsolationLevelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIsolationLevel(this);
}


std::any MemgraphCypher::IsolationLevelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitIsolationLevel(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::IsolationLevelContext* MemgraphCypher::isolationLevel() {
  IsolationLevelContext *_localctx = _tracker.createInstance<IsolationLevelContext>(_ctx, getState());
  enterRule(_localctx, 102, MemgraphCypher::RuleIsolationLevel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(772);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(766);
      match(MemgraphCypher::SNAPSHOT);
      setState(767);
      match(MemgraphCypher::ISOLATION);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(768);
      match(MemgraphCypher::READ);
      setState(769);
      match(MemgraphCypher::COMMITTED);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(770);
      match(MemgraphCypher::READ);
      setState(771);
      match(MemgraphCypher::UNCOMMITTED);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IsolationLevelScopeContext ------------------------------------------------------------------

MemgraphCypher::IsolationLevelScopeContext::IsolationLevelScopeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::IsolationLevelScopeContext::GLOBAL() {
  return getToken(MemgraphCypher::GLOBAL, 0);
}

tree::TerminalNode* MemgraphCypher::IsolationLevelScopeContext::SESSION() {
  return getToken(MemgraphCypher::SESSION, 0);
}

tree::TerminalNode* MemgraphCypher::IsolationLevelScopeContext::NEXT() {
  return getToken(MemgraphCypher::NEXT, 0);
}


size_t MemgraphCypher::IsolationLevelScopeContext::getRuleIndex() const {
  return MemgraphCypher::RuleIsolationLevelScope;
}

void MemgraphCypher::IsolationLevelScopeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIsolationLevelScope(this);
}

void MemgraphCypher::IsolationLevelScopeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIsolationLevelScope(this);
}


std::any MemgraphCypher::IsolationLevelScopeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitIsolationLevelScope(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::IsolationLevelScopeContext* MemgraphCypher::isolationLevelScope() {
  IsolationLevelScopeContext *_localctx = _tracker.createInstance<IsolationLevelScopeContext>(_ctx, getState());
  enterRule(_localctx, 104, MemgraphCypher::RuleIsolationLevelScope);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(774);
    _la = _input->LA(1);
    if (!(((((_la - 35) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 35)) & ((1ULL << (MemgraphCypher::GLOBAL - 35))
      | (1ULL << (MemgraphCypher::NEXT - 35))
      | (1ULL << (MemgraphCypher::SESSION - 35)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IsolationLevelQueryContext ------------------------------------------------------------------

MemgraphCypher::IsolationLevelQueryContext::IsolationLevelQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::IsolationLevelQueryContext::SET() {
  return getToken(MemgraphCypher::SET, 0);
}

MemgraphCypher::IsolationLevelScopeContext* MemgraphCypher::IsolationLevelQueryContext::isolationLevelScope() {
  return getRuleContext<MemgraphCypher::IsolationLevelScopeContext>(0);
}

tree::TerminalNode* MemgraphCypher::IsolationLevelQueryContext::TRANSACTION() {
  return getToken(MemgraphCypher::TRANSACTION, 0);
}

tree::TerminalNode* MemgraphCypher::IsolationLevelQueryContext::ISOLATION() {
  return getToken(MemgraphCypher::ISOLATION, 0);
}

tree::TerminalNode* MemgraphCypher::IsolationLevelQueryContext::LEVEL() {
  return getToken(MemgraphCypher::LEVEL, 0);
}

MemgraphCypher::IsolationLevelContext* MemgraphCypher::IsolationLevelQueryContext::isolationLevel() {
  return getRuleContext<MemgraphCypher::IsolationLevelContext>(0);
}


size_t MemgraphCypher::IsolationLevelQueryContext::getRuleIndex() const {
  return MemgraphCypher::RuleIsolationLevelQuery;
}

void MemgraphCypher::IsolationLevelQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIsolationLevelQuery(this);
}

void MemgraphCypher::IsolationLevelQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIsolationLevelQuery(this);
}


std::any MemgraphCypher::IsolationLevelQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitIsolationLevelQuery(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::IsolationLevelQueryContext* MemgraphCypher::isolationLevelQuery() {
  IsolationLevelQueryContext *_localctx = _tracker.createInstance<IsolationLevelQueryContext>(_ctx, getState());
  enterRule(_localctx, 106, MemgraphCypher::RuleIsolationLevelQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(776);
    match(MemgraphCypher::SET);
    setState(777);
    isolationLevelScope();
    setState(778);
    match(MemgraphCypher::TRANSACTION);
    setState(779);
    match(MemgraphCypher::ISOLATION);
    setState(780);
    match(MemgraphCypher::LEVEL);
    setState(781);
    isolationLevel();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateSnapshotQueryContext ------------------------------------------------------------------

MemgraphCypher::CreateSnapshotQueryContext::CreateSnapshotQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::CreateSnapshotQueryContext::CREATE() {
  return getToken(MemgraphCypher::CREATE, 0);
}

tree::TerminalNode* MemgraphCypher::CreateSnapshotQueryContext::SNAPSHOT() {
  return getToken(MemgraphCypher::SNAPSHOT, 0);
}


size_t MemgraphCypher::CreateSnapshotQueryContext::getRuleIndex() const {
  return MemgraphCypher::RuleCreateSnapshotQuery;
}

void MemgraphCypher::CreateSnapshotQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateSnapshotQuery(this);
}

void MemgraphCypher::CreateSnapshotQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateSnapshotQuery(this);
}


std::any MemgraphCypher::CreateSnapshotQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitCreateSnapshotQuery(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::CreateSnapshotQueryContext* MemgraphCypher::createSnapshotQuery() {
  CreateSnapshotQueryContext *_localctx = _tracker.createInstance<CreateSnapshotQueryContext>(_ctx, getState());
  enterRule(_localctx, 108, MemgraphCypher::RuleCreateSnapshotQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(783);
    match(MemgraphCypher::CREATE);
    setState(784);
    match(MemgraphCypher::SNAPSHOT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StreamNameContext ------------------------------------------------------------------

MemgraphCypher::StreamNameContext::StreamNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::SymbolicNameContext* MemgraphCypher::StreamNameContext::symbolicName() {
  return getRuleContext<MemgraphCypher::SymbolicNameContext>(0);
}


size_t MemgraphCypher::StreamNameContext::getRuleIndex() const {
  return MemgraphCypher::RuleStreamName;
}

void MemgraphCypher::StreamNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStreamName(this);
}

void MemgraphCypher::StreamNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStreamName(this);
}


std::any MemgraphCypher::StreamNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitStreamName(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::StreamNameContext* MemgraphCypher::streamName() {
  StreamNameContext *_localctx = _tracker.createInstance<StreamNameContext>(_ctx, getState());
  enterRule(_localctx, 110, MemgraphCypher::RuleStreamName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(786);
    symbolicName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SymbolicNameWithMinusContext ------------------------------------------------------------------

MemgraphCypher::SymbolicNameWithMinusContext::SymbolicNameWithMinusContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MemgraphCypher::SymbolicNameContext *> MemgraphCypher::SymbolicNameWithMinusContext::symbolicName() {
  return getRuleContexts<MemgraphCypher::SymbolicNameContext>();
}

MemgraphCypher::SymbolicNameContext* MemgraphCypher::SymbolicNameWithMinusContext::symbolicName(size_t i) {
  return getRuleContext<MemgraphCypher::SymbolicNameContext>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::SymbolicNameWithMinusContext::MINUS() {
  return getTokens(MemgraphCypher::MINUS);
}

tree::TerminalNode* MemgraphCypher::SymbolicNameWithMinusContext::MINUS(size_t i) {
  return getToken(MemgraphCypher::MINUS, i);
}


size_t MemgraphCypher::SymbolicNameWithMinusContext::getRuleIndex() const {
  return MemgraphCypher::RuleSymbolicNameWithMinus;
}

void MemgraphCypher::SymbolicNameWithMinusContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSymbolicNameWithMinus(this);
}

void MemgraphCypher::SymbolicNameWithMinusContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSymbolicNameWithMinus(this);
}


std::any MemgraphCypher::SymbolicNameWithMinusContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitSymbolicNameWithMinus(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::SymbolicNameWithMinusContext* MemgraphCypher::symbolicNameWithMinus() {
  SymbolicNameWithMinusContext *_localctx = _tracker.createInstance<SymbolicNameWithMinusContext>(_ctx, getState());
  enterRule(_localctx, 112, MemgraphCypher::RuleSymbolicNameWithMinus);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(788);
    symbolicName();
    setState(793);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::MINUS) {
      setState(789);
      match(MemgraphCypher::MINUS);
      setState(790);
      symbolicName();
      setState(795);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SymbolicNameWithDotsAndMinusContext ------------------------------------------------------------------

MemgraphCypher::SymbolicNameWithDotsAndMinusContext::SymbolicNameWithDotsAndMinusContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MemgraphCypher::SymbolicNameWithMinusContext *> MemgraphCypher::SymbolicNameWithDotsAndMinusContext::symbolicNameWithMinus() {
  return getRuleContexts<MemgraphCypher::SymbolicNameWithMinusContext>();
}

MemgraphCypher::SymbolicNameWithMinusContext* MemgraphCypher::SymbolicNameWithDotsAndMinusContext::symbolicNameWithMinus(size_t i) {
  return getRuleContext<MemgraphCypher::SymbolicNameWithMinusContext>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::SymbolicNameWithDotsAndMinusContext::DOT() {
  return getTokens(MemgraphCypher::DOT);
}

tree::TerminalNode* MemgraphCypher::SymbolicNameWithDotsAndMinusContext::DOT(size_t i) {
  return getToken(MemgraphCypher::DOT, i);
}


size_t MemgraphCypher::SymbolicNameWithDotsAndMinusContext::getRuleIndex() const {
  return MemgraphCypher::RuleSymbolicNameWithDotsAndMinus;
}

void MemgraphCypher::SymbolicNameWithDotsAndMinusContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSymbolicNameWithDotsAndMinus(this);
}

void MemgraphCypher::SymbolicNameWithDotsAndMinusContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSymbolicNameWithDotsAndMinus(this);
}


std::any MemgraphCypher::SymbolicNameWithDotsAndMinusContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitSymbolicNameWithDotsAndMinus(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::SymbolicNameWithDotsAndMinusContext* MemgraphCypher::symbolicNameWithDotsAndMinus() {
  SymbolicNameWithDotsAndMinusContext *_localctx = _tracker.createInstance<SymbolicNameWithDotsAndMinusContext>(_ctx, getState());
  enterRule(_localctx, 114, MemgraphCypher::RuleSymbolicNameWithDotsAndMinus);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(796);
    symbolicNameWithMinus();
    setState(801);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::DOT) {
      setState(797);
      match(MemgraphCypher::DOT);
      setState(798);
      symbolicNameWithMinus();
      setState(803);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SymbolicTopicNamesContext ------------------------------------------------------------------

MemgraphCypher::SymbolicTopicNamesContext::SymbolicTopicNamesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MemgraphCypher::SymbolicNameWithDotsAndMinusContext *> MemgraphCypher::SymbolicTopicNamesContext::symbolicNameWithDotsAndMinus() {
  return getRuleContexts<MemgraphCypher::SymbolicNameWithDotsAndMinusContext>();
}

MemgraphCypher::SymbolicNameWithDotsAndMinusContext* MemgraphCypher::SymbolicTopicNamesContext::symbolicNameWithDotsAndMinus(size_t i) {
  return getRuleContext<MemgraphCypher::SymbolicNameWithDotsAndMinusContext>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::SymbolicTopicNamesContext::COMMA() {
  return getTokens(MemgraphCypher::COMMA);
}

tree::TerminalNode* MemgraphCypher::SymbolicTopicNamesContext::COMMA(size_t i) {
  return getToken(MemgraphCypher::COMMA, i);
}


size_t MemgraphCypher::SymbolicTopicNamesContext::getRuleIndex() const {
  return MemgraphCypher::RuleSymbolicTopicNames;
}

void MemgraphCypher::SymbolicTopicNamesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSymbolicTopicNames(this);
}

void MemgraphCypher::SymbolicTopicNamesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSymbolicTopicNames(this);
}


std::any MemgraphCypher::SymbolicTopicNamesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitSymbolicTopicNames(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::SymbolicTopicNamesContext* MemgraphCypher::symbolicTopicNames() {
  SymbolicTopicNamesContext *_localctx = _tracker.createInstance<SymbolicTopicNamesContext>(_ctx, getState());
  enterRule(_localctx, 116, MemgraphCypher::RuleSymbolicTopicNames);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(804);
    symbolicNameWithDotsAndMinus();
    setState(809);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::COMMA) {
      setState(805);
      match(MemgraphCypher::COMMA);
      setState(806);
      symbolicNameWithDotsAndMinus();
      setState(811);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TopicNamesContext ------------------------------------------------------------------

MemgraphCypher::TopicNamesContext::TopicNamesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::SymbolicTopicNamesContext* MemgraphCypher::TopicNamesContext::symbolicTopicNames() {
  return getRuleContext<MemgraphCypher::SymbolicTopicNamesContext>(0);
}

MemgraphCypher::LiteralContext* MemgraphCypher::TopicNamesContext::literal() {
  return getRuleContext<MemgraphCypher::LiteralContext>(0);
}


size_t MemgraphCypher::TopicNamesContext::getRuleIndex() const {
  return MemgraphCypher::RuleTopicNames;
}

void MemgraphCypher::TopicNamesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTopicNames(this);
}

void MemgraphCypher::TopicNamesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTopicNames(this);
}


std::any MemgraphCypher::TopicNamesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitTopicNames(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::TopicNamesContext* MemgraphCypher::topicNames() {
  TopicNamesContext *_localctx = _tracker.createInstance<TopicNamesContext>(_ctx, getState());
  enterRule(_localctx, 118, MemgraphCypher::RuleTopicNames);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(814);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(812);
      symbolicTopicNames();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(813);
      literal();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommonCreateStreamConfigContext ------------------------------------------------------------------

MemgraphCypher::CommonCreateStreamConfigContext::CommonCreateStreamConfigContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::CommonCreateStreamConfigContext::TRANSFORM() {
  return getToken(MemgraphCypher::TRANSFORM, 0);
}

MemgraphCypher::ProcedureNameContext* MemgraphCypher::CommonCreateStreamConfigContext::procedureName() {
  return getRuleContext<MemgraphCypher::ProcedureNameContext>(0);
}

tree::TerminalNode* MemgraphCypher::CommonCreateStreamConfigContext::BATCH_INTERVAL() {
  return getToken(MemgraphCypher::BATCH_INTERVAL, 0);
}

MemgraphCypher::LiteralContext* MemgraphCypher::CommonCreateStreamConfigContext::literal() {
  return getRuleContext<MemgraphCypher::LiteralContext>(0);
}

tree::TerminalNode* MemgraphCypher::CommonCreateStreamConfigContext::BATCH_SIZE() {
  return getToken(MemgraphCypher::BATCH_SIZE, 0);
}


size_t MemgraphCypher::CommonCreateStreamConfigContext::getRuleIndex() const {
  return MemgraphCypher::RuleCommonCreateStreamConfig;
}

void MemgraphCypher::CommonCreateStreamConfigContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommonCreateStreamConfig(this);
}

void MemgraphCypher::CommonCreateStreamConfigContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommonCreateStreamConfig(this);
}


std::any MemgraphCypher::CommonCreateStreamConfigContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitCommonCreateStreamConfig(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::CommonCreateStreamConfigContext* MemgraphCypher::commonCreateStreamConfig() {
  CommonCreateStreamConfigContext *_localctx = _tracker.createInstance<CommonCreateStreamConfigContext>(_ctx, getState());
  enterRule(_localctx, 120, MemgraphCypher::RuleCommonCreateStreamConfig);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(822);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MemgraphCypher::TRANSFORM: {
        enterOuterAlt(_localctx, 1);
        setState(816);
        match(MemgraphCypher::TRANSFORM);
        setState(817);
        antlrcpp::downCast<CommonCreateStreamConfigContext *>(_localctx)->transformationName = procedureName();
        break;
      }

      case MemgraphCypher::BATCH_INTERVAL: {
        enterOuterAlt(_localctx, 2);
        setState(818);
        match(MemgraphCypher::BATCH_INTERVAL);
        setState(819);
        antlrcpp::downCast<CommonCreateStreamConfigContext *>(_localctx)->batchInterval = literal();
        break;
      }

      case MemgraphCypher::BATCH_SIZE: {
        enterOuterAlt(_localctx, 3);
        setState(820);
        match(MemgraphCypher::BATCH_SIZE);
        setState(821);
        antlrcpp::downCast<CommonCreateStreamConfigContext *>(_localctx)->batchSize = literal();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateStreamContext ------------------------------------------------------------------

MemgraphCypher::CreateStreamContext::CreateStreamContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::KafkaCreateStreamContext* MemgraphCypher::CreateStreamContext::kafkaCreateStream() {
  return getRuleContext<MemgraphCypher::KafkaCreateStreamContext>(0);
}

MemgraphCypher::PulsarCreateStreamContext* MemgraphCypher::CreateStreamContext::pulsarCreateStream() {
  return getRuleContext<MemgraphCypher::PulsarCreateStreamContext>(0);
}


size_t MemgraphCypher::CreateStreamContext::getRuleIndex() const {
  return MemgraphCypher::RuleCreateStream;
}

void MemgraphCypher::CreateStreamContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateStream(this);
}

void MemgraphCypher::CreateStreamContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateStream(this);
}


std::any MemgraphCypher::CreateStreamContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitCreateStream(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::CreateStreamContext* MemgraphCypher::createStream() {
  CreateStreamContext *_localctx = _tracker.createInstance<CreateStreamContext>(_ctx, getState());
  enterRule(_localctx, 122, MemgraphCypher::RuleCreateStream);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(826);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(824);
      kafkaCreateStream();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(825);
      pulsarCreateStream();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConfigKeyValuePairContext ------------------------------------------------------------------

MemgraphCypher::ConfigKeyValuePairContext::ConfigKeyValuePairContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MemgraphCypher::LiteralContext *> MemgraphCypher::ConfigKeyValuePairContext::literal() {
  return getRuleContexts<MemgraphCypher::LiteralContext>();
}

MemgraphCypher::LiteralContext* MemgraphCypher::ConfigKeyValuePairContext::literal(size_t i) {
  return getRuleContext<MemgraphCypher::LiteralContext>(i);
}

tree::TerminalNode* MemgraphCypher::ConfigKeyValuePairContext::COLON() {
  return getToken(MemgraphCypher::COLON, 0);
}


size_t MemgraphCypher::ConfigKeyValuePairContext::getRuleIndex() const {
  return MemgraphCypher::RuleConfigKeyValuePair;
}

void MemgraphCypher::ConfigKeyValuePairContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConfigKeyValuePair(this);
}

void MemgraphCypher::ConfigKeyValuePairContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConfigKeyValuePair(this);
}


std::any MemgraphCypher::ConfigKeyValuePairContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitConfigKeyValuePair(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ConfigKeyValuePairContext* MemgraphCypher::configKeyValuePair() {
  ConfigKeyValuePairContext *_localctx = _tracker.createInstance<ConfigKeyValuePairContext>(_ctx, getState());
  enterRule(_localctx, 124, MemgraphCypher::RuleConfigKeyValuePair);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(828);
    literal();
    setState(829);
    match(MemgraphCypher::COLON);
    setState(830);
    literal();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConfigMapContext ------------------------------------------------------------------

MemgraphCypher::ConfigMapContext::ConfigMapContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ConfigMapContext::LBRACE() {
  return getToken(MemgraphCypher::LBRACE, 0);
}

tree::TerminalNode* MemgraphCypher::ConfigMapContext::RBRACE() {
  return getToken(MemgraphCypher::RBRACE, 0);
}

std::vector<MemgraphCypher::ConfigKeyValuePairContext *> MemgraphCypher::ConfigMapContext::configKeyValuePair() {
  return getRuleContexts<MemgraphCypher::ConfigKeyValuePairContext>();
}

MemgraphCypher::ConfigKeyValuePairContext* MemgraphCypher::ConfigMapContext::configKeyValuePair(size_t i) {
  return getRuleContext<MemgraphCypher::ConfigKeyValuePairContext>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::ConfigMapContext::COMMA() {
  return getTokens(MemgraphCypher::COMMA);
}

tree::TerminalNode* MemgraphCypher::ConfigMapContext::COMMA(size_t i) {
  return getToken(MemgraphCypher::COMMA, i);
}


size_t MemgraphCypher::ConfigMapContext::getRuleIndex() const {
  return MemgraphCypher::RuleConfigMap;
}

void MemgraphCypher::ConfigMapContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConfigMap(this);
}

void MemgraphCypher::ConfigMapContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConfigMap(this);
}


std::any MemgraphCypher::ConfigMapContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitConfigMap(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ConfigMapContext* MemgraphCypher::configMap() {
  ConfigMapContext *_localctx = _tracker.createInstance<ConfigMapContext>(_ctx, getState());
  enterRule(_localctx, 126, MemgraphCypher::RuleConfigMap);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(832);
    match(MemgraphCypher::LBRACE);
    setState(841);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 94) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 94)) & ((1ULL << (MemgraphCypher::LBRACK - 94))
      | (1ULL << (MemgraphCypher::LBRACE - 94))
      | (1ULL << (MemgraphCypher::CYPHERNULL - 94))
      | (1ULL << (MemgraphCypher::FALSE - 94)))) != 0) || ((((_la - 184) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 184)) & ((1ULL << (MemgraphCypher::TRUE - 184))
      | (1ULL << (MemgraphCypher::StringLiteral - 184))
      | (1ULL << (MemgraphCypher::DecimalLiteral - 184))
      | (1ULL << (MemgraphCypher::OctalLiteral - 184))
      | (1ULL << (MemgraphCypher::HexadecimalLiteral - 184))
      | (1ULL << (MemgraphCypher::FloatingLiteral - 184)))) != 0)) {
      setState(833);
      configKeyValuePair();
      setState(838);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MemgraphCypher::COMMA) {
        setState(834);
        match(MemgraphCypher::COMMA);
        setState(835);
        configKeyValuePair();
        setState(840);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(843);
    match(MemgraphCypher::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KafkaCreateStreamConfigContext ------------------------------------------------------------------

MemgraphCypher::KafkaCreateStreamConfigContext::KafkaCreateStreamConfigContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::KafkaCreateStreamConfigContext::TOPICS() {
  return getToken(MemgraphCypher::TOPICS, 0);
}

MemgraphCypher::TopicNamesContext* MemgraphCypher::KafkaCreateStreamConfigContext::topicNames() {
  return getRuleContext<MemgraphCypher::TopicNamesContext>(0);
}

tree::TerminalNode* MemgraphCypher::KafkaCreateStreamConfigContext::CONSUMER_GROUP() {
  return getToken(MemgraphCypher::CONSUMER_GROUP, 0);
}

MemgraphCypher::SymbolicNameWithDotsAndMinusContext* MemgraphCypher::KafkaCreateStreamConfigContext::symbolicNameWithDotsAndMinus() {
  return getRuleContext<MemgraphCypher::SymbolicNameWithDotsAndMinusContext>(0);
}

tree::TerminalNode* MemgraphCypher::KafkaCreateStreamConfigContext::BOOTSTRAP_SERVERS() {
  return getToken(MemgraphCypher::BOOTSTRAP_SERVERS, 0);
}

MemgraphCypher::LiteralContext* MemgraphCypher::KafkaCreateStreamConfigContext::literal() {
  return getRuleContext<MemgraphCypher::LiteralContext>(0);
}

tree::TerminalNode* MemgraphCypher::KafkaCreateStreamConfigContext::CONFIGS() {
  return getToken(MemgraphCypher::CONFIGS, 0);
}

MemgraphCypher::ConfigMapContext* MemgraphCypher::KafkaCreateStreamConfigContext::configMap() {
  return getRuleContext<MemgraphCypher::ConfigMapContext>(0);
}

tree::TerminalNode* MemgraphCypher::KafkaCreateStreamConfigContext::CREDENTIALS() {
  return getToken(MemgraphCypher::CREDENTIALS, 0);
}

MemgraphCypher::CommonCreateStreamConfigContext* MemgraphCypher::KafkaCreateStreamConfigContext::commonCreateStreamConfig() {
  return getRuleContext<MemgraphCypher::CommonCreateStreamConfigContext>(0);
}


size_t MemgraphCypher::KafkaCreateStreamConfigContext::getRuleIndex() const {
  return MemgraphCypher::RuleKafkaCreateStreamConfig;
}

void MemgraphCypher::KafkaCreateStreamConfigContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKafkaCreateStreamConfig(this);
}

void MemgraphCypher::KafkaCreateStreamConfigContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKafkaCreateStreamConfig(this);
}


std::any MemgraphCypher::KafkaCreateStreamConfigContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitKafkaCreateStreamConfig(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::KafkaCreateStreamConfigContext* MemgraphCypher::kafkaCreateStreamConfig() {
  KafkaCreateStreamConfigContext *_localctx = _tracker.createInstance<KafkaCreateStreamConfigContext>(_ctx, getState());
  enterRule(_localctx, 128, MemgraphCypher::RuleKafkaCreateStreamConfig);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(856);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MemgraphCypher::TOPICS: {
        enterOuterAlt(_localctx, 1);
        setState(845);
        match(MemgraphCypher::TOPICS);
        setState(846);
        topicNames();
        break;
      }

      case MemgraphCypher::CONSUMER_GROUP: {
        enterOuterAlt(_localctx, 2);
        setState(847);
        match(MemgraphCypher::CONSUMER_GROUP);
        setState(848);
        antlrcpp::downCast<KafkaCreateStreamConfigContext *>(_localctx)->consumerGroup = symbolicNameWithDotsAndMinus();
        break;
      }

      case MemgraphCypher::BOOTSTRAP_SERVERS: {
        enterOuterAlt(_localctx, 3);
        setState(849);
        match(MemgraphCypher::BOOTSTRAP_SERVERS);
        setState(850);
        antlrcpp::downCast<KafkaCreateStreamConfigContext *>(_localctx)->bootstrapServers = literal();
        break;
      }

      case MemgraphCypher::CONFIGS: {
        enterOuterAlt(_localctx, 4);
        setState(851);
        match(MemgraphCypher::CONFIGS);
        setState(852);
        antlrcpp::downCast<KafkaCreateStreamConfigContext *>(_localctx)->configsMap = configMap();
        break;
      }

      case MemgraphCypher::CREDENTIALS: {
        enterOuterAlt(_localctx, 5);
        setState(853);
        match(MemgraphCypher::CREDENTIALS);
        setState(854);
        antlrcpp::downCast<KafkaCreateStreamConfigContext *>(_localctx)->credentialsMap = configMap();
        break;
      }

      case MemgraphCypher::BATCH_INTERVAL:
      case MemgraphCypher::BATCH_SIZE:
      case MemgraphCypher::TRANSFORM: {
        enterOuterAlt(_localctx, 6);
        setState(855);
        commonCreateStreamConfig();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KafkaCreateStreamContext ------------------------------------------------------------------

MemgraphCypher::KafkaCreateStreamContext::KafkaCreateStreamContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::KafkaCreateStreamContext::CREATE() {
  return getToken(MemgraphCypher::CREATE, 0);
}

tree::TerminalNode* MemgraphCypher::KafkaCreateStreamContext::KAFKA() {
  return getToken(MemgraphCypher::KAFKA, 0);
}

tree::TerminalNode* MemgraphCypher::KafkaCreateStreamContext::STREAM() {
  return getToken(MemgraphCypher::STREAM, 0);
}

MemgraphCypher::StreamNameContext* MemgraphCypher::KafkaCreateStreamContext::streamName() {
  return getRuleContext<MemgraphCypher::StreamNameContext>(0);
}

std::vector<MemgraphCypher::KafkaCreateStreamConfigContext *> MemgraphCypher::KafkaCreateStreamContext::kafkaCreateStreamConfig() {
  return getRuleContexts<MemgraphCypher::KafkaCreateStreamConfigContext>();
}

MemgraphCypher::KafkaCreateStreamConfigContext* MemgraphCypher::KafkaCreateStreamContext::kafkaCreateStreamConfig(size_t i) {
  return getRuleContext<MemgraphCypher::KafkaCreateStreamConfigContext>(i);
}


size_t MemgraphCypher::KafkaCreateStreamContext::getRuleIndex() const {
  return MemgraphCypher::RuleKafkaCreateStream;
}

void MemgraphCypher::KafkaCreateStreamContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKafkaCreateStream(this);
}

void MemgraphCypher::KafkaCreateStreamContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKafkaCreateStream(this);
}


std::any MemgraphCypher::KafkaCreateStreamContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitKafkaCreateStream(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::KafkaCreateStreamContext* MemgraphCypher::kafkaCreateStream() {
  KafkaCreateStreamContext *_localctx = _tracker.createInstance<KafkaCreateStreamContext>(_ctx, getState());
  enterRule(_localctx, 130, MemgraphCypher::RuleKafkaCreateStream);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(858);
    match(MemgraphCypher::CREATE);
    setState(859);
    match(MemgraphCypher::KAFKA);
    setState(860);
    match(MemgraphCypher::STREAM);
    setState(861);
    streamName();
    setState(865);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MemgraphCypher::BATCH_INTERVAL)
      | (1ULL << MemgraphCypher::BATCH_SIZE)
      | (1ULL << MemgraphCypher::BOOTSTRAP_SERVERS)
      | (1ULL << MemgraphCypher::CONFIGS)
      | (1ULL << MemgraphCypher::CONSUMER_GROUP)
      | (1ULL << MemgraphCypher::CREDENTIALS))) != 0) || _la == MemgraphCypher::TOPICS

    || _la == MemgraphCypher::TRANSFORM) {
      setState(862);
      kafkaCreateStreamConfig();
      setState(867);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PulsarCreateStreamConfigContext ------------------------------------------------------------------

MemgraphCypher::PulsarCreateStreamConfigContext::PulsarCreateStreamConfigContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::PulsarCreateStreamConfigContext::TOPICS() {
  return getToken(MemgraphCypher::TOPICS, 0);
}

MemgraphCypher::TopicNamesContext* MemgraphCypher::PulsarCreateStreamConfigContext::topicNames() {
  return getRuleContext<MemgraphCypher::TopicNamesContext>(0);
}

tree::TerminalNode* MemgraphCypher::PulsarCreateStreamConfigContext::SERVICE_URL() {
  return getToken(MemgraphCypher::SERVICE_URL, 0);
}

MemgraphCypher::LiteralContext* MemgraphCypher::PulsarCreateStreamConfigContext::literal() {
  return getRuleContext<MemgraphCypher::LiteralContext>(0);
}

MemgraphCypher::CommonCreateStreamConfigContext* MemgraphCypher::PulsarCreateStreamConfigContext::commonCreateStreamConfig() {
  return getRuleContext<MemgraphCypher::CommonCreateStreamConfigContext>(0);
}


size_t MemgraphCypher::PulsarCreateStreamConfigContext::getRuleIndex() const {
  return MemgraphCypher::RulePulsarCreateStreamConfig;
}

void MemgraphCypher::PulsarCreateStreamConfigContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPulsarCreateStreamConfig(this);
}

void MemgraphCypher::PulsarCreateStreamConfigContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPulsarCreateStreamConfig(this);
}


std::any MemgraphCypher::PulsarCreateStreamConfigContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitPulsarCreateStreamConfig(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::PulsarCreateStreamConfigContext* MemgraphCypher::pulsarCreateStreamConfig() {
  PulsarCreateStreamConfigContext *_localctx = _tracker.createInstance<PulsarCreateStreamConfigContext>(_ctx, getState());
  enterRule(_localctx, 132, MemgraphCypher::RulePulsarCreateStreamConfig);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(873);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MemgraphCypher::TOPICS: {
        enterOuterAlt(_localctx, 1);
        setState(868);
        match(MemgraphCypher::TOPICS);
        setState(869);
        topicNames();
        break;
      }

      case MemgraphCypher::SERVICE_URL: {
        enterOuterAlt(_localctx, 2);
        setState(870);
        match(MemgraphCypher::SERVICE_URL);
        setState(871);
        antlrcpp::downCast<PulsarCreateStreamConfigContext *>(_localctx)->serviceUrl = literal();
        break;
      }

      case MemgraphCypher::BATCH_INTERVAL:
      case MemgraphCypher::BATCH_SIZE:
      case MemgraphCypher::TRANSFORM: {
        enterOuterAlt(_localctx, 3);
        setState(872);
        commonCreateStreamConfig();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PulsarCreateStreamContext ------------------------------------------------------------------

MemgraphCypher::PulsarCreateStreamContext::PulsarCreateStreamContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::PulsarCreateStreamContext::CREATE() {
  return getToken(MemgraphCypher::CREATE, 0);
}

tree::TerminalNode* MemgraphCypher::PulsarCreateStreamContext::PULSAR() {
  return getToken(MemgraphCypher::PULSAR, 0);
}

tree::TerminalNode* MemgraphCypher::PulsarCreateStreamContext::STREAM() {
  return getToken(MemgraphCypher::STREAM, 0);
}

MemgraphCypher::StreamNameContext* MemgraphCypher::PulsarCreateStreamContext::streamName() {
  return getRuleContext<MemgraphCypher::StreamNameContext>(0);
}

std::vector<MemgraphCypher::PulsarCreateStreamConfigContext *> MemgraphCypher::PulsarCreateStreamContext::pulsarCreateStreamConfig() {
  return getRuleContexts<MemgraphCypher::PulsarCreateStreamConfigContext>();
}

MemgraphCypher::PulsarCreateStreamConfigContext* MemgraphCypher::PulsarCreateStreamContext::pulsarCreateStreamConfig(size_t i) {
  return getRuleContext<MemgraphCypher::PulsarCreateStreamConfigContext>(i);
}


size_t MemgraphCypher::PulsarCreateStreamContext::getRuleIndex() const {
  return MemgraphCypher::RulePulsarCreateStream;
}

void MemgraphCypher::PulsarCreateStreamContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPulsarCreateStream(this);
}

void MemgraphCypher::PulsarCreateStreamContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPulsarCreateStream(this);
}


std::any MemgraphCypher::PulsarCreateStreamContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitPulsarCreateStream(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::PulsarCreateStreamContext* MemgraphCypher::pulsarCreateStream() {
  PulsarCreateStreamContext *_localctx = _tracker.createInstance<PulsarCreateStreamContext>(_ctx, getState());
  enterRule(_localctx, 134, MemgraphCypher::RulePulsarCreateStream);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(875);
    match(MemgraphCypher::CREATE);
    setState(876);
    match(MemgraphCypher::PULSAR);
    setState(877);
    match(MemgraphCypher::STREAM);
    setState(878);
    streamName();
    setState(882);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::BATCH_INTERVAL

    || _la == MemgraphCypher::BATCH_SIZE || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & ((1ULL << (MemgraphCypher::SERVICE_URL - 66))
      | (1ULL << (MemgraphCypher::TOPICS - 66))
      | (1ULL << (MemgraphCypher::TRANSFORM - 66)))) != 0)) {
      setState(879);
      pulsarCreateStreamConfig();
      setState(884);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropStreamContext ------------------------------------------------------------------

MemgraphCypher::DropStreamContext::DropStreamContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::DropStreamContext::DROP() {
  return getToken(MemgraphCypher::DROP, 0);
}

tree::TerminalNode* MemgraphCypher::DropStreamContext::STREAM() {
  return getToken(MemgraphCypher::STREAM, 0);
}

MemgraphCypher::StreamNameContext* MemgraphCypher::DropStreamContext::streamName() {
  return getRuleContext<MemgraphCypher::StreamNameContext>(0);
}


size_t MemgraphCypher::DropStreamContext::getRuleIndex() const {
  return MemgraphCypher::RuleDropStream;
}

void MemgraphCypher::DropStreamContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropStream(this);
}

void MemgraphCypher::DropStreamContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropStream(this);
}


std::any MemgraphCypher::DropStreamContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitDropStream(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::DropStreamContext* MemgraphCypher::dropStream() {
  DropStreamContext *_localctx = _tracker.createInstance<DropStreamContext>(_ctx, getState());
  enterRule(_localctx, 136, MemgraphCypher::RuleDropStream);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(885);
    match(MemgraphCypher::DROP);
    setState(886);
    match(MemgraphCypher::STREAM);
    setState(887);
    streamName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StartStreamContext ------------------------------------------------------------------

MemgraphCypher::StartStreamContext::StartStreamContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::StartStreamContext::START() {
  return getToken(MemgraphCypher::START, 0);
}

tree::TerminalNode* MemgraphCypher::StartStreamContext::STREAM() {
  return getToken(MemgraphCypher::STREAM, 0);
}

MemgraphCypher::StreamNameContext* MemgraphCypher::StartStreamContext::streamName() {
  return getRuleContext<MemgraphCypher::StreamNameContext>(0);
}

tree::TerminalNode* MemgraphCypher::StartStreamContext::BATCH_LIMIT() {
  return getToken(MemgraphCypher::BATCH_LIMIT, 0);
}

tree::TerminalNode* MemgraphCypher::StartStreamContext::TIMEOUT() {
  return getToken(MemgraphCypher::TIMEOUT, 0);
}

std::vector<MemgraphCypher::LiteralContext *> MemgraphCypher::StartStreamContext::literal() {
  return getRuleContexts<MemgraphCypher::LiteralContext>();
}

MemgraphCypher::LiteralContext* MemgraphCypher::StartStreamContext::literal(size_t i) {
  return getRuleContext<MemgraphCypher::LiteralContext>(i);
}


size_t MemgraphCypher::StartStreamContext::getRuleIndex() const {
  return MemgraphCypher::RuleStartStream;
}

void MemgraphCypher::StartStreamContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStartStream(this);
}

void MemgraphCypher::StartStreamContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStartStream(this);
}


std::any MemgraphCypher::StartStreamContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitStartStream(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::StartStreamContext* MemgraphCypher::startStream() {
  StartStreamContext *_localctx = _tracker.createInstance<StartStreamContext>(_ctx, getState());
  enterRule(_localctx, 138, MemgraphCypher::RuleStartStream);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(889);
    match(MemgraphCypher::START);
    setState(890);
    match(MemgraphCypher::STREAM);
    setState(891);
    streamName();
    setState(894);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::BATCH_LIMIT) {
      setState(892);
      match(MemgraphCypher::BATCH_LIMIT);
      setState(893);
      antlrcpp::downCast<StartStreamContext *>(_localctx)->batchLimit = literal();
    }
    setState(898);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::TIMEOUT) {
      setState(896);
      match(MemgraphCypher::TIMEOUT);
      setState(897);
      antlrcpp::downCast<StartStreamContext *>(_localctx)->timeout = literal();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StartAllStreamsContext ------------------------------------------------------------------

MemgraphCypher::StartAllStreamsContext::StartAllStreamsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::StartAllStreamsContext::START() {
  return getToken(MemgraphCypher::START, 0);
}

tree::TerminalNode* MemgraphCypher::StartAllStreamsContext::ALL() {
  return getToken(MemgraphCypher::ALL, 0);
}

tree::TerminalNode* MemgraphCypher::StartAllStreamsContext::STREAMS() {
  return getToken(MemgraphCypher::STREAMS, 0);
}


size_t MemgraphCypher::StartAllStreamsContext::getRuleIndex() const {
  return MemgraphCypher::RuleStartAllStreams;
}

void MemgraphCypher::StartAllStreamsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStartAllStreams(this);
}

void MemgraphCypher::StartAllStreamsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStartAllStreams(this);
}


std::any MemgraphCypher::StartAllStreamsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitStartAllStreams(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::StartAllStreamsContext* MemgraphCypher::startAllStreams() {
  StartAllStreamsContext *_localctx = _tracker.createInstance<StartAllStreamsContext>(_ctx, getState());
  enterRule(_localctx, 140, MemgraphCypher::RuleStartAllStreams);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(900);
    match(MemgraphCypher::START);
    setState(901);
    match(MemgraphCypher::ALL);
    setState(902);
    match(MemgraphCypher::STREAMS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StopStreamContext ------------------------------------------------------------------

MemgraphCypher::StopStreamContext::StopStreamContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::StopStreamContext::STOP() {
  return getToken(MemgraphCypher::STOP, 0);
}

tree::TerminalNode* MemgraphCypher::StopStreamContext::STREAM() {
  return getToken(MemgraphCypher::STREAM, 0);
}

MemgraphCypher::StreamNameContext* MemgraphCypher::StopStreamContext::streamName() {
  return getRuleContext<MemgraphCypher::StreamNameContext>(0);
}


size_t MemgraphCypher::StopStreamContext::getRuleIndex() const {
  return MemgraphCypher::RuleStopStream;
}

void MemgraphCypher::StopStreamContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStopStream(this);
}

void MemgraphCypher::StopStreamContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStopStream(this);
}


std::any MemgraphCypher::StopStreamContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitStopStream(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::StopStreamContext* MemgraphCypher::stopStream() {
  StopStreamContext *_localctx = _tracker.createInstance<StopStreamContext>(_ctx, getState());
  enterRule(_localctx, 142, MemgraphCypher::RuleStopStream);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(904);
    match(MemgraphCypher::STOP);
    setState(905);
    match(MemgraphCypher::STREAM);
    setState(906);
    streamName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StopAllStreamsContext ------------------------------------------------------------------

MemgraphCypher::StopAllStreamsContext::StopAllStreamsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::StopAllStreamsContext::STOP() {
  return getToken(MemgraphCypher::STOP, 0);
}

tree::TerminalNode* MemgraphCypher::StopAllStreamsContext::ALL() {
  return getToken(MemgraphCypher::ALL, 0);
}

tree::TerminalNode* MemgraphCypher::StopAllStreamsContext::STREAMS() {
  return getToken(MemgraphCypher::STREAMS, 0);
}


size_t MemgraphCypher::StopAllStreamsContext::getRuleIndex() const {
  return MemgraphCypher::RuleStopAllStreams;
}

void MemgraphCypher::StopAllStreamsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStopAllStreams(this);
}

void MemgraphCypher::StopAllStreamsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStopAllStreams(this);
}


std::any MemgraphCypher::StopAllStreamsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitStopAllStreams(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::StopAllStreamsContext* MemgraphCypher::stopAllStreams() {
  StopAllStreamsContext *_localctx = _tracker.createInstance<StopAllStreamsContext>(_ctx, getState());
  enterRule(_localctx, 144, MemgraphCypher::RuleStopAllStreams);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(908);
    match(MemgraphCypher::STOP);
    setState(909);
    match(MemgraphCypher::ALL);
    setState(910);
    match(MemgraphCypher::STREAMS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowStreamsContext ------------------------------------------------------------------

MemgraphCypher::ShowStreamsContext::ShowStreamsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ShowStreamsContext::SHOW() {
  return getToken(MemgraphCypher::SHOW, 0);
}

tree::TerminalNode* MemgraphCypher::ShowStreamsContext::STREAMS() {
  return getToken(MemgraphCypher::STREAMS, 0);
}


size_t MemgraphCypher::ShowStreamsContext::getRuleIndex() const {
  return MemgraphCypher::RuleShowStreams;
}

void MemgraphCypher::ShowStreamsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowStreams(this);
}

void MemgraphCypher::ShowStreamsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowStreams(this);
}


std::any MemgraphCypher::ShowStreamsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitShowStreams(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ShowStreamsContext* MemgraphCypher::showStreams() {
  ShowStreamsContext *_localctx = _tracker.createInstance<ShowStreamsContext>(_ctx, getState());
  enterRule(_localctx, 146, MemgraphCypher::RuleShowStreams);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(912);
    match(MemgraphCypher::SHOW);
    setState(913);
    match(MemgraphCypher::STREAMS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CheckStreamContext ------------------------------------------------------------------

MemgraphCypher::CheckStreamContext::CheckStreamContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::CheckStreamContext::CHECK() {
  return getToken(MemgraphCypher::CHECK, 0);
}

tree::TerminalNode* MemgraphCypher::CheckStreamContext::STREAM() {
  return getToken(MemgraphCypher::STREAM, 0);
}

MemgraphCypher::StreamNameContext* MemgraphCypher::CheckStreamContext::streamName() {
  return getRuleContext<MemgraphCypher::StreamNameContext>(0);
}

tree::TerminalNode* MemgraphCypher::CheckStreamContext::BATCH_LIMIT() {
  return getToken(MemgraphCypher::BATCH_LIMIT, 0);
}

tree::TerminalNode* MemgraphCypher::CheckStreamContext::TIMEOUT() {
  return getToken(MemgraphCypher::TIMEOUT, 0);
}

std::vector<MemgraphCypher::LiteralContext *> MemgraphCypher::CheckStreamContext::literal() {
  return getRuleContexts<MemgraphCypher::LiteralContext>();
}

MemgraphCypher::LiteralContext* MemgraphCypher::CheckStreamContext::literal(size_t i) {
  return getRuleContext<MemgraphCypher::LiteralContext>(i);
}


size_t MemgraphCypher::CheckStreamContext::getRuleIndex() const {
  return MemgraphCypher::RuleCheckStream;
}

void MemgraphCypher::CheckStreamContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCheckStream(this);
}

void MemgraphCypher::CheckStreamContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCheckStream(this);
}


std::any MemgraphCypher::CheckStreamContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitCheckStream(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::CheckStreamContext* MemgraphCypher::checkStream() {
  CheckStreamContext *_localctx = _tracker.createInstance<CheckStreamContext>(_ctx, getState());
  enterRule(_localctx, 148, MemgraphCypher::RuleCheckStream);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(915);
    match(MemgraphCypher::CHECK);
    setState(916);
    match(MemgraphCypher::STREAM);
    setState(917);
    streamName();
    setState(920);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::BATCH_LIMIT) {
      setState(918);
      match(MemgraphCypher::BATCH_LIMIT);
      setState(919);
      antlrcpp::downCast<CheckStreamContext *>(_localctx)->batchLimit = literal();
    }
    setState(924);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::TIMEOUT) {
      setState(922);
      match(MemgraphCypher::TIMEOUT);
      setState(923);
      antlrcpp::downCast<CheckStreamContext *>(_localctx)->timeout = literal();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SettingNameContext ------------------------------------------------------------------

MemgraphCypher::SettingNameContext::SettingNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::LiteralContext* MemgraphCypher::SettingNameContext::literal() {
  return getRuleContext<MemgraphCypher::LiteralContext>(0);
}


size_t MemgraphCypher::SettingNameContext::getRuleIndex() const {
  return MemgraphCypher::RuleSettingName;
}

void MemgraphCypher::SettingNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSettingName(this);
}

void MemgraphCypher::SettingNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSettingName(this);
}


std::any MemgraphCypher::SettingNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitSettingName(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::SettingNameContext* MemgraphCypher::settingName() {
  SettingNameContext *_localctx = _tracker.createInstance<SettingNameContext>(_ctx, getState());
  enterRule(_localctx, 150, MemgraphCypher::RuleSettingName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(926);
    literal();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SettingValueContext ------------------------------------------------------------------

MemgraphCypher::SettingValueContext::SettingValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::LiteralContext* MemgraphCypher::SettingValueContext::literal() {
  return getRuleContext<MemgraphCypher::LiteralContext>(0);
}


size_t MemgraphCypher::SettingValueContext::getRuleIndex() const {
  return MemgraphCypher::RuleSettingValue;
}

void MemgraphCypher::SettingValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSettingValue(this);
}

void MemgraphCypher::SettingValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSettingValue(this);
}


std::any MemgraphCypher::SettingValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitSettingValue(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::SettingValueContext* MemgraphCypher::settingValue() {
  SettingValueContext *_localctx = _tracker.createInstance<SettingValueContext>(_ctx, getState());
  enterRule(_localctx, 152, MemgraphCypher::RuleSettingValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(928);
    literal();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetSettingContext ------------------------------------------------------------------

MemgraphCypher::SetSettingContext::SetSettingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::SetSettingContext::SET() {
  return getToken(MemgraphCypher::SET, 0);
}

tree::TerminalNode* MemgraphCypher::SetSettingContext::DATABASE() {
  return getToken(MemgraphCypher::DATABASE, 0);
}

tree::TerminalNode* MemgraphCypher::SetSettingContext::SETTING() {
  return getToken(MemgraphCypher::SETTING, 0);
}

MemgraphCypher::SettingNameContext* MemgraphCypher::SetSettingContext::settingName() {
  return getRuleContext<MemgraphCypher::SettingNameContext>(0);
}

tree::TerminalNode* MemgraphCypher::SetSettingContext::TO() {
  return getToken(MemgraphCypher::TO, 0);
}

MemgraphCypher::SettingValueContext* MemgraphCypher::SetSettingContext::settingValue() {
  return getRuleContext<MemgraphCypher::SettingValueContext>(0);
}


size_t MemgraphCypher::SetSettingContext::getRuleIndex() const {
  return MemgraphCypher::RuleSetSetting;
}

void MemgraphCypher::SetSettingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetSetting(this);
}

void MemgraphCypher::SetSettingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetSetting(this);
}


std::any MemgraphCypher::SetSettingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitSetSetting(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::SetSettingContext* MemgraphCypher::setSetting() {
  SetSettingContext *_localctx = _tracker.createInstance<SetSettingContext>(_ctx, getState());
  enterRule(_localctx, 154, MemgraphCypher::RuleSetSetting);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(930);
    match(MemgraphCypher::SET);
    setState(931);
    match(MemgraphCypher::DATABASE);
    setState(932);
    match(MemgraphCypher::SETTING);
    setState(933);
    settingName();
    setState(934);
    match(MemgraphCypher::TO);
    setState(935);
    settingValue();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowSettingContext ------------------------------------------------------------------

MemgraphCypher::ShowSettingContext::ShowSettingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ShowSettingContext::SHOW() {
  return getToken(MemgraphCypher::SHOW, 0);
}

tree::TerminalNode* MemgraphCypher::ShowSettingContext::DATABASE() {
  return getToken(MemgraphCypher::DATABASE, 0);
}

tree::TerminalNode* MemgraphCypher::ShowSettingContext::SETTING() {
  return getToken(MemgraphCypher::SETTING, 0);
}

MemgraphCypher::SettingNameContext* MemgraphCypher::ShowSettingContext::settingName() {
  return getRuleContext<MemgraphCypher::SettingNameContext>(0);
}


size_t MemgraphCypher::ShowSettingContext::getRuleIndex() const {
  return MemgraphCypher::RuleShowSetting;
}

void MemgraphCypher::ShowSettingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowSetting(this);
}

void MemgraphCypher::ShowSettingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowSetting(this);
}


std::any MemgraphCypher::ShowSettingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitShowSetting(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ShowSettingContext* MemgraphCypher::showSetting() {
  ShowSettingContext *_localctx = _tracker.createInstance<ShowSettingContext>(_ctx, getState());
  enterRule(_localctx, 156, MemgraphCypher::RuleShowSetting);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(937);
    match(MemgraphCypher::SHOW);
    setState(938);
    match(MemgraphCypher::DATABASE);
    setState(939);
    match(MemgraphCypher::SETTING);
    setState(940);
    settingName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowSettingsContext ------------------------------------------------------------------

MemgraphCypher::ShowSettingsContext::ShowSettingsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ShowSettingsContext::SHOW() {
  return getToken(MemgraphCypher::SHOW, 0);
}

tree::TerminalNode* MemgraphCypher::ShowSettingsContext::DATABASE() {
  return getToken(MemgraphCypher::DATABASE, 0);
}

tree::TerminalNode* MemgraphCypher::ShowSettingsContext::SETTINGS() {
  return getToken(MemgraphCypher::SETTINGS, 0);
}


size_t MemgraphCypher::ShowSettingsContext::getRuleIndex() const {
  return MemgraphCypher::RuleShowSettings;
}

void MemgraphCypher::ShowSettingsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowSettings(this);
}

void MemgraphCypher::ShowSettingsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowSettings(this);
}


std::any MemgraphCypher::ShowSettingsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitShowSettings(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ShowSettingsContext* MemgraphCypher::showSettings() {
  ShowSettingsContext *_localctx = _tracker.createInstance<ShowSettingsContext>(_ctx, getState());
  enterRule(_localctx, 158, MemgraphCypher::RuleShowSettings);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(942);
    match(MemgraphCypher::SHOW);
    setState(943);
    match(MemgraphCypher::DATABASE);
    setState(944);
    match(MemgraphCypher::SETTINGS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VersionQueryContext ------------------------------------------------------------------

MemgraphCypher::VersionQueryContext::VersionQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::VersionQueryContext::SHOW() {
  return getToken(MemgraphCypher::SHOW, 0);
}

tree::TerminalNode* MemgraphCypher::VersionQueryContext::VERSION() {
  return getToken(MemgraphCypher::VERSION, 0);
}


size_t MemgraphCypher::VersionQueryContext::getRuleIndex() const {
  return MemgraphCypher::RuleVersionQuery;
}

void MemgraphCypher::VersionQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVersionQuery(this);
}

void MemgraphCypher::VersionQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVersionQuery(this);
}


std::any MemgraphCypher::VersionQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitVersionQuery(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::VersionQueryContext* MemgraphCypher::versionQuery() {
  VersionQueryContext *_localctx = _tracker.createInstance<VersionQueryContext>(_ctx, getState());
  enterRule(_localctx, 160, MemgraphCypher::RuleVersionQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(946);
    match(MemgraphCypher::SHOW);
    setState(947);
    match(MemgraphCypher::VERSION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CypherContext ------------------------------------------------------------------

MemgraphCypher::CypherContext::CypherContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::StatementContext* MemgraphCypher::CypherContext::statement() {
  return getRuleContext<MemgraphCypher::StatementContext>(0);
}

tree::TerminalNode* MemgraphCypher::CypherContext::EOF() {
  return getToken(MemgraphCypher::EOF, 0);
}

tree::TerminalNode* MemgraphCypher::CypherContext::SEMICOLON() {
  return getToken(MemgraphCypher::SEMICOLON, 0);
}


size_t MemgraphCypher::CypherContext::getRuleIndex() const {
  return MemgraphCypher::RuleCypher;
}

void MemgraphCypher::CypherContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCypher(this);
}

void MemgraphCypher::CypherContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCypher(this);
}


std::any MemgraphCypher::CypherContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitCypher(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::CypherContext* MemgraphCypher::cypher() {
  CypherContext *_localctx = _tracker.createInstance<CypherContext>(_ctx, getState());
  enterRule(_localctx, 162, MemgraphCypher::RuleCypher);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(949);
    statement();
    setState(951);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::SEMICOLON) {
      setState(950);
      match(MemgraphCypher::SEMICOLON);
    }
    setState(953);
    match(MemgraphCypher::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

MemgraphCypher::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::QueryContext* MemgraphCypher::StatementContext::query() {
  return getRuleContext<MemgraphCypher::QueryContext>(0);
}


size_t MemgraphCypher::StatementContext::getRuleIndex() const {
  return MemgraphCypher::RuleStatement;
}

void MemgraphCypher::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void MemgraphCypher::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}


std::any MemgraphCypher::StatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitStatement(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::StatementContext* MemgraphCypher::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 164, MemgraphCypher::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(955);
    query();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintQueryContext ------------------------------------------------------------------

MemgraphCypher::ConstraintQueryContext::ConstraintQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ConstraintQueryContext::CONSTRAINT() {
  return getToken(MemgraphCypher::CONSTRAINT, 0);
}

tree::TerminalNode* MemgraphCypher::ConstraintQueryContext::ON() {
  return getToken(MemgraphCypher::ON, 0);
}

MemgraphCypher::ConstraintContext* MemgraphCypher::ConstraintQueryContext::constraint() {
  return getRuleContext<MemgraphCypher::ConstraintContext>(0);
}

tree::TerminalNode* MemgraphCypher::ConstraintQueryContext::CREATE() {
  return getToken(MemgraphCypher::CREATE, 0);
}

tree::TerminalNode* MemgraphCypher::ConstraintQueryContext::DROP() {
  return getToken(MemgraphCypher::DROP, 0);
}


size_t MemgraphCypher::ConstraintQueryContext::getRuleIndex() const {
  return MemgraphCypher::RuleConstraintQuery;
}

void MemgraphCypher::ConstraintQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraintQuery(this);
}

void MemgraphCypher::ConstraintQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraintQuery(this);
}


std::any MemgraphCypher::ConstraintQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitConstraintQuery(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ConstraintQueryContext* MemgraphCypher::constraintQuery() {
  ConstraintQueryContext *_localctx = _tracker.createInstance<ConstraintQueryContext>(_ctx, getState());
  enterRule(_localctx, 166, MemgraphCypher::RuleConstraintQuery);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(957);
    _la = _input->LA(1);
    if (!(_la == MemgraphCypher::DROP || _la == MemgraphCypher::CREATE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(958);
    match(MemgraphCypher::CONSTRAINT);
    setState(959);
    match(MemgraphCypher::ON);
    setState(960);
    constraint();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintContext ------------------------------------------------------------------

MemgraphCypher::ConstraintContext::ConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MemgraphCypher::ConstraintContext::LPAREN() {
  return getTokens(MemgraphCypher::LPAREN);
}

tree::TerminalNode* MemgraphCypher::ConstraintContext::LPAREN(size_t i) {
  return getToken(MemgraphCypher::LPAREN, i);
}

tree::TerminalNode* MemgraphCypher::ConstraintContext::COLON() {
  return getToken(MemgraphCypher::COLON, 0);
}

MemgraphCypher::LabelNameContext* MemgraphCypher::ConstraintContext::labelName() {
  return getRuleContext<MemgraphCypher::LabelNameContext>(0);
}

std::vector<tree::TerminalNode *> MemgraphCypher::ConstraintContext::RPAREN() {
  return getTokens(MemgraphCypher::RPAREN);
}

tree::TerminalNode* MemgraphCypher::ConstraintContext::RPAREN(size_t i) {
  return getToken(MemgraphCypher::RPAREN, i);
}

tree::TerminalNode* MemgraphCypher::ConstraintContext::ASSERT() {
  return getToken(MemgraphCypher::ASSERT, 0);
}

tree::TerminalNode* MemgraphCypher::ConstraintContext::EXISTS() {
  return getToken(MemgraphCypher::EXISTS, 0);
}

MemgraphCypher::ConstraintPropertyListContext* MemgraphCypher::ConstraintContext::constraintPropertyList() {
  return getRuleContext<MemgraphCypher::ConstraintPropertyListContext>(0);
}

MemgraphCypher::VariableContext* MemgraphCypher::ConstraintContext::variable() {
  return getRuleContext<MemgraphCypher::VariableContext>(0);
}

tree::TerminalNode* MemgraphCypher::ConstraintContext::IS() {
  return getToken(MemgraphCypher::IS, 0);
}

tree::TerminalNode* MemgraphCypher::ConstraintContext::UNIQUE() {
  return getToken(MemgraphCypher::UNIQUE, 0);
}

tree::TerminalNode* MemgraphCypher::ConstraintContext::NODE() {
  return getToken(MemgraphCypher::NODE, 0);
}

tree::TerminalNode* MemgraphCypher::ConstraintContext::KEY() {
  return getToken(MemgraphCypher::KEY, 0);
}


size_t MemgraphCypher::ConstraintContext::getRuleIndex() const {
  return MemgraphCypher::RuleConstraint;
}

void MemgraphCypher::ConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraint(this);
}

void MemgraphCypher::ConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraint(this);
}


std::any MemgraphCypher::ConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitConstraint(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ConstraintContext* MemgraphCypher::constraint() {
  ConstraintContext *_localctx = _tracker.createInstance<ConstraintContext>(_ctx, getState());
  enterRule(_localctx, 168, MemgraphCypher::RuleConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(996);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(962);
      match(MemgraphCypher::LPAREN);
      setState(963);
      antlrcpp::downCast<ConstraintContext *>(_localctx)->nodeName = variable();
      setState(964);
      match(MemgraphCypher::COLON);
      setState(965);
      labelName();
      setState(966);
      match(MemgraphCypher::RPAREN);
      setState(967);
      match(MemgraphCypher::ASSERT);
      setState(968);
      match(MemgraphCypher::EXISTS);
      setState(969);
      match(MemgraphCypher::LPAREN);
      setState(970);
      constraintPropertyList();
      setState(971);
      match(MemgraphCypher::RPAREN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(973);
      match(MemgraphCypher::LPAREN);
      setState(974);
      antlrcpp::downCast<ConstraintContext *>(_localctx)->nodeName = variable();
      setState(975);
      match(MemgraphCypher::COLON);
      setState(976);
      labelName();
      setState(977);
      match(MemgraphCypher::RPAREN);
      setState(978);
      match(MemgraphCypher::ASSERT);
      setState(979);
      constraintPropertyList();
      setState(980);
      match(MemgraphCypher::IS);
      setState(981);
      match(MemgraphCypher::UNIQUE);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(983);
      match(MemgraphCypher::LPAREN);
      setState(984);
      antlrcpp::downCast<ConstraintContext *>(_localctx)->nodeName = variable();
      setState(985);
      match(MemgraphCypher::COLON);
      setState(986);
      labelName();
      setState(987);
      match(MemgraphCypher::RPAREN);
      setState(988);
      match(MemgraphCypher::ASSERT);
      setState(989);
      match(MemgraphCypher::LPAREN);
      setState(990);
      constraintPropertyList();
      setState(991);
      match(MemgraphCypher::RPAREN);
      setState(992);
      match(MemgraphCypher::IS);
      setState(993);
      match(MemgraphCypher::NODE);
      setState(994);
      match(MemgraphCypher::KEY);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintPropertyListContext ------------------------------------------------------------------

MemgraphCypher::ConstraintPropertyListContext::ConstraintPropertyListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MemgraphCypher::VariableContext *> MemgraphCypher::ConstraintPropertyListContext::variable() {
  return getRuleContexts<MemgraphCypher::VariableContext>();
}

MemgraphCypher::VariableContext* MemgraphCypher::ConstraintPropertyListContext::variable(size_t i) {
  return getRuleContext<MemgraphCypher::VariableContext>(i);
}

std::vector<MemgraphCypher::PropertyLookupContext *> MemgraphCypher::ConstraintPropertyListContext::propertyLookup() {
  return getRuleContexts<MemgraphCypher::PropertyLookupContext>();
}

MemgraphCypher::PropertyLookupContext* MemgraphCypher::ConstraintPropertyListContext::propertyLookup(size_t i) {
  return getRuleContext<MemgraphCypher::PropertyLookupContext>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::ConstraintPropertyListContext::COMMA() {
  return getTokens(MemgraphCypher::COMMA);
}

tree::TerminalNode* MemgraphCypher::ConstraintPropertyListContext::COMMA(size_t i) {
  return getToken(MemgraphCypher::COMMA, i);
}


size_t MemgraphCypher::ConstraintPropertyListContext::getRuleIndex() const {
  return MemgraphCypher::RuleConstraintPropertyList;
}

void MemgraphCypher::ConstraintPropertyListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraintPropertyList(this);
}

void MemgraphCypher::ConstraintPropertyListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraintPropertyList(this);
}


std::any MemgraphCypher::ConstraintPropertyListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitConstraintPropertyList(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ConstraintPropertyListContext* MemgraphCypher::constraintPropertyList() {
  ConstraintPropertyListContext *_localctx = _tracker.createInstance<ConstraintPropertyListContext>(_ctx, getState());
  enterRule(_localctx, 170, MemgraphCypher::RuleConstraintPropertyList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(998);
    variable();
    setState(999);
    propertyLookup();
    setState(1006);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::COMMA) {
      setState(1000);
      match(MemgraphCypher::COMMA);
      setState(1001);
      variable();
      setState(1002);
      propertyLookup();
      setState(1008);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StorageInfoContext ------------------------------------------------------------------

MemgraphCypher::StorageInfoContext::StorageInfoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::StorageInfoContext::STORAGE() {
  return getToken(MemgraphCypher::STORAGE, 0);
}

tree::TerminalNode* MemgraphCypher::StorageInfoContext::INFO() {
  return getToken(MemgraphCypher::INFO, 0);
}


size_t MemgraphCypher::StorageInfoContext::getRuleIndex() const {
  return MemgraphCypher::RuleStorageInfo;
}

void MemgraphCypher::StorageInfoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStorageInfo(this);
}

void MemgraphCypher::StorageInfoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStorageInfo(this);
}


std::any MemgraphCypher::StorageInfoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitStorageInfo(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::StorageInfoContext* MemgraphCypher::storageInfo() {
  StorageInfoContext *_localctx = _tracker.createInstance<StorageInfoContext>(_ctx, getState());
  enterRule(_localctx, 172, MemgraphCypher::RuleStorageInfo);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1009);
    match(MemgraphCypher::STORAGE);
    setState(1010);
    match(MemgraphCypher::INFO);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexInfoContext ------------------------------------------------------------------

MemgraphCypher::IndexInfoContext::IndexInfoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::IndexInfoContext::INDEX() {
  return getToken(MemgraphCypher::INDEX, 0);
}

tree::TerminalNode* MemgraphCypher::IndexInfoContext::INFO() {
  return getToken(MemgraphCypher::INFO, 0);
}


size_t MemgraphCypher::IndexInfoContext::getRuleIndex() const {
  return MemgraphCypher::RuleIndexInfo;
}

void MemgraphCypher::IndexInfoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexInfo(this);
}

void MemgraphCypher::IndexInfoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexInfo(this);
}


std::any MemgraphCypher::IndexInfoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitIndexInfo(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::IndexInfoContext* MemgraphCypher::indexInfo() {
  IndexInfoContext *_localctx = _tracker.createInstance<IndexInfoContext>(_ctx, getState());
  enterRule(_localctx, 174, MemgraphCypher::RuleIndexInfo);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1012);
    match(MemgraphCypher::INDEX);
    setState(1013);
    match(MemgraphCypher::INFO);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintInfoContext ------------------------------------------------------------------

MemgraphCypher::ConstraintInfoContext::ConstraintInfoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ConstraintInfoContext::CONSTRAINT() {
  return getToken(MemgraphCypher::CONSTRAINT, 0);
}

tree::TerminalNode* MemgraphCypher::ConstraintInfoContext::INFO() {
  return getToken(MemgraphCypher::INFO, 0);
}


size_t MemgraphCypher::ConstraintInfoContext::getRuleIndex() const {
  return MemgraphCypher::RuleConstraintInfo;
}

void MemgraphCypher::ConstraintInfoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraintInfo(this);
}

void MemgraphCypher::ConstraintInfoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraintInfo(this);
}


std::any MemgraphCypher::ConstraintInfoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitConstraintInfo(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ConstraintInfoContext* MemgraphCypher::constraintInfo() {
  ConstraintInfoContext *_localctx = _tracker.createInstance<ConstraintInfoContext>(_ctx, getState());
  enterRule(_localctx, 176, MemgraphCypher::RuleConstraintInfo);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1015);
    match(MemgraphCypher::CONSTRAINT);
    setState(1016);
    match(MemgraphCypher::INFO);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InfoQueryContext ------------------------------------------------------------------

MemgraphCypher::InfoQueryContext::InfoQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::InfoQueryContext::SHOW() {
  return getToken(MemgraphCypher::SHOW, 0);
}

MemgraphCypher::StorageInfoContext* MemgraphCypher::InfoQueryContext::storageInfo() {
  return getRuleContext<MemgraphCypher::StorageInfoContext>(0);
}

MemgraphCypher::IndexInfoContext* MemgraphCypher::InfoQueryContext::indexInfo() {
  return getRuleContext<MemgraphCypher::IndexInfoContext>(0);
}

MemgraphCypher::ConstraintInfoContext* MemgraphCypher::InfoQueryContext::constraintInfo() {
  return getRuleContext<MemgraphCypher::ConstraintInfoContext>(0);
}


size_t MemgraphCypher::InfoQueryContext::getRuleIndex() const {
  return MemgraphCypher::RuleInfoQuery;
}

void MemgraphCypher::InfoQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInfoQuery(this);
}

void MemgraphCypher::InfoQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInfoQuery(this);
}


std::any MemgraphCypher::InfoQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitInfoQuery(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::InfoQueryContext* MemgraphCypher::infoQuery() {
  InfoQueryContext *_localctx = _tracker.createInstance<InfoQueryContext>(_ctx, getState());
  enterRule(_localctx, 178, MemgraphCypher::RuleInfoQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1018);
    match(MemgraphCypher::SHOW);
    setState(1022);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MemgraphCypher::STORAGE: {
        setState(1019);
        storageInfo();
        break;
      }

      case MemgraphCypher::INDEX: {
        setState(1020);
        indexInfo();
        break;
      }

      case MemgraphCypher::CONSTRAINT: {
        setState(1021);
        constraintInfo();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExplainQueryContext ------------------------------------------------------------------

MemgraphCypher::ExplainQueryContext::ExplainQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ExplainQueryContext::EXPLAIN() {
  return getToken(MemgraphCypher::EXPLAIN, 0);
}

MemgraphCypher::CypherQueryContext* MemgraphCypher::ExplainQueryContext::cypherQuery() {
  return getRuleContext<MemgraphCypher::CypherQueryContext>(0);
}


size_t MemgraphCypher::ExplainQueryContext::getRuleIndex() const {
  return MemgraphCypher::RuleExplainQuery;
}

void MemgraphCypher::ExplainQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExplainQuery(this);
}

void MemgraphCypher::ExplainQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExplainQuery(this);
}


std::any MemgraphCypher::ExplainQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitExplainQuery(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ExplainQueryContext* MemgraphCypher::explainQuery() {
  ExplainQueryContext *_localctx = _tracker.createInstance<ExplainQueryContext>(_ctx, getState());
  enterRule(_localctx, 180, MemgraphCypher::RuleExplainQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1024);
    match(MemgraphCypher::EXPLAIN);
    setState(1025);
    cypherQuery();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProfileQueryContext ------------------------------------------------------------------

MemgraphCypher::ProfileQueryContext::ProfileQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ProfileQueryContext::PROFILE() {
  return getToken(MemgraphCypher::PROFILE, 0);
}

MemgraphCypher::CypherQueryContext* MemgraphCypher::ProfileQueryContext::cypherQuery() {
  return getRuleContext<MemgraphCypher::CypherQueryContext>(0);
}


size_t MemgraphCypher::ProfileQueryContext::getRuleIndex() const {
  return MemgraphCypher::RuleProfileQuery;
}

void MemgraphCypher::ProfileQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProfileQuery(this);
}

void MemgraphCypher::ProfileQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProfileQuery(this);
}


std::any MemgraphCypher::ProfileQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitProfileQuery(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ProfileQueryContext* MemgraphCypher::profileQuery() {
  ProfileQueryContext *_localctx = _tracker.createInstance<ProfileQueryContext>(_ctx, getState());
  enterRule(_localctx, 182, MemgraphCypher::RuleProfileQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1027);
    match(MemgraphCypher::PROFILE);
    setState(1028);
    cypherQuery();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CypherQueryContext ------------------------------------------------------------------

MemgraphCypher::CypherQueryContext::CypherQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::SingleQueryContext* MemgraphCypher::CypherQueryContext::singleQuery() {
  return getRuleContext<MemgraphCypher::SingleQueryContext>(0);
}

std::vector<MemgraphCypher::CypherUnionContext *> MemgraphCypher::CypherQueryContext::cypherUnion() {
  return getRuleContexts<MemgraphCypher::CypherUnionContext>();
}

MemgraphCypher::CypherUnionContext* MemgraphCypher::CypherQueryContext::cypherUnion(size_t i) {
  return getRuleContext<MemgraphCypher::CypherUnionContext>(i);
}

MemgraphCypher::QueryMemoryLimitContext* MemgraphCypher::CypherQueryContext::queryMemoryLimit() {
  return getRuleContext<MemgraphCypher::QueryMemoryLimitContext>(0);
}


size_t MemgraphCypher::CypherQueryContext::getRuleIndex() const {
  return MemgraphCypher::RuleCypherQuery;
}

void MemgraphCypher::CypherQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCypherQuery(this);
}

void MemgraphCypher::CypherQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCypherQuery(this);
}


std::any MemgraphCypher::CypherQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitCypherQuery(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::CypherQueryContext* MemgraphCypher::cypherQuery() {
  CypherQueryContext *_localctx = _tracker.createInstance<CypherQueryContext>(_ctx, getState());
  enterRule(_localctx, 184, MemgraphCypher::RuleCypherQuery);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1030);
    singleQuery();
    setState(1034);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::UNION) {
      setState(1031);
      cypherUnion();
      setState(1036);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1038);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::QUERY) {
      setState(1037);
      queryMemoryLimit();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexQueryContext ------------------------------------------------------------------

MemgraphCypher::IndexQueryContext::IndexQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::CreateIndexContext* MemgraphCypher::IndexQueryContext::createIndex() {
  return getRuleContext<MemgraphCypher::CreateIndexContext>(0);
}

MemgraphCypher::DropIndexContext* MemgraphCypher::IndexQueryContext::dropIndex() {
  return getRuleContext<MemgraphCypher::DropIndexContext>(0);
}


size_t MemgraphCypher::IndexQueryContext::getRuleIndex() const {
  return MemgraphCypher::RuleIndexQuery;
}

void MemgraphCypher::IndexQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexQuery(this);
}

void MemgraphCypher::IndexQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexQuery(this);
}


std::any MemgraphCypher::IndexQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitIndexQuery(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::IndexQueryContext* MemgraphCypher::indexQuery() {
  IndexQueryContext *_localctx = _tracker.createInstance<IndexQueryContext>(_ctx, getState());
  enterRule(_localctx, 186, MemgraphCypher::RuleIndexQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1042);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MemgraphCypher::CREATE: {
        enterOuterAlt(_localctx, 1);
        setState(1040);
        createIndex();
        break;
      }

      case MemgraphCypher::DROP: {
        enterOuterAlt(_localctx, 2);
        setState(1041);
        dropIndex();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SingleQueryContext ------------------------------------------------------------------

MemgraphCypher::SingleQueryContext::SingleQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MemgraphCypher::ClauseContext *> MemgraphCypher::SingleQueryContext::clause() {
  return getRuleContexts<MemgraphCypher::ClauseContext>();
}

MemgraphCypher::ClauseContext* MemgraphCypher::SingleQueryContext::clause(size_t i) {
  return getRuleContext<MemgraphCypher::ClauseContext>(i);
}


size_t MemgraphCypher::SingleQueryContext::getRuleIndex() const {
  return MemgraphCypher::RuleSingleQuery;
}

void MemgraphCypher::SingleQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingleQuery(this);
}

void MemgraphCypher::SingleQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingleQuery(this);
}


std::any MemgraphCypher::SingleQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitSingleQuery(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::SingleQueryContext* MemgraphCypher::singleQuery() {
  SingleQueryContext *_localctx = _tracker.createInstance<SingleQueryContext>(_ctx, getState());
  enterRule(_localctx, 188, MemgraphCypher::RuleSingleQuery);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1044);
    clause();
    setState(1048);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::FOREACH

    || _la == MemgraphCypher::LOAD || ((((_la - 132) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 132)) & ((1ULL << (MemgraphCypher::CALL - 132))
      | (1ULL << (MemgraphCypher::CREATE - 132))
      | (1ULL << (MemgraphCypher::DELETE - 132))
      | (1ULL << (MemgraphCypher::DETACH - 132))
      | (1ULL << (MemgraphCypher::MATCH - 132))
      | (1ULL << (MemgraphCypher::MERGE - 132))
      | (1ULL << (MemgraphCypher::OPTIONAL - 132))
      | (1ULL << (MemgraphCypher::REMOVE - 132))
      | (1ULL << (MemgraphCypher::RETURN - 132))
      | (1ULL << (MemgraphCypher::SET - 132))
      | (1ULL << (MemgraphCypher::UNWIND - 132))
      | (1ULL << (MemgraphCypher::WITH - 132)))) != 0)) {
      setState(1045);
      clause();
      setState(1050);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CypherUnionContext ------------------------------------------------------------------

MemgraphCypher::CypherUnionContext::CypherUnionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::CypherUnionContext::UNION() {
  return getToken(MemgraphCypher::UNION, 0);
}

tree::TerminalNode* MemgraphCypher::CypherUnionContext::ALL() {
  return getToken(MemgraphCypher::ALL, 0);
}

MemgraphCypher::SingleQueryContext* MemgraphCypher::CypherUnionContext::singleQuery() {
  return getRuleContext<MemgraphCypher::SingleQueryContext>(0);
}


size_t MemgraphCypher::CypherUnionContext::getRuleIndex() const {
  return MemgraphCypher::RuleCypherUnion;
}

void MemgraphCypher::CypherUnionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCypherUnion(this);
}

void MemgraphCypher::CypherUnionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCypherUnion(this);
}


std::any MemgraphCypher::CypherUnionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitCypherUnion(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::CypherUnionContext* MemgraphCypher::cypherUnion() {
  CypherUnionContext *_localctx = _tracker.createInstance<CypherUnionContext>(_ctx, getState());
  enterRule(_localctx, 190, MemgraphCypher::RuleCypherUnion);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1056);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1051);
      match(MemgraphCypher::UNION);
      setState(1052);
      match(MemgraphCypher::ALL);
      setState(1053);
      singleQuery();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1054);
      match(MemgraphCypher::UNION);
      setState(1055);
      singleQuery();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CypherMatchContext ------------------------------------------------------------------

MemgraphCypher::CypherMatchContext::CypherMatchContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::CypherMatchContext::MATCH() {
  return getToken(MemgraphCypher::MATCH, 0);
}

MemgraphCypher::PatternContext* MemgraphCypher::CypherMatchContext::pattern() {
  return getRuleContext<MemgraphCypher::PatternContext>(0);
}

tree::TerminalNode* MemgraphCypher::CypherMatchContext::OPTIONAL() {
  return getToken(MemgraphCypher::OPTIONAL, 0);
}

MemgraphCypher::WhereContext* MemgraphCypher::CypherMatchContext::where() {
  return getRuleContext<MemgraphCypher::WhereContext>(0);
}


size_t MemgraphCypher::CypherMatchContext::getRuleIndex() const {
  return MemgraphCypher::RuleCypherMatch;
}

void MemgraphCypher::CypherMatchContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCypherMatch(this);
}

void MemgraphCypher::CypherMatchContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCypherMatch(this);
}


std::any MemgraphCypher::CypherMatchContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitCypherMatch(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::CypherMatchContext* MemgraphCypher::cypherMatch() {
  CypherMatchContext *_localctx = _tracker.createInstance<CypherMatchContext>(_ctx, getState());
  enterRule(_localctx, 192, MemgraphCypher::RuleCypherMatch);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1059);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::OPTIONAL) {
      setState(1058);
      match(MemgraphCypher::OPTIONAL);
    }
    setState(1061);
    match(MemgraphCypher::MATCH);
    setState(1062);
    pattern();
    setState(1064);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::WHERE) {
      setState(1063);
      where();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnwindContext ------------------------------------------------------------------

MemgraphCypher::UnwindContext::UnwindContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::UnwindContext::UNWIND() {
  return getToken(MemgraphCypher::UNWIND, 0);
}

MemgraphCypher::ExpressionContext* MemgraphCypher::UnwindContext::expression() {
  return getRuleContext<MemgraphCypher::ExpressionContext>(0);
}

tree::TerminalNode* MemgraphCypher::UnwindContext::AS() {
  return getToken(MemgraphCypher::AS, 0);
}

MemgraphCypher::VariableContext* MemgraphCypher::UnwindContext::variable() {
  return getRuleContext<MemgraphCypher::VariableContext>(0);
}


size_t MemgraphCypher::UnwindContext::getRuleIndex() const {
  return MemgraphCypher::RuleUnwind;
}

void MemgraphCypher::UnwindContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnwind(this);
}

void MemgraphCypher::UnwindContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnwind(this);
}


std::any MemgraphCypher::UnwindContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitUnwind(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::UnwindContext* MemgraphCypher::unwind() {
  UnwindContext *_localctx = _tracker.createInstance<UnwindContext>(_ctx, getState());
  enterRule(_localctx, 194, MemgraphCypher::RuleUnwind);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1066);
    match(MemgraphCypher::UNWIND);
    setState(1067);
    expression();
    setState(1068);
    match(MemgraphCypher::AS);
    setState(1069);
    variable();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MergeContext ------------------------------------------------------------------

MemgraphCypher::MergeContext::MergeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::MergeContext::MERGE() {
  return getToken(MemgraphCypher::MERGE, 0);
}

MemgraphCypher::PatternPartContext* MemgraphCypher::MergeContext::patternPart() {
  return getRuleContext<MemgraphCypher::PatternPartContext>(0);
}

std::vector<MemgraphCypher::MergeActionContext *> MemgraphCypher::MergeContext::mergeAction() {
  return getRuleContexts<MemgraphCypher::MergeActionContext>();
}

MemgraphCypher::MergeActionContext* MemgraphCypher::MergeContext::mergeAction(size_t i) {
  return getRuleContext<MemgraphCypher::MergeActionContext>(i);
}


size_t MemgraphCypher::MergeContext::getRuleIndex() const {
  return MemgraphCypher::RuleMerge;
}

void MemgraphCypher::MergeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMerge(this);
}

void MemgraphCypher::MergeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMerge(this);
}


std::any MemgraphCypher::MergeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitMerge(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::MergeContext* MemgraphCypher::merge() {
  MergeContext *_localctx = _tracker.createInstance<MergeContext>(_ctx, getState());
  enterRule(_localctx, 196, MemgraphCypher::RuleMerge);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1071);
    match(MemgraphCypher::MERGE);
    setState(1072);
    patternPart();
    setState(1076);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::ON) {
      setState(1073);
      mergeAction();
      setState(1078);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MergeActionContext ------------------------------------------------------------------

MemgraphCypher::MergeActionContext::MergeActionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::MergeActionContext::ON() {
  return getToken(MemgraphCypher::ON, 0);
}

tree::TerminalNode* MemgraphCypher::MergeActionContext::MATCH() {
  return getToken(MemgraphCypher::MATCH, 0);
}

MemgraphCypher::SetContext* MemgraphCypher::MergeActionContext::set() {
  return getRuleContext<MemgraphCypher::SetContext>(0);
}

tree::TerminalNode* MemgraphCypher::MergeActionContext::CREATE() {
  return getToken(MemgraphCypher::CREATE, 0);
}


size_t MemgraphCypher::MergeActionContext::getRuleIndex() const {
  return MemgraphCypher::RuleMergeAction;
}

void MemgraphCypher::MergeActionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMergeAction(this);
}

void MemgraphCypher::MergeActionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMergeAction(this);
}


std::any MemgraphCypher::MergeActionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitMergeAction(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::MergeActionContext* MemgraphCypher::mergeAction() {
  MergeActionContext *_localctx = _tracker.createInstance<MergeActionContext>(_ctx, getState());
  enterRule(_localctx, 198, MemgraphCypher::RuleMergeAction);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1085);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1079);
      match(MemgraphCypher::ON);
      setState(1080);
      match(MemgraphCypher::MATCH);
      setState(1081);
      set();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1082);
      match(MemgraphCypher::ON);
      setState(1083);
      match(MemgraphCypher::CREATE);
      setState(1084);
      set();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateContext ------------------------------------------------------------------

MemgraphCypher::CreateContext::CreateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::CreateContext::CREATE() {
  return getToken(MemgraphCypher::CREATE, 0);
}

MemgraphCypher::PatternContext* MemgraphCypher::CreateContext::pattern() {
  return getRuleContext<MemgraphCypher::PatternContext>(0);
}


size_t MemgraphCypher::CreateContext::getRuleIndex() const {
  return MemgraphCypher::RuleCreate;
}

void MemgraphCypher::CreateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate(this);
}

void MemgraphCypher::CreateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate(this);
}


std::any MemgraphCypher::CreateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitCreate(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::CreateContext* MemgraphCypher::create() {
  CreateContext *_localctx = _tracker.createInstance<CreateContext>(_ctx, getState());
  enterRule(_localctx, 200, MemgraphCypher::RuleCreate);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1087);
    match(MemgraphCypher::CREATE);
    setState(1088);
    pattern();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetContext ------------------------------------------------------------------

MemgraphCypher::SetContext::SetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::SetContext::SET() {
  return getToken(MemgraphCypher::SET, 0);
}

std::vector<MemgraphCypher::SetItemContext *> MemgraphCypher::SetContext::setItem() {
  return getRuleContexts<MemgraphCypher::SetItemContext>();
}

MemgraphCypher::SetItemContext* MemgraphCypher::SetContext::setItem(size_t i) {
  return getRuleContext<MemgraphCypher::SetItemContext>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::SetContext::COMMA() {
  return getTokens(MemgraphCypher::COMMA);
}

tree::TerminalNode* MemgraphCypher::SetContext::COMMA(size_t i) {
  return getToken(MemgraphCypher::COMMA, i);
}


size_t MemgraphCypher::SetContext::getRuleIndex() const {
  return MemgraphCypher::RuleSet;
}

void MemgraphCypher::SetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSet(this);
}

void MemgraphCypher::SetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSet(this);
}


std::any MemgraphCypher::SetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitSet(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::SetContext* MemgraphCypher::set() {
  SetContext *_localctx = _tracker.createInstance<SetContext>(_ctx, getState());
  enterRule(_localctx, 202, MemgraphCypher::RuleSet);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1090);
    match(MemgraphCypher::SET);
    setState(1091);
    setItem();
    setState(1096);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::COMMA) {
      setState(1092);
      match(MemgraphCypher::COMMA);
      setState(1093);
      setItem();
      setState(1098);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetItemContext ------------------------------------------------------------------

MemgraphCypher::SetItemContext::SetItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::PropertyExpressionContext* MemgraphCypher::SetItemContext::propertyExpression() {
  return getRuleContext<MemgraphCypher::PropertyExpressionContext>(0);
}

tree::TerminalNode* MemgraphCypher::SetItemContext::EQ() {
  return getToken(MemgraphCypher::EQ, 0);
}

MemgraphCypher::ExpressionContext* MemgraphCypher::SetItemContext::expression() {
  return getRuleContext<MemgraphCypher::ExpressionContext>(0);
}

MemgraphCypher::VariableContext* MemgraphCypher::SetItemContext::variable() {
  return getRuleContext<MemgraphCypher::VariableContext>(0);
}

tree::TerminalNode* MemgraphCypher::SetItemContext::PLUS_EQ() {
  return getToken(MemgraphCypher::PLUS_EQ, 0);
}

MemgraphCypher::NodeLabelsContext* MemgraphCypher::SetItemContext::nodeLabels() {
  return getRuleContext<MemgraphCypher::NodeLabelsContext>(0);
}


size_t MemgraphCypher::SetItemContext::getRuleIndex() const {
  return MemgraphCypher::RuleSetItem;
}

void MemgraphCypher::SetItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetItem(this);
}

void MemgraphCypher::SetItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetItem(this);
}


std::any MemgraphCypher::SetItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitSetItem(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::SetItemContext* MemgraphCypher::setItem() {
  SetItemContext *_localctx = _tracker.createInstance<SetItemContext>(_ctx, getState());
  enterRule(_localctx, 204, MemgraphCypher::RuleSetItem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1114);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1099);
      propertyExpression();
      setState(1100);
      match(MemgraphCypher::EQ);
      setState(1101);
      expression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1103);
      variable();
      setState(1104);
      match(MemgraphCypher::EQ);
      setState(1105);
      expression();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1107);
      variable();
      setState(1108);
      match(MemgraphCypher::PLUS_EQ);
      setState(1109);
      expression();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1111);
      variable();
      setState(1112);
      nodeLabels();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CypherDeleteContext ------------------------------------------------------------------

MemgraphCypher::CypherDeleteContext::CypherDeleteContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::CypherDeleteContext::DELETE() {
  return getToken(MemgraphCypher::DELETE, 0);
}

std::vector<MemgraphCypher::ExpressionContext *> MemgraphCypher::CypherDeleteContext::expression() {
  return getRuleContexts<MemgraphCypher::ExpressionContext>();
}

MemgraphCypher::ExpressionContext* MemgraphCypher::CypherDeleteContext::expression(size_t i) {
  return getRuleContext<MemgraphCypher::ExpressionContext>(i);
}

tree::TerminalNode* MemgraphCypher::CypherDeleteContext::DETACH() {
  return getToken(MemgraphCypher::DETACH, 0);
}

std::vector<tree::TerminalNode *> MemgraphCypher::CypherDeleteContext::COMMA() {
  return getTokens(MemgraphCypher::COMMA);
}

tree::TerminalNode* MemgraphCypher::CypherDeleteContext::COMMA(size_t i) {
  return getToken(MemgraphCypher::COMMA, i);
}


size_t MemgraphCypher::CypherDeleteContext::getRuleIndex() const {
  return MemgraphCypher::RuleCypherDelete;
}

void MemgraphCypher::CypherDeleteContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCypherDelete(this);
}

void MemgraphCypher::CypherDeleteContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCypherDelete(this);
}


std::any MemgraphCypher::CypherDeleteContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitCypherDelete(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::CypherDeleteContext* MemgraphCypher::cypherDelete() {
  CypherDeleteContext *_localctx = _tracker.createInstance<CypherDeleteContext>(_ctx, getState());
  enterRule(_localctx, 206, MemgraphCypher::RuleCypherDelete);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1117);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::DETACH) {
      setState(1116);
      match(MemgraphCypher::DETACH);
    }
    setState(1119);
    match(MemgraphCypher::DELETE);
    setState(1120);
    expression();
    setState(1125);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::COMMA) {
      setState(1121);
      match(MemgraphCypher::COMMA);
      setState(1122);
      expression();
      setState(1127);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RemoveContext ------------------------------------------------------------------

MemgraphCypher::RemoveContext::RemoveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::RemoveContext::REMOVE() {
  return getToken(MemgraphCypher::REMOVE, 0);
}

std::vector<MemgraphCypher::RemoveItemContext *> MemgraphCypher::RemoveContext::removeItem() {
  return getRuleContexts<MemgraphCypher::RemoveItemContext>();
}

MemgraphCypher::RemoveItemContext* MemgraphCypher::RemoveContext::removeItem(size_t i) {
  return getRuleContext<MemgraphCypher::RemoveItemContext>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::RemoveContext::COMMA() {
  return getTokens(MemgraphCypher::COMMA);
}

tree::TerminalNode* MemgraphCypher::RemoveContext::COMMA(size_t i) {
  return getToken(MemgraphCypher::COMMA, i);
}


size_t MemgraphCypher::RemoveContext::getRuleIndex() const {
  return MemgraphCypher::RuleRemove;
}

void MemgraphCypher::RemoveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRemove(this);
}

void MemgraphCypher::RemoveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRemove(this);
}


std::any MemgraphCypher::RemoveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitRemove(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::RemoveContext* MemgraphCypher::remove() {
  RemoveContext *_localctx = _tracker.createInstance<RemoveContext>(_ctx, getState());
  enterRule(_localctx, 208, MemgraphCypher::RuleRemove);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1128);
    match(MemgraphCypher::REMOVE);
    setState(1129);
    removeItem();
    setState(1134);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::COMMA) {
      setState(1130);
      match(MemgraphCypher::COMMA);
      setState(1131);
      removeItem();
      setState(1136);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RemoveItemContext ------------------------------------------------------------------

MemgraphCypher::RemoveItemContext::RemoveItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::VariableContext* MemgraphCypher::RemoveItemContext::variable() {
  return getRuleContext<MemgraphCypher::VariableContext>(0);
}

MemgraphCypher::NodeLabelsContext* MemgraphCypher::RemoveItemContext::nodeLabels() {
  return getRuleContext<MemgraphCypher::NodeLabelsContext>(0);
}

MemgraphCypher::PropertyExpressionContext* MemgraphCypher::RemoveItemContext::propertyExpression() {
  return getRuleContext<MemgraphCypher::PropertyExpressionContext>(0);
}


size_t MemgraphCypher::RemoveItemContext::getRuleIndex() const {
  return MemgraphCypher::RuleRemoveItem;
}

void MemgraphCypher::RemoveItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRemoveItem(this);
}

void MemgraphCypher::RemoveItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRemoveItem(this);
}


std::any MemgraphCypher::RemoveItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitRemoveItem(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::RemoveItemContext* MemgraphCypher::removeItem() {
  RemoveItemContext *_localctx = _tracker.createInstance<RemoveItemContext>(_ctx, getState());
  enterRule(_localctx, 210, MemgraphCypher::RuleRemoveItem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1141);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1137);
      variable();
      setState(1138);
      nodeLabels();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1140);
      propertyExpression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WithContext ------------------------------------------------------------------

MemgraphCypher::WithContext::WithContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::WithContext::WITH() {
  return getToken(MemgraphCypher::WITH, 0);
}

MemgraphCypher::ReturnBodyContext* MemgraphCypher::WithContext::returnBody() {
  return getRuleContext<MemgraphCypher::ReturnBodyContext>(0);
}

tree::TerminalNode* MemgraphCypher::WithContext::DISTINCT() {
  return getToken(MemgraphCypher::DISTINCT, 0);
}

MemgraphCypher::WhereContext* MemgraphCypher::WithContext::where() {
  return getRuleContext<MemgraphCypher::WhereContext>(0);
}


size_t MemgraphCypher::WithContext::getRuleIndex() const {
  return MemgraphCypher::RuleWith;
}

void MemgraphCypher::WithContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWith(this);
}

void MemgraphCypher::WithContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWith(this);
}


std::any MemgraphCypher::WithContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitWith(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::WithContext* MemgraphCypher::with() {
  WithContext *_localctx = _tracker.createInstance<WithContext>(_ctx, getState());
  enterRule(_localctx, 212, MemgraphCypher::RuleWith);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1143);
    match(MemgraphCypher::WITH);
    setState(1145);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx)) {
    case 1: {
      setState(1144);
      match(MemgraphCypher::DISTINCT);
      break;
    }

    default:
      break;
    }
    setState(1147);
    returnBody();
    setState(1149);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::WHERE) {
      setState(1148);
      where();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CypherReturnContext ------------------------------------------------------------------

MemgraphCypher::CypherReturnContext::CypherReturnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::CypherReturnContext::RETURN() {
  return getToken(MemgraphCypher::RETURN, 0);
}

MemgraphCypher::ReturnBodyContext* MemgraphCypher::CypherReturnContext::returnBody() {
  return getRuleContext<MemgraphCypher::ReturnBodyContext>(0);
}

tree::TerminalNode* MemgraphCypher::CypherReturnContext::DISTINCT() {
  return getToken(MemgraphCypher::DISTINCT, 0);
}


size_t MemgraphCypher::CypherReturnContext::getRuleIndex() const {
  return MemgraphCypher::RuleCypherReturn;
}

void MemgraphCypher::CypherReturnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCypherReturn(this);
}

void MemgraphCypher::CypherReturnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCypherReturn(this);
}


std::any MemgraphCypher::CypherReturnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitCypherReturn(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::CypherReturnContext* MemgraphCypher::cypherReturn() {
  CypherReturnContext *_localctx = _tracker.createInstance<CypherReturnContext>(_ctx, getState());
  enterRule(_localctx, 214, MemgraphCypher::RuleCypherReturn);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1151);
    match(MemgraphCypher::RETURN);
    setState(1153);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx)) {
    case 1: {
      setState(1152);
      match(MemgraphCypher::DISTINCT);
      break;
    }

    default:
      break;
    }
    setState(1155);
    returnBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CallProcedureContext ------------------------------------------------------------------

MemgraphCypher::CallProcedureContext::CallProcedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::CallProcedureContext::CALL() {
  return getToken(MemgraphCypher::CALL, 0);
}

MemgraphCypher::ProcedureNameContext* MemgraphCypher::CallProcedureContext::procedureName() {
  return getRuleContext<MemgraphCypher::ProcedureNameContext>(0);
}

tree::TerminalNode* MemgraphCypher::CallProcedureContext::LPAREN() {
  return getToken(MemgraphCypher::LPAREN, 0);
}

tree::TerminalNode* MemgraphCypher::CallProcedureContext::RPAREN() {
  return getToken(MemgraphCypher::RPAREN, 0);
}

std::vector<MemgraphCypher::ExpressionContext *> MemgraphCypher::CallProcedureContext::expression() {
  return getRuleContexts<MemgraphCypher::ExpressionContext>();
}

MemgraphCypher::ExpressionContext* MemgraphCypher::CallProcedureContext::expression(size_t i) {
  return getRuleContext<MemgraphCypher::ExpressionContext>(i);
}

MemgraphCypher::ProcedureMemoryLimitContext* MemgraphCypher::CallProcedureContext::procedureMemoryLimit() {
  return getRuleContext<MemgraphCypher::ProcedureMemoryLimitContext>(0);
}

MemgraphCypher::YieldProcedureResultsContext* MemgraphCypher::CallProcedureContext::yieldProcedureResults() {
  return getRuleContext<MemgraphCypher::YieldProcedureResultsContext>(0);
}

std::vector<tree::TerminalNode *> MemgraphCypher::CallProcedureContext::COMMA() {
  return getTokens(MemgraphCypher::COMMA);
}

tree::TerminalNode* MemgraphCypher::CallProcedureContext::COMMA(size_t i) {
  return getToken(MemgraphCypher::COMMA, i);
}


size_t MemgraphCypher::CallProcedureContext::getRuleIndex() const {
  return MemgraphCypher::RuleCallProcedure;
}

void MemgraphCypher::CallProcedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCallProcedure(this);
}

void MemgraphCypher::CallProcedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCallProcedure(this);
}


std::any MemgraphCypher::CallProcedureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitCallProcedure(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::CallProcedureContext* MemgraphCypher::callProcedure() {
  CallProcedureContext *_localctx = _tracker.createInstance<CallProcedureContext>(_ctx, getState());
  enterRule(_localctx, 216, MemgraphCypher::RuleCallProcedure);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1157);
    match(MemgraphCypher::CALL);
    setState(1158);
    procedureName();
    setState(1159);
    match(MemgraphCypher::LPAREN);
    setState(1168);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MemgraphCypher::AFTER)
      | (1ULL << MemgraphCypher::ALTER)
      | (1ULL << MemgraphCypher::ASYNC)
      | (1ULL << MemgraphCypher::AUTH)
      | (1ULL << MemgraphCypher::BAD)
      | (1ULL << MemgraphCypher::BATCH_INTERVAL)
      | (1ULL << MemgraphCypher::BATCH_LIMIT)
      | (1ULL << MemgraphCypher::BATCH_SIZE)
      | (1ULL << MemgraphCypher::BEFORE)
      | (1ULL << MemgraphCypher::BOOTSTRAP_SERVERS)
      | (1ULL << MemgraphCypher::CHECK)
      | (1ULL << MemgraphCypher::CLEAR)
      | (1ULL << MemgraphCypher::COMMIT)
      | (1ULL << MemgraphCypher::COMMITTED)
      | (1ULL << MemgraphCypher::CONFIG)
      | (1ULL << MemgraphCypher::CONFIGS)
      | (1ULL << MemgraphCypher::CONSUMER_GROUP)
      | (1ULL << MemgraphCypher::CREDENTIALS)
      | (1ULL << MemgraphCypher::CSV)
      | (1ULL << MemgraphCypher::DATA)
      | (1ULL << MemgraphCypher::DELIMITER)
      | (1ULL << MemgraphCypher::DATABASE)
      | (1ULL << MemgraphCypher::DENY)
      | (1ULL << MemgraphCypher::DROP)
      | (1ULL << MemgraphCypher::DUMP)
      | (1ULL << MemgraphCypher::EXECUTE)
      | (1ULL << MemgraphCypher::FOR)
      | (1ULL << MemgraphCypher::FOREACH)
      | (1ULL << MemgraphCypher::FREE)
      | (1ULL << MemgraphCypher::FROM)
      | (1ULL << MemgraphCypher::GLOBAL)
      | (1ULL << MemgraphCypher::GRANT)
      | (1ULL << MemgraphCypher::HEADER)
      | (1ULL << MemgraphCypher::IDENTIFIED)
      | (1ULL << MemgraphCypher::ISOLATION)
      | (1ULL << MemgraphCypher::KAFKA)
      | (1ULL << MemgraphCypher::LEVEL)
      | (1ULL << MemgraphCypher::LOAD)
      | (1ULL << MemgraphCypher::LOCK)
      | (1ULL << MemgraphCypher::MAIN)
      | (1ULL << MemgraphCypher::MODE)
      | (1ULL << MemgraphCypher::NEXT)
      | (1ULL << MemgraphCypher::NO)
      | (1ULL << MemgraphCypher::PASSWORD)
      | (1ULL << MemgraphCypher::PORT)
      | (1ULL << MemgraphCypher::PRIVILEGES)
      | (1ULL << MemgraphCypher::PULSAR)
      | (1ULL << MemgraphCypher::READ)
      | (1ULL << MemgraphCypher::REGISTER)
      | (1ULL << MemgraphCypher::REPLICA)
      | (1ULL << MemgraphCypher::REPLICAS)
      | (1ULL << MemgraphCypher::REPLICATION)
      | (1ULL << MemgraphCypher::REVOKE)
      | (1ULL << MemgraphCypher::ROLE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (MemgraphCypher::ROLES - 64))
      | (1ULL << (MemgraphCypher::QUOTE - 64))
      | (1ULL << (MemgraphCypher::SESSION - 64))
      | (1ULL << (MemgraphCypher::SETTING - 64))
      | (1ULL << (MemgraphCypher::SETTINGS - 64))
      | (1ULL << (MemgraphCypher::SNAPSHOT - 64))
      | (1ULL << (MemgraphCypher::START - 64))
      | (1ULL << (MemgraphCypher::STATS - 64))
      | (1ULL << (MemgraphCypher::STREAM - 64))
      | (1ULL << (MemgraphCypher::STREAMS - 64))
      | (1ULL << (MemgraphCypher::SYNC - 64))
      | (1ULL << (MemgraphCypher::TIMEOUT - 64))
      | (1ULL << (MemgraphCypher::TO - 64))
      | (1ULL << (MemgraphCypher::TOPICS - 64))
      | (1ULL << (MemgraphCypher::TRANSACTION - 64))
      | (1ULL << (MemgraphCypher::TRANSFORM - 64))
      | (1ULL << (MemgraphCypher::TRIGGER - 64))
      | (1ULL << (MemgraphCypher::TRIGGERS - 64))
      | (1ULL << (MemgraphCypher::UNCOMMITTED - 64))
      | (1ULL << (MemgraphCypher::UNLOCK - 64))
      | (1ULL << (MemgraphCypher::UPDATE - 64))
      | (1ULL << (MemgraphCypher::USER - 64))
      | (1ULL << (MemgraphCypher::USERS - 64))
      | (1ULL << (MemgraphCypher::VERSION - 64))
      | (1ULL << (MemgraphCypher::LPAREN - 64))
      | (1ULL << (MemgraphCypher::LBRACK - 64))
      | (1ULL << (MemgraphCypher::LBRACE - 64))
      | (1ULL << (MemgraphCypher::DOLLAR - 64))
      | (1ULL << (MemgraphCypher::PLUS - 64))
      | (1ULL << (MemgraphCypher::MINUS - 64))
      | (1ULL << (MemgraphCypher::ALL - 64))
      | (1ULL << (MemgraphCypher::AND - 64))
      | (1ULL << (MemgraphCypher::ANY - 64))
      | (1ULL << (MemgraphCypher::AS - 64))
      | (1ULL << (MemgraphCypher::ASC - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (MemgraphCypher::ASCENDING - 128))
      | (1ULL << (MemgraphCypher::ASSERT - 128))
      | (1ULL << (MemgraphCypher::BFS - 128))
      | (1ULL << (MemgraphCypher::BY - 128))
      | (1ULL << (MemgraphCypher::CALL - 128))
      | (1ULL << (MemgraphCypher::CASE - 128))
      | (1ULL << (MemgraphCypher::COALESCE - 128))
      | (1ULL << (MemgraphCypher::CONSTRAINT - 128))
      | (1ULL << (MemgraphCypher::CONTAINS - 128))
      | (1ULL << (MemgraphCypher::COUNT - 128))
      | (1ULL << (MemgraphCypher::CREATE - 128))
      | (1ULL << (MemgraphCypher::CYPHERNULL - 128))
      | (1ULL << (MemgraphCypher::DELETE - 128))
      | (1ULL << (MemgraphCypher::DESC - 128))
      | (1ULL << (MemgraphCypher::DESCENDING - 128))
      | (1ULL << (MemgraphCypher::DETACH - 128))
      | (1ULL << (MemgraphCypher::DISTINCT - 128))
      | (1ULL << (MemgraphCypher::ELSE - 128))
      | (1ULL << (MemgraphCypher::END - 128))
      | (1ULL << (MemgraphCypher::ENDS - 128))
      | (1ULL << (MemgraphCypher::EXISTS - 128))
      | (1ULL << (MemgraphCypher::EXPLAIN - 128))
      | (1ULL << (MemgraphCypher::EXTRACT - 128))
      | (1ULL << (MemgraphCypher::FALSE - 128))
      | (1ULL << (MemgraphCypher::FILTER - 128))
      | (1ULL << (MemgraphCypher::IN - 128))
      | (1ULL << (MemgraphCypher::INDEX - 128))
      | (1ULL << (MemgraphCypher::INFO - 128))
      | (1ULL << (MemgraphCypher::IS - 128))
      | (1ULL << (MemgraphCypher::KEY - 128))
      | (1ULL << (MemgraphCypher::LIMIT - 128))
      | (1ULL << (MemgraphCypher::L_SKIP - 128))
      | (1ULL << (MemgraphCypher::MATCH - 128))
      | (1ULL << (MemgraphCypher::MERGE - 128))
      | (1ULL << (MemgraphCypher::NODE - 128))
      | (1ULL << (MemgraphCypher::NONE - 128))
      | (1ULL << (MemgraphCypher::NOT - 128))
      | (1ULL << (MemgraphCypher::ON - 128))
      | (1ULL << (MemgraphCypher::OPTIONAL - 128))
      | (1ULL << (MemgraphCypher::OR - 128))
      | (1ULL << (MemgraphCypher::ORDER - 128))
      | (1ULL << (MemgraphCypher::PROCEDURE - 128))
      | (1ULL << (MemgraphCypher::PROFILE - 128))
      | (1ULL << (MemgraphCypher::QUERY - 128))
      | (1ULL << (MemgraphCypher::REDUCE - 128))
      | (1ULL << (MemgraphCypher::REMOVE - 128))
      | (1ULL << (MemgraphCypher::RETURN - 128))
      | (1ULL << (MemgraphCypher::SET - 128))
      | (1ULL << (MemgraphCypher::SHOW - 128))
      | (1ULL << (MemgraphCypher::SINGLE - 128))
      | (1ULL << (MemgraphCypher::STARTS - 128))
      | (1ULL << (MemgraphCypher::STORAGE - 128))
      | (1ULL << (MemgraphCypher::THEN - 128))
      | (1ULL << (MemgraphCypher::TRUE - 128))
      | (1ULL << (MemgraphCypher::UNION - 128))
      | (1ULL << (MemgraphCypher::UNIQUE - 128))
      | (1ULL << (MemgraphCypher::UNWIND - 128))
      | (1ULL << (MemgraphCypher::WHEN - 128))
      | (1ULL << (MemgraphCypher::WHERE - 128))
      | (1ULL << (MemgraphCypher::WITH - 128)))) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & ((1ULL << (MemgraphCypher::WSHORTEST - 192))
      | (1ULL << (MemgraphCypher::XOR - 192))
      | (1ULL << (MemgraphCypher::YIELD - 192))
      | (1ULL << (MemgraphCypher::StringLiteral - 192))
      | (1ULL << (MemgraphCypher::DecimalLiteral - 192))
      | (1ULL << (MemgraphCypher::OctalLiteral - 192))
      | (1ULL << (MemgraphCypher::HexadecimalLiteral - 192))
      | (1ULL << (MemgraphCypher::FloatingLiteral - 192))
      | (1ULL << (MemgraphCypher::UnescapedSymbolicName - 192))
      | (1ULL << (MemgraphCypher::EscapedSymbolicName - 192)))) != 0)) {
      setState(1160);
      expression();
      setState(1165);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MemgraphCypher::COMMA) {
        setState(1161);
        match(MemgraphCypher::COMMA);
        setState(1162);
        expression();
        setState(1167);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1170);
    match(MemgraphCypher::RPAREN);
    setState(1172);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::PROCEDURE) {
      setState(1171);
      procedureMemoryLimit();
    }
    setState(1175);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::YIELD) {
      setState(1174);
      yieldProcedureResults();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureNameContext ------------------------------------------------------------------

MemgraphCypher::ProcedureNameContext::ProcedureNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MemgraphCypher::SymbolicNameContext *> MemgraphCypher::ProcedureNameContext::symbolicName() {
  return getRuleContexts<MemgraphCypher::SymbolicNameContext>();
}

MemgraphCypher::SymbolicNameContext* MemgraphCypher::ProcedureNameContext::symbolicName(size_t i) {
  return getRuleContext<MemgraphCypher::SymbolicNameContext>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::ProcedureNameContext::DOT() {
  return getTokens(MemgraphCypher::DOT);
}

tree::TerminalNode* MemgraphCypher::ProcedureNameContext::DOT(size_t i) {
  return getToken(MemgraphCypher::DOT, i);
}


size_t MemgraphCypher::ProcedureNameContext::getRuleIndex() const {
  return MemgraphCypher::RuleProcedureName;
}

void MemgraphCypher::ProcedureNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureName(this);
}

void MemgraphCypher::ProcedureNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureName(this);
}


std::any MemgraphCypher::ProcedureNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitProcedureName(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ProcedureNameContext* MemgraphCypher::procedureName() {
  ProcedureNameContext *_localctx = _tracker.createInstance<ProcedureNameContext>(_ctx, getState());
  enterRule(_localctx, 218, MemgraphCypher::RuleProcedureName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1177);
    symbolicName();
    setState(1182);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::DOT) {
      setState(1178);
      match(MemgraphCypher::DOT);
      setState(1179);
      symbolicName();
      setState(1184);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- YieldProcedureResultsContext ------------------------------------------------------------------

MemgraphCypher::YieldProcedureResultsContext::YieldProcedureResultsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::YieldProcedureResultsContext::YIELD() {
  return getToken(MemgraphCypher::YIELD, 0);
}

tree::TerminalNode* MemgraphCypher::YieldProcedureResultsContext::ASTERISK() {
  return getToken(MemgraphCypher::ASTERISK, 0);
}

std::vector<MemgraphCypher::ProcedureResultContext *> MemgraphCypher::YieldProcedureResultsContext::procedureResult() {
  return getRuleContexts<MemgraphCypher::ProcedureResultContext>();
}

MemgraphCypher::ProcedureResultContext* MemgraphCypher::YieldProcedureResultsContext::procedureResult(size_t i) {
  return getRuleContext<MemgraphCypher::ProcedureResultContext>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::YieldProcedureResultsContext::COMMA() {
  return getTokens(MemgraphCypher::COMMA);
}

tree::TerminalNode* MemgraphCypher::YieldProcedureResultsContext::COMMA(size_t i) {
  return getToken(MemgraphCypher::COMMA, i);
}


size_t MemgraphCypher::YieldProcedureResultsContext::getRuleIndex() const {
  return MemgraphCypher::RuleYieldProcedureResults;
}

void MemgraphCypher::YieldProcedureResultsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterYieldProcedureResults(this);
}

void MemgraphCypher::YieldProcedureResultsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitYieldProcedureResults(this);
}


std::any MemgraphCypher::YieldProcedureResultsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitYieldProcedureResults(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::YieldProcedureResultsContext* MemgraphCypher::yieldProcedureResults() {
  YieldProcedureResultsContext *_localctx = _tracker.createInstance<YieldProcedureResultsContext>(_ctx, getState());
  enterRule(_localctx, 220, MemgraphCypher::RuleYieldProcedureResults);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1185);
    match(MemgraphCypher::YIELD);
    setState(1195);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MemgraphCypher::ASTERISK: {
        setState(1186);
        match(MemgraphCypher::ASTERISK);
        break;
      }

      case MemgraphCypher::AFTER:
      case MemgraphCypher::ALTER:
      case MemgraphCypher::ASYNC:
      case MemgraphCypher::AUTH:
      case MemgraphCypher::BAD:
      case MemgraphCypher::BATCH_INTERVAL:
      case MemgraphCypher::BATCH_LIMIT:
      case MemgraphCypher::BATCH_SIZE:
      case MemgraphCypher::BEFORE:
      case MemgraphCypher::BOOTSTRAP_SERVERS:
      case MemgraphCypher::CHECK:
      case MemgraphCypher::CLEAR:
      case MemgraphCypher::COMMIT:
      case MemgraphCypher::COMMITTED:
      case MemgraphCypher::CONFIG:
      case MemgraphCypher::CONFIGS:
      case MemgraphCypher::CONSUMER_GROUP:
      case MemgraphCypher::CREDENTIALS:
      case MemgraphCypher::CSV:
      case MemgraphCypher::DATA:
      case MemgraphCypher::DELIMITER:
      case MemgraphCypher::DATABASE:
      case MemgraphCypher::DENY:
      case MemgraphCypher::DROP:
      case MemgraphCypher::DUMP:
      case MemgraphCypher::EXECUTE:
      case MemgraphCypher::FOR:
      case MemgraphCypher::FOREACH:
      case MemgraphCypher::FREE:
      case MemgraphCypher::FROM:
      case MemgraphCypher::GLOBAL:
      case MemgraphCypher::GRANT:
      case MemgraphCypher::HEADER:
      case MemgraphCypher::IDENTIFIED:
      case MemgraphCypher::ISOLATION:
      case MemgraphCypher::KAFKA:
      case MemgraphCypher::LEVEL:
      case MemgraphCypher::LOAD:
      case MemgraphCypher::LOCK:
      case MemgraphCypher::MAIN:
      case MemgraphCypher::MODE:
      case MemgraphCypher::NEXT:
      case MemgraphCypher::NO:
      case MemgraphCypher::PASSWORD:
      case MemgraphCypher::PORT:
      case MemgraphCypher::PRIVILEGES:
      case MemgraphCypher::PULSAR:
      case MemgraphCypher::READ:
      case MemgraphCypher::REGISTER:
      case MemgraphCypher::REPLICA:
      case MemgraphCypher::REPLICAS:
      case MemgraphCypher::REPLICATION:
      case MemgraphCypher::REVOKE:
      case MemgraphCypher::ROLE:
      case MemgraphCypher::ROLES:
      case MemgraphCypher::QUOTE:
      case MemgraphCypher::SESSION:
      case MemgraphCypher::SETTING:
      case MemgraphCypher::SETTINGS:
      case MemgraphCypher::SNAPSHOT:
      case MemgraphCypher::START:
      case MemgraphCypher::STATS:
      case MemgraphCypher::STREAM:
      case MemgraphCypher::STREAMS:
      case MemgraphCypher::SYNC:
      case MemgraphCypher::TIMEOUT:
      case MemgraphCypher::TO:
      case MemgraphCypher::TOPICS:
      case MemgraphCypher::TRANSACTION:
      case MemgraphCypher::TRANSFORM:
      case MemgraphCypher::TRIGGER:
      case MemgraphCypher::TRIGGERS:
      case MemgraphCypher::UNCOMMITTED:
      case MemgraphCypher::UNLOCK:
      case MemgraphCypher::UPDATE:
      case MemgraphCypher::USER:
      case MemgraphCypher::USERS:
      case MemgraphCypher::VERSION:
      case MemgraphCypher::ALL:
      case MemgraphCypher::AND:
      case MemgraphCypher::ANY:
      case MemgraphCypher::AS:
      case MemgraphCypher::ASC:
      case MemgraphCypher::ASCENDING:
      case MemgraphCypher::ASSERT:
      case MemgraphCypher::BFS:
      case MemgraphCypher::BY:
      case MemgraphCypher::CALL:
      case MemgraphCypher::CASE:
      case MemgraphCypher::CONSTRAINT:
      case MemgraphCypher::CONTAINS:
      case MemgraphCypher::COUNT:
      case MemgraphCypher::CREATE:
      case MemgraphCypher::CYPHERNULL:
      case MemgraphCypher::DELETE:
      case MemgraphCypher::DESC:
      case MemgraphCypher::DESCENDING:
      case MemgraphCypher::DETACH:
      case MemgraphCypher::DISTINCT:
      case MemgraphCypher::ELSE:
      case MemgraphCypher::END:
      case MemgraphCypher::ENDS:
      case MemgraphCypher::EXISTS:
      case MemgraphCypher::EXPLAIN:
      case MemgraphCypher::EXTRACT:
      case MemgraphCypher::FALSE:
      case MemgraphCypher::FILTER:
      case MemgraphCypher::IN:
      case MemgraphCypher::INDEX:
      case MemgraphCypher::INFO:
      case MemgraphCypher::IS:
      case MemgraphCypher::KEY:
      case MemgraphCypher::LIMIT:
      case MemgraphCypher::L_SKIP:
      case MemgraphCypher::MATCH:
      case MemgraphCypher::MERGE:
      case MemgraphCypher::NODE:
      case MemgraphCypher::NONE:
      case MemgraphCypher::NOT:
      case MemgraphCypher::ON:
      case MemgraphCypher::OPTIONAL:
      case MemgraphCypher::OR:
      case MemgraphCypher::ORDER:
      case MemgraphCypher::PROCEDURE:
      case MemgraphCypher::PROFILE:
      case MemgraphCypher::QUERY:
      case MemgraphCypher::REDUCE:
      case MemgraphCypher::REMOVE:
      case MemgraphCypher::RETURN:
      case MemgraphCypher::SET:
      case MemgraphCypher::SHOW:
      case MemgraphCypher::SINGLE:
      case MemgraphCypher::STARTS:
      case MemgraphCypher::STORAGE:
      case MemgraphCypher::THEN:
      case MemgraphCypher::TRUE:
      case MemgraphCypher::UNION:
      case MemgraphCypher::UNIQUE:
      case MemgraphCypher::UNWIND:
      case MemgraphCypher::WHEN:
      case MemgraphCypher::WHERE:
      case MemgraphCypher::WITH:
      case MemgraphCypher::WSHORTEST:
      case MemgraphCypher::XOR:
      case MemgraphCypher::YIELD:
      case MemgraphCypher::UnescapedSymbolicName:
      case MemgraphCypher::EscapedSymbolicName: {
        setState(1187);
        procedureResult();
        setState(1192);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MemgraphCypher::COMMA) {
          setState(1188);
          match(MemgraphCypher::COMMA);
          setState(1189);
          procedureResult();
          setState(1194);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MemoryLimitContext ------------------------------------------------------------------

MemgraphCypher::MemoryLimitContext::MemoryLimitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::MemoryLimitContext::MEMORY() {
  return getToken(MemgraphCypher::MEMORY, 0);
}

tree::TerminalNode* MemgraphCypher::MemoryLimitContext::UNLIMITED() {
  return getToken(MemgraphCypher::UNLIMITED, 0);
}

tree::TerminalNode* MemgraphCypher::MemoryLimitContext::LIMIT() {
  return getToken(MemgraphCypher::LIMIT, 0);
}

MemgraphCypher::LiteralContext* MemgraphCypher::MemoryLimitContext::literal() {
  return getRuleContext<MemgraphCypher::LiteralContext>(0);
}

tree::TerminalNode* MemgraphCypher::MemoryLimitContext::MB() {
  return getToken(MemgraphCypher::MB, 0);
}

tree::TerminalNode* MemgraphCypher::MemoryLimitContext::KB() {
  return getToken(MemgraphCypher::KB, 0);
}


size_t MemgraphCypher::MemoryLimitContext::getRuleIndex() const {
  return MemgraphCypher::RuleMemoryLimit;
}

void MemgraphCypher::MemoryLimitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemoryLimit(this);
}

void MemgraphCypher::MemoryLimitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemoryLimit(this);
}


std::any MemgraphCypher::MemoryLimitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitMemoryLimit(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::MemoryLimitContext* MemgraphCypher::memoryLimit() {
  MemoryLimitContext *_localctx = _tracker.createInstance<MemoryLimitContext>(_ctx, getState());
  enterRule(_localctx, 222, MemgraphCypher::RuleMemoryLimit);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1197);
    match(MemgraphCypher::MEMORY);
    setState(1203);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MemgraphCypher::UNLIMITED: {
        setState(1198);
        match(MemgraphCypher::UNLIMITED);
        break;
      }

      case MemgraphCypher::LIMIT: {
        setState(1199);
        match(MemgraphCypher::LIMIT);
        setState(1200);
        literal();
        setState(1201);
        _la = _input->LA(1);
        if (!(_la == MemgraphCypher::KB

        || _la == MemgraphCypher::MB)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryMemoryLimitContext ------------------------------------------------------------------

MemgraphCypher::QueryMemoryLimitContext::QueryMemoryLimitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::QueryMemoryLimitContext::QUERY() {
  return getToken(MemgraphCypher::QUERY, 0);
}

MemgraphCypher::MemoryLimitContext* MemgraphCypher::QueryMemoryLimitContext::memoryLimit() {
  return getRuleContext<MemgraphCypher::MemoryLimitContext>(0);
}


size_t MemgraphCypher::QueryMemoryLimitContext::getRuleIndex() const {
  return MemgraphCypher::RuleQueryMemoryLimit;
}

void MemgraphCypher::QueryMemoryLimitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryMemoryLimit(this);
}

void MemgraphCypher::QueryMemoryLimitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryMemoryLimit(this);
}


std::any MemgraphCypher::QueryMemoryLimitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitQueryMemoryLimit(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::QueryMemoryLimitContext* MemgraphCypher::queryMemoryLimit() {
  QueryMemoryLimitContext *_localctx = _tracker.createInstance<QueryMemoryLimitContext>(_ctx, getState());
  enterRule(_localctx, 224, MemgraphCypher::RuleQueryMemoryLimit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1205);
    match(MemgraphCypher::QUERY);
    setState(1206);
    memoryLimit();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureMemoryLimitContext ------------------------------------------------------------------

MemgraphCypher::ProcedureMemoryLimitContext::ProcedureMemoryLimitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ProcedureMemoryLimitContext::PROCEDURE() {
  return getToken(MemgraphCypher::PROCEDURE, 0);
}

MemgraphCypher::MemoryLimitContext* MemgraphCypher::ProcedureMemoryLimitContext::memoryLimit() {
  return getRuleContext<MemgraphCypher::MemoryLimitContext>(0);
}


size_t MemgraphCypher::ProcedureMemoryLimitContext::getRuleIndex() const {
  return MemgraphCypher::RuleProcedureMemoryLimit;
}

void MemgraphCypher::ProcedureMemoryLimitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureMemoryLimit(this);
}

void MemgraphCypher::ProcedureMemoryLimitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureMemoryLimit(this);
}


std::any MemgraphCypher::ProcedureMemoryLimitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitProcedureMemoryLimit(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ProcedureMemoryLimitContext* MemgraphCypher::procedureMemoryLimit() {
  ProcedureMemoryLimitContext *_localctx = _tracker.createInstance<ProcedureMemoryLimitContext>(_ctx, getState());
  enterRule(_localctx, 226, MemgraphCypher::RuleProcedureMemoryLimit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1208);
    match(MemgraphCypher::PROCEDURE);
    setState(1209);
    memoryLimit();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureResultContext ------------------------------------------------------------------

MemgraphCypher::ProcedureResultContext::ProcedureResultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MemgraphCypher::VariableContext *> MemgraphCypher::ProcedureResultContext::variable() {
  return getRuleContexts<MemgraphCypher::VariableContext>();
}

MemgraphCypher::VariableContext* MemgraphCypher::ProcedureResultContext::variable(size_t i) {
  return getRuleContext<MemgraphCypher::VariableContext>(i);
}

tree::TerminalNode* MemgraphCypher::ProcedureResultContext::AS() {
  return getToken(MemgraphCypher::AS, 0);
}


size_t MemgraphCypher::ProcedureResultContext::getRuleIndex() const {
  return MemgraphCypher::RuleProcedureResult;
}

void MemgraphCypher::ProcedureResultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureResult(this);
}

void MemgraphCypher::ProcedureResultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureResult(this);
}


std::any MemgraphCypher::ProcedureResultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitProcedureResult(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ProcedureResultContext* MemgraphCypher::procedureResult() {
  ProcedureResultContext *_localctx = _tracker.createInstance<ProcedureResultContext>(_ctx, getState());
  enterRule(_localctx, 228, MemgraphCypher::RuleProcedureResult);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1216);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1211);
      variable();
      setState(1212);
      match(MemgraphCypher::AS);
      setState(1213);
      variable();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1215);
      variable();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnBodyContext ------------------------------------------------------------------

MemgraphCypher::ReturnBodyContext::ReturnBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::ReturnItemsContext* MemgraphCypher::ReturnBodyContext::returnItems() {
  return getRuleContext<MemgraphCypher::ReturnItemsContext>(0);
}

MemgraphCypher::OrderContext* MemgraphCypher::ReturnBodyContext::order() {
  return getRuleContext<MemgraphCypher::OrderContext>(0);
}

MemgraphCypher::SkipContext* MemgraphCypher::ReturnBodyContext::skip() {
  return getRuleContext<MemgraphCypher::SkipContext>(0);
}

MemgraphCypher::LimitContext* MemgraphCypher::ReturnBodyContext::limit() {
  return getRuleContext<MemgraphCypher::LimitContext>(0);
}


size_t MemgraphCypher::ReturnBodyContext::getRuleIndex() const {
  return MemgraphCypher::RuleReturnBody;
}

void MemgraphCypher::ReturnBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturnBody(this);
}

void MemgraphCypher::ReturnBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturnBody(this);
}


std::any MemgraphCypher::ReturnBodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitReturnBody(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ReturnBodyContext* MemgraphCypher::returnBody() {
  ReturnBodyContext *_localctx = _tracker.createInstance<ReturnBodyContext>(_ctx, getState());
  enterRule(_localctx, 230, MemgraphCypher::RuleReturnBody);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1218);
    returnItems();
    setState(1220);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::ORDER) {
      setState(1219);
      order();
    }
    setState(1223);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::L_SKIP) {
      setState(1222);
      skip();
    }
    setState(1226);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::LIMIT) {
      setState(1225);
      limit();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnItemsContext ------------------------------------------------------------------

MemgraphCypher::ReturnItemsContext::ReturnItemsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ReturnItemsContext::ASTERISK() {
  return getToken(MemgraphCypher::ASTERISK, 0);
}

std::vector<tree::TerminalNode *> MemgraphCypher::ReturnItemsContext::COMMA() {
  return getTokens(MemgraphCypher::COMMA);
}

tree::TerminalNode* MemgraphCypher::ReturnItemsContext::COMMA(size_t i) {
  return getToken(MemgraphCypher::COMMA, i);
}

std::vector<MemgraphCypher::ReturnItemContext *> MemgraphCypher::ReturnItemsContext::returnItem() {
  return getRuleContexts<MemgraphCypher::ReturnItemContext>();
}

MemgraphCypher::ReturnItemContext* MemgraphCypher::ReturnItemsContext::returnItem(size_t i) {
  return getRuleContext<MemgraphCypher::ReturnItemContext>(i);
}


size_t MemgraphCypher::ReturnItemsContext::getRuleIndex() const {
  return MemgraphCypher::RuleReturnItems;
}

void MemgraphCypher::ReturnItemsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturnItems(this);
}

void MemgraphCypher::ReturnItemsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturnItems(this);
}


std::any MemgraphCypher::ReturnItemsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitReturnItems(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ReturnItemsContext* MemgraphCypher::returnItems() {
  ReturnItemsContext *_localctx = _tracker.createInstance<ReturnItemsContext>(_ctx, getState());
  enterRule(_localctx, 232, MemgraphCypher::RuleReturnItems);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1244);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MemgraphCypher::ASTERISK: {
        enterOuterAlt(_localctx, 1);
        setState(1228);
        match(MemgraphCypher::ASTERISK);
        setState(1233);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MemgraphCypher::COMMA) {
          setState(1229);
          match(MemgraphCypher::COMMA);
          setState(1230);
          returnItem();
          setState(1235);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MemgraphCypher::AFTER:
      case MemgraphCypher::ALTER:
      case MemgraphCypher::ASYNC:
      case MemgraphCypher::AUTH:
      case MemgraphCypher::BAD:
      case MemgraphCypher::BATCH_INTERVAL:
      case MemgraphCypher::BATCH_LIMIT:
      case MemgraphCypher::BATCH_SIZE:
      case MemgraphCypher::BEFORE:
      case MemgraphCypher::BOOTSTRAP_SERVERS:
      case MemgraphCypher::CHECK:
      case MemgraphCypher::CLEAR:
      case MemgraphCypher::COMMIT:
      case MemgraphCypher::COMMITTED:
      case MemgraphCypher::CONFIG:
      case MemgraphCypher::CONFIGS:
      case MemgraphCypher::CONSUMER_GROUP:
      case MemgraphCypher::CREDENTIALS:
      case MemgraphCypher::CSV:
      case MemgraphCypher::DATA:
      case MemgraphCypher::DELIMITER:
      case MemgraphCypher::DATABASE:
      case MemgraphCypher::DENY:
      case MemgraphCypher::DROP:
      case MemgraphCypher::DUMP:
      case MemgraphCypher::EXECUTE:
      case MemgraphCypher::FOR:
      case MemgraphCypher::FOREACH:
      case MemgraphCypher::FREE:
      case MemgraphCypher::FROM:
      case MemgraphCypher::GLOBAL:
      case MemgraphCypher::GRANT:
      case MemgraphCypher::HEADER:
      case MemgraphCypher::IDENTIFIED:
      case MemgraphCypher::ISOLATION:
      case MemgraphCypher::KAFKA:
      case MemgraphCypher::LEVEL:
      case MemgraphCypher::LOAD:
      case MemgraphCypher::LOCK:
      case MemgraphCypher::MAIN:
      case MemgraphCypher::MODE:
      case MemgraphCypher::NEXT:
      case MemgraphCypher::NO:
      case MemgraphCypher::PASSWORD:
      case MemgraphCypher::PORT:
      case MemgraphCypher::PRIVILEGES:
      case MemgraphCypher::PULSAR:
      case MemgraphCypher::READ:
      case MemgraphCypher::REGISTER:
      case MemgraphCypher::REPLICA:
      case MemgraphCypher::REPLICAS:
      case MemgraphCypher::REPLICATION:
      case MemgraphCypher::REVOKE:
      case MemgraphCypher::ROLE:
      case MemgraphCypher::ROLES:
      case MemgraphCypher::QUOTE:
      case MemgraphCypher::SESSION:
      case MemgraphCypher::SETTING:
      case MemgraphCypher::SETTINGS:
      case MemgraphCypher::SNAPSHOT:
      case MemgraphCypher::START:
      case MemgraphCypher::STATS:
      case MemgraphCypher::STREAM:
      case MemgraphCypher::STREAMS:
      case MemgraphCypher::SYNC:
      case MemgraphCypher::TIMEOUT:
      case MemgraphCypher::TO:
      case MemgraphCypher::TOPICS:
      case MemgraphCypher::TRANSACTION:
      case MemgraphCypher::TRANSFORM:
      case MemgraphCypher::TRIGGER:
      case MemgraphCypher::TRIGGERS:
      case MemgraphCypher::UNCOMMITTED:
      case MemgraphCypher::UNLOCK:
      case MemgraphCypher::UPDATE:
      case MemgraphCypher::USER:
      case MemgraphCypher::USERS:
      case MemgraphCypher::VERSION:
      case MemgraphCypher::LPAREN:
      case MemgraphCypher::LBRACK:
      case MemgraphCypher::LBRACE:
      case MemgraphCypher::DOLLAR:
      case MemgraphCypher::PLUS:
      case MemgraphCypher::MINUS:
      case MemgraphCypher::ALL:
      case MemgraphCypher::AND:
      case MemgraphCypher::ANY:
      case MemgraphCypher::AS:
      case MemgraphCypher::ASC:
      case MemgraphCypher::ASCENDING:
      case MemgraphCypher::ASSERT:
      case MemgraphCypher::BFS:
      case MemgraphCypher::BY:
      case MemgraphCypher::CALL:
      case MemgraphCypher::CASE:
      case MemgraphCypher::COALESCE:
      case MemgraphCypher::CONSTRAINT:
      case MemgraphCypher::CONTAINS:
      case MemgraphCypher::COUNT:
      case MemgraphCypher::CREATE:
      case MemgraphCypher::CYPHERNULL:
      case MemgraphCypher::DELETE:
      case MemgraphCypher::DESC:
      case MemgraphCypher::DESCENDING:
      case MemgraphCypher::DETACH:
      case MemgraphCypher::DISTINCT:
      case MemgraphCypher::ELSE:
      case MemgraphCypher::END:
      case MemgraphCypher::ENDS:
      case MemgraphCypher::EXISTS:
      case MemgraphCypher::EXPLAIN:
      case MemgraphCypher::EXTRACT:
      case MemgraphCypher::FALSE:
      case MemgraphCypher::FILTER:
      case MemgraphCypher::IN:
      case MemgraphCypher::INDEX:
      case MemgraphCypher::INFO:
      case MemgraphCypher::IS:
      case MemgraphCypher::KEY:
      case MemgraphCypher::LIMIT:
      case MemgraphCypher::L_SKIP:
      case MemgraphCypher::MATCH:
      case MemgraphCypher::MERGE:
      case MemgraphCypher::NODE:
      case MemgraphCypher::NONE:
      case MemgraphCypher::NOT:
      case MemgraphCypher::ON:
      case MemgraphCypher::OPTIONAL:
      case MemgraphCypher::OR:
      case MemgraphCypher::ORDER:
      case MemgraphCypher::PROCEDURE:
      case MemgraphCypher::PROFILE:
      case MemgraphCypher::QUERY:
      case MemgraphCypher::REDUCE:
      case MemgraphCypher::REMOVE:
      case MemgraphCypher::RETURN:
      case MemgraphCypher::SET:
      case MemgraphCypher::SHOW:
      case MemgraphCypher::SINGLE:
      case MemgraphCypher::STARTS:
      case MemgraphCypher::STORAGE:
      case MemgraphCypher::THEN:
      case MemgraphCypher::TRUE:
      case MemgraphCypher::UNION:
      case MemgraphCypher::UNIQUE:
      case MemgraphCypher::UNWIND:
      case MemgraphCypher::WHEN:
      case MemgraphCypher::WHERE:
      case MemgraphCypher::WITH:
      case MemgraphCypher::WSHORTEST:
      case MemgraphCypher::XOR:
      case MemgraphCypher::YIELD:
      case MemgraphCypher::StringLiteral:
      case MemgraphCypher::DecimalLiteral:
      case MemgraphCypher::OctalLiteral:
      case MemgraphCypher::HexadecimalLiteral:
      case MemgraphCypher::FloatingLiteral:
      case MemgraphCypher::UnescapedSymbolicName:
      case MemgraphCypher::EscapedSymbolicName: {
        enterOuterAlt(_localctx, 2);
        setState(1236);
        returnItem();
        setState(1241);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MemgraphCypher::COMMA) {
          setState(1237);
          match(MemgraphCypher::COMMA);
          setState(1238);
          returnItem();
          setState(1243);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnItemContext ------------------------------------------------------------------

MemgraphCypher::ReturnItemContext::ReturnItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::ExpressionContext* MemgraphCypher::ReturnItemContext::expression() {
  return getRuleContext<MemgraphCypher::ExpressionContext>(0);
}

tree::TerminalNode* MemgraphCypher::ReturnItemContext::AS() {
  return getToken(MemgraphCypher::AS, 0);
}

MemgraphCypher::VariableContext* MemgraphCypher::ReturnItemContext::variable() {
  return getRuleContext<MemgraphCypher::VariableContext>(0);
}


size_t MemgraphCypher::ReturnItemContext::getRuleIndex() const {
  return MemgraphCypher::RuleReturnItem;
}

void MemgraphCypher::ReturnItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturnItem(this);
}

void MemgraphCypher::ReturnItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturnItem(this);
}


std::any MemgraphCypher::ReturnItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitReturnItem(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ReturnItemContext* MemgraphCypher::returnItem() {
  ReturnItemContext *_localctx = _tracker.createInstance<ReturnItemContext>(_ctx, getState());
  enterRule(_localctx, 234, MemgraphCypher::RuleReturnItem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1251);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1246);
      expression();
      setState(1247);
      match(MemgraphCypher::AS);
      setState(1248);
      variable();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1250);
      expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OrderContext ------------------------------------------------------------------

MemgraphCypher::OrderContext::OrderContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::OrderContext::ORDER() {
  return getToken(MemgraphCypher::ORDER, 0);
}

tree::TerminalNode* MemgraphCypher::OrderContext::BY() {
  return getToken(MemgraphCypher::BY, 0);
}

std::vector<MemgraphCypher::SortItemContext *> MemgraphCypher::OrderContext::sortItem() {
  return getRuleContexts<MemgraphCypher::SortItemContext>();
}

MemgraphCypher::SortItemContext* MemgraphCypher::OrderContext::sortItem(size_t i) {
  return getRuleContext<MemgraphCypher::SortItemContext>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::OrderContext::COMMA() {
  return getTokens(MemgraphCypher::COMMA);
}

tree::TerminalNode* MemgraphCypher::OrderContext::COMMA(size_t i) {
  return getToken(MemgraphCypher::COMMA, i);
}


size_t MemgraphCypher::OrderContext::getRuleIndex() const {
  return MemgraphCypher::RuleOrder;
}

void MemgraphCypher::OrderContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrder(this);
}

void MemgraphCypher::OrderContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrder(this);
}


std::any MemgraphCypher::OrderContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitOrder(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::OrderContext* MemgraphCypher::order() {
  OrderContext *_localctx = _tracker.createInstance<OrderContext>(_ctx, getState());
  enterRule(_localctx, 236, MemgraphCypher::RuleOrder);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1253);
    match(MemgraphCypher::ORDER);
    setState(1254);
    match(MemgraphCypher::BY);
    setState(1255);
    sortItem();
    setState(1260);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::COMMA) {
      setState(1256);
      match(MemgraphCypher::COMMA);
      setState(1257);
      sortItem();
      setState(1262);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SkipContext ------------------------------------------------------------------

MemgraphCypher::SkipContext::SkipContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::SkipContext::L_SKIP() {
  return getToken(MemgraphCypher::L_SKIP, 0);
}

MemgraphCypher::ExpressionContext* MemgraphCypher::SkipContext::expression() {
  return getRuleContext<MemgraphCypher::ExpressionContext>(0);
}


size_t MemgraphCypher::SkipContext::getRuleIndex() const {
  return MemgraphCypher::RuleSkip;
}

void MemgraphCypher::SkipContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSkip(this);
}

void MemgraphCypher::SkipContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSkip(this);
}


std::any MemgraphCypher::SkipContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitSkip(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::SkipContext* MemgraphCypher::skip() {
  SkipContext *_localctx = _tracker.createInstance<SkipContext>(_ctx, getState());
  enterRule(_localctx, 238, MemgraphCypher::RuleSkip);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1263);
    match(MemgraphCypher::L_SKIP);
    setState(1264);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LimitContext ------------------------------------------------------------------

MemgraphCypher::LimitContext::LimitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::LimitContext::LIMIT() {
  return getToken(MemgraphCypher::LIMIT, 0);
}

MemgraphCypher::ExpressionContext* MemgraphCypher::LimitContext::expression() {
  return getRuleContext<MemgraphCypher::ExpressionContext>(0);
}


size_t MemgraphCypher::LimitContext::getRuleIndex() const {
  return MemgraphCypher::RuleLimit;
}

void MemgraphCypher::LimitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLimit(this);
}

void MemgraphCypher::LimitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLimit(this);
}


std::any MemgraphCypher::LimitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitLimit(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::LimitContext* MemgraphCypher::limit() {
  LimitContext *_localctx = _tracker.createInstance<LimitContext>(_ctx, getState());
  enterRule(_localctx, 240, MemgraphCypher::RuleLimit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1266);
    match(MemgraphCypher::LIMIT);
    setState(1267);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SortItemContext ------------------------------------------------------------------

MemgraphCypher::SortItemContext::SortItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::ExpressionContext* MemgraphCypher::SortItemContext::expression() {
  return getRuleContext<MemgraphCypher::ExpressionContext>(0);
}

tree::TerminalNode* MemgraphCypher::SortItemContext::ASCENDING() {
  return getToken(MemgraphCypher::ASCENDING, 0);
}

tree::TerminalNode* MemgraphCypher::SortItemContext::ASC() {
  return getToken(MemgraphCypher::ASC, 0);
}

tree::TerminalNode* MemgraphCypher::SortItemContext::DESCENDING() {
  return getToken(MemgraphCypher::DESCENDING, 0);
}

tree::TerminalNode* MemgraphCypher::SortItemContext::DESC() {
  return getToken(MemgraphCypher::DESC, 0);
}


size_t MemgraphCypher::SortItemContext::getRuleIndex() const {
  return MemgraphCypher::RuleSortItem;
}

void MemgraphCypher::SortItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSortItem(this);
}

void MemgraphCypher::SortItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSortItem(this);
}


std::any MemgraphCypher::SortItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitSortItem(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::SortItemContext* MemgraphCypher::sortItem() {
  SortItemContext *_localctx = _tracker.createInstance<SortItemContext>(_ctx, getState());
  enterRule(_localctx, 242, MemgraphCypher::RuleSortItem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1269);
    expression();
    setState(1271);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 127) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 127)) & ((1ULL << (MemgraphCypher::ASC - 127))
      | (1ULL << (MemgraphCypher::ASCENDING - 127))
      | (1ULL << (MemgraphCypher::DESC - 127))
      | (1ULL << (MemgraphCypher::DESCENDING - 127)))) != 0)) {
      setState(1270);
      _la = _input->LA(1);
      if (!(((((_la - 127) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 127)) & ((1ULL << (MemgraphCypher::ASC - 127))
        | (1ULL << (MemgraphCypher::ASCENDING - 127))
        | (1ULL << (MemgraphCypher::DESC - 127))
        | (1ULL << (MemgraphCypher::DESCENDING - 127)))) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhereContext ------------------------------------------------------------------

MemgraphCypher::WhereContext::WhereContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::WhereContext::WHERE() {
  return getToken(MemgraphCypher::WHERE, 0);
}

MemgraphCypher::ExpressionContext* MemgraphCypher::WhereContext::expression() {
  return getRuleContext<MemgraphCypher::ExpressionContext>(0);
}


size_t MemgraphCypher::WhereContext::getRuleIndex() const {
  return MemgraphCypher::RuleWhere;
}

void MemgraphCypher::WhereContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhere(this);
}

void MemgraphCypher::WhereContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhere(this);
}


std::any MemgraphCypher::WhereContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitWhere(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::WhereContext* MemgraphCypher::where() {
  WhereContext *_localctx = _tracker.createInstance<WhereContext>(_ctx, getState());
  enterRule(_localctx, 244, MemgraphCypher::RuleWhere);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1273);
    match(MemgraphCypher::WHERE);
    setState(1274);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PatternContext ------------------------------------------------------------------

MemgraphCypher::PatternContext::PatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MemgraphCypher::PatternPartContext *> MemgraphCypher::PatternContext::patternPart() {
  return getRuleContexts<MemgraphCypher::PatternPartContext>();
}

MemgraphCypher::PatternPartContext* MemgraphCypher::PatternContext::patternPart(size_t i) {
  return getRuleContext<MemgraphCypher::PatternPartContext>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::PatternContext::COMMA() {
  return getTokens(MemgraphCypher::COMMA);
}

tree::TerminalNode* MemgraphCypher::PatternContext::COMMA(size_t i) {
  return getToken(MemgraphCypher::COMMA, i);
}


size_t MemgraphCypher::PatternContext::getRuleIndex() const {
  return MemgraphCypher::RulePattern;
}

void MemgraphCypher::PatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPattern(this);
}

void MemgraphCypher::PatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPattern(this);
}


std::any MemgraphCypher::PatternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitPattern(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::PatternContext* MemgraphCypher::pattern() {
  PatternContext *_localctx = _tracker.createInstance<PatternContext>(_ctx, getState());
  enterRule(_localctx, 246, MemgraphCypher::RulePattern);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1276);
    patternPart();
    setState(1281);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::COMMA) {
      setState(1277);
      match(MemgraphCypher::COMMA);
      setState(1278);
      patternPart();
      setState(1283);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PatternPartContext ------------------------------------------------------------------

MemgraphCypher::PatternPartContext::PatternPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::VariableContext* MemgraphCypher::PatternPartContext::variable() {
  return getRuleContext<MemgraphCypher::VariableContext>(0);
}

tree::TerminalNode* MemgraphCypher::PatternPartContext::EQ() {
  return getToken(MemgraphCypher::EQ, 0);
}

MemgraphCypher::AnonymousPatternPartContext* MemgraphCypher::PatternPartContext::anonymousPatternPart() {
  return getRuleContext<MemgraphCypher::AnonymousPatternPartContext>(0);
}


size_t MemgraphCypher::PatternPartContext::getRuleIndex() const {
  return MemgraphCypher::RulePatternPart;
}

void MemgraphCypher::PatternPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPatternPart(this);
}

void MemgraphCypher::PatternPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPatternPart(this);
}


std::any MemgraphCypher::PatternPartContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitPatternPart(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::PatternPartContext* MemgraphCypher::patternPart() {
  PatternPartContext *_localctx = _tracker.createInstance<PatternPartContext>(_ctx, getState());
  enterRule(_localctx, 248, MemgraphCypher::RulePatternPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1289);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MemgraphCypher::AFTER:
      case MemgraphCypher::ALTER:
      case MemgraphCypher::ASYNC:
      case MemgraphCypher::AUTH:
      case MemgraphCypher::BAD:
      case MemgraphCypher::BATCH_INTERVAL:
      case MemgraphCypher::BATCH_LIMIT:
      case MemgraphCypher::BATCH_SIZE:
      case MemgraphCypher::BEFORE:
      case MemgraphCypher::BOOTSTRAP_SERVERS:
      case MemgraphCypher::CHECK:
      case MemgraphCypher::CLEAR:
      case MemgraphCypher::COMMIT:
      case MemgraphCypher::COMMITTED:
      case MemgraphCypher::CONFIG:
      case MemgraphCypher::CONFIGS:
      case MemgraphCypher::CONSUMER_GROUP:
      case MemgraphCypher::CREDENTIALS:
      case MemgraphCypher::CSV:
      case MemgraphCypher::DATA:
      case MemgraphCypher::DELIMITER:
      case MemgraphCypher::DATABASE:
      case MemgraphCypher::DENY:
      case MemgraphCypher::DROP:
      case MemgraphCypher::DUMP:
      case MemgraphCypher::EXECUTE:
      case MemgraphCypher::FOR:
      case MemgraphCypher::FOREACH:
      case MemgraphCypher::FREE:
      case MemgraphCypher::FROM:
      case MemgraphCypher::GLOBAL:
      case MemgraphCypher::GRANT:
      case MemgraphCypher::HEADER:
      case MemgraphCypher::IDENTIFIED:
      case MemgraphCypher::ISOLATION:
      case MemgraphCypher::KAFKA:
      case MemgraphCypher::LEVEL:
      case MemgraphCypher::LOAD:
      case MemgraphCypher::LOCK:
      case MemgraphCypher::MAIN:
      case MemgraphCypher::MODE:
      case MemgraphCypher::NEXT:
      case MemgraphCypher::NO:
      case MemgraphCypher::PASSWORD:
      case MemgraphCypher::PORT:
      case MemgraphCypher::PRIVILEGES:
      case MemgraphCypher::PULSAR:
      case MemgraphCypher::READ:
      case MemgraphCypher::REGISTER:
      case MemgraphCypher::REPLICA:
      case MemgraphCypher::REPLICAS:
      case MemgraphCypher::REPLICATION:
      case MemgraphCypher::REVOKE:
      case MemgraphCypher::ROLE:
      case MemgraphCypher::ROLES:
      case MemgraphCypher::QUOTE:
      case MemgraphCypher::SESSION:
      case MemgraphCypher::SETTING:
      case MemgraphCypher::SETTINGS:
      case MemgraphCypher::SNAPSHOT:
      case MemgraphCypher::START:
      case MemgraphCypher::STATS:
      case MemgraphCypher::STREAM:
      case MemgraphCypher::STREAMS:
      case MemgraphCypher::SYNC:
      case MemgraphCypher::TIMEOUT:
      case MemgraphCypher::TO:
      case MemgraphCypher::TOPICS:
      case MemgraphCypher::TRANSACTION:
      case MemgraphCypher::TRANSFORM:
      case MemgraphCypher::TRIGGER:
      case MemgraphCypher::TRIGGERS:
      case MemgraphCypher::UNCOMMITTED:
      case MemgraphCypher::UNLOCK:
      case MemgraphCypher::UPDATE:
      case MemgraphCypher::USER:
      case MemgraphCypher::USERS:
      case MemgraphCypher::VERSION:
      case MemgraphCypher::ALL:
      case MemgraphCypher::AND:
      case MemgraphCypher::ANY:
      case MemgraphCypher::AS:
      case MemgraphCypher::ASC:
      case MemgraphCypher::ASCENDING:
      case MemgraphCypher::ASSERT:
      case MemgraphCypher::BFS:
      case MemgraphCypher::BY:
      case MemgraphCypher::CALL:
      case MemgraphCypher::CASE:
      case MemgraphCypher::CONSTRAINT:
      case MemgraphCypher::CONTAINS:
      case MemgraphCypher::COUNT:
      case MemgraphCypher::CREATE:
      case MemgraphCypher::CYPHERNULL:
      case MemgraphCypher::DELETE:
      case MemgraphCypher::DESC:
      case MemgraphCypher::DESCENDING:
      case MemgraphCypher::DETACH:
      case MemgraphCypher::DISTINCT:
      case MemgraphCypher::ELSE:
      case MemgraphCypher::END:
      case MemgraphCypher::ENDS:
      case MemgraphCypher::EXISTS:
      case MemgraphCypher::EXPLAIN:
      case MemgraphCypher::EXTRACT:
      case MemgraphCypher::FALSE:
      case MemgraphCypher::FILTER:
      case MemgraphCypher::IN:
      case MemgraphCypher::INDEX:
      case MemgraphCypher::INFO:
      case MemgraphCypher::IS:
      case MemgraphCypher::KEY:
      case MemgraphCypher::LIMIT:
      case MemgraphCypher::L_SKIP:
      case MemgraphCypher::MATCH:
      case MemgraphCypher::MERGE:
      case MemgraphCypher::NODE:
      case MemgraphCypher::NONE:
      case MemgraphCypher::NOT:
      case MemgraphCypher::ON:
      case MemgraphCypher::OPTIONAL:
      case MemgraphCypher::OR:
      case MemgraphCypher::ORDER:
      case MemgraphCypher::PROCEDURE:
      case MemgraphCypher::PROFILE:
      case MemgraphCypher::QUERY:
      case MemgraphCypher::REDUCE:
      case MemgraphCypher::REMOVE:
      case MemgraphCypher::RETURN:
      case MemgraphCypher::SET:
      case MemgraphCypher::SHOW:
      case MemgraphCypher::SINGLE:
      case MemgraphCypher::STARTS:
      case MemgraphCypher::STORAGE:
      case MemgraphCypher::THEN:
      case MemgraphCypher::TRUE:
      case MemgraphCypher::UNION:
      case MemgraphCypher::UNIQUE:
      case MemgraphCypher::UNWIND:
      case MemgraphCypher::WHEN:
      case MemgraphCypher::WHERE:
      case MemgraphCypher::WITH:
      case MemgraphCypher::WSHORTEST:
      case MemgraphCypher::XOR:
      case MemgraphCypher::YIELD:
      case MemgraphCypher::UnescapedSymbolicName:
      case MemgraphCypher::EscapedSymbolicName: {
        enterOuterAlt(_localctx, 1);
        setState(1284);
        variable();
        setState(1285);
        match(MemgraphCypher::EQ);
        setState(1286);
        anonymousPatternPart();
        break;
      }

      case MemgraphCypher::LPAREN: {
        enterOuterAlt(_localctx, 2);
        setState(1288);
        anonymousPatternPart();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnonymousPatternPartContext ------------------------------------------------------------------

MemgraphCypher::AnonymousPatternPartContext::AnonymousPatternPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::PatternElementContext* MemgraphCypher::AnonymousPatternPartContext::patternElement() {
  return getRuleContext<MemgraphCypher::PatternElementContext>(0);
}


size_t MemgraphCypher::AnonymousPatternPartContext::getRuleIndex() const {
  return MemgraphCypher::RuleAnonymousPatternPart;
}

void MemgraphCypher::AnonymousPatternPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnonymousPatternPart(this);
}

void MemgraphCypher::AnonymousPatternPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnonymousPatternPart(this);
}


std::any MemgraphCypher::AnonymousPatternPartContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitAnonymousPatternPart(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::AnonymousPatternPartContext* MemgraphCypher::anonymousPatternPart() {
  AnonymousPatternPartContext *_localctx = _tracker.createInstance<AnonymousPatternPartContext>(_ctx, getState());
  enterRule(_localctx, 250, MemgraphCypher::RuleAnonymousPatternPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1291);
    patternElement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PatternElementContext ------------------------------------------------------------------

MemgraphCypher::PatternElementContext::PatternElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::NodePatternContext* MemgraphCypher::PatternElementContext::nodePattern() {
  return getRuleContext<MemgraphCypher::NodePatternContext>(0);
}

std::vector<MemgraphCypher::PatternElementChainContext *> MemgraphCypher::PatternElementContext::patternElementChain() {
  return getRuleContexts<MemgraphCypher::PatternElementChainContext>();
}

MemgraphCypher::PatternElementChainContext* MemgraphCypher::PatternElementContext::patternElementChain(size_t i) {
  return getRuleContext<MemgraphCypher::PatternElementChainContext>(i);
}

tree::TerminalNode* MemgraphCypher::PatternElementContext::LPAREN() {
  return getToken(MemgraphCypher::LPAREN, 0);
}

MemgraphCypher::PatternElementContext* MemgraphCypher::PatternElementContext::patternElement() {
  return getRuleContext<MemgraphCypher::PatternElementContext>(0);
}

tree::TerminalNode* MemgraphCypher::PatternElementContext::RPAREN() {
  return getToken(MemgraphCypher::RPAREN, 0);
}


size_t MemgraphCypher::PatternElementContext::getRuleIndex() const {
  return MemgraphCypher::RulePatternElement;
}

void MemgraphCypher::PatternElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPatternElement(this);
}

void MemgraphCypher::PatternElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPatternElement(this);
}


std::any MemgraphCypher::PatternElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitPatternElement(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::PatternElementContext* MemgraphCypher::patternElement() {
  PatternElementContext *_localctx = _tracker.createInstance<PatternElementContext>(_ctx, getState());
  enterRule(_localctx, 252, MemgraphCypher::RulePatternElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1304);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1293);
      nodePattern();
      setState(1297);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 106) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 106)) & ((1ULL << (MemgraphCypher::LT - 106))
        | (1ULL << (MemgraphCypher::MINUS - 106))
        | (1ULL << (MemgraphCypher::LeftArrowHeadPart - 106))
        | (1ULL << (MemgraphCypher::DashPart - 106)))) != 0)) {
        setState(1294);
        patternElementChain();
        setState(1299);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1300);
      match(MemgraphCypher::LPAREN);
      setState(1301);
      patternElement();
      setState(1302);
      match(MemgraphCypher::RPAREN);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NodePatternContext ------------------------------------------------------------------

MemgraphCypher::NodePatternContext::NodePatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::NodePatternContext::LPAREN() {
  return getToken(MemgraphCypher::LPAREN, 0);
}

tree::TerminalNode* MemgraphCypher::NodePatternContext::RPAREN() {
  return getToken(MemgraphCypher::RPAREN, 0);
}

MemgraphCypher::VariableContext* MemgraphCypher::NodePatternContext::variable() {
  return getRuleContext<MemgraphCypher::VariableContext>(0);
}

MemgraphCypher::NodeLabelsContext* MemgraphCypher::NodePatternContext::nodeLabels() {
  return getRuleContext<MemgraphCypher::NodeLabelsContext>(0);
}

MemgraphCypher::PropertiesContext* MemgraphCypher::NodePatternContext::properties() {
  return getRuleContext<MemgraphCypher::PropertiesContext>(0);
}


size_t MemgraphCypher::NodePatternContext::getRuleIndex() const {
  return MemgraphCypher::RuleNodePattern;
}

void MemgraphCypher::NodePatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNodePattern(this);
}

void MemgraphCypher::NodePatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNodePattern(this);
}


std::any MemgraphCypher::NodePatternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitNodePattern(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::NodePatternContext* MemgraphCypher::nodePattern() {
  NodePatternContext *_localctx = _tracker.createInstance<NodePatternContext>(_ctx, getState());
  enterRule(_localctx, 254, MemgraphCypher::RuleNodePattern);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1306);
    match(MemgraphCypher::LPAREN);
    setState(1308);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MemgraphCypher::AFTER)
      | (1ULL << MemgraphCypher::ALTER)
      | (1ULL << MemgraphCypher::ASYNC)
      | (1ULL << MemgraphCypher::AUTH)
      | (1ULL << MemgraphCypher::BAD)
      | (1ULL << MemgraphCypher::BATCH_INTERVAL)
      | (1ULL << MemgraphCypher::BATCH_LIMIT)
      | (1ULL << MemgraphCypher::BATCH_SIZE)
      | (1ULL << MemgraphCypher::BEFORE)
      | (1ULL << MemgraphCypher::BOOTSTRAP_SERVERS)
      | (1ULL << MemgraphCypher::CHECK)
      | (1ULL << MemgraphCypher::CLEAR)
      | (1ULL << MemgraphCypher::COMMIT)
      | (1ULL << MemgraphCypher::COMMITTED)
      | (1ULL << MemgraphCypher::CONFIG)
      | (1ULL << MemgraphCypher::CONFIGS)
      | (1ULL << MemgraphCypher::CONSUMER_GROUP)
      | (1ULL << MemgraphCypher::CREDENTIALS)
      | (1ULL << MemgraphCypher::CSV)
      | (1ULL << MemgraphCypher::DATA)
      | (1ULL << MemgraphCypher::DELIMITER)
      | (1ULL << MemgraphCypher::DATABASE)
      | (1ULL << MemgraphCypher::DENY)
      | (1ULL << MemgraphCypher::DROP)
      | (1ULL << MemgraphCypher::DUMP)
      | (1ULL << MemgraphCypher::EXECUTE)
      | (1ULL << MemgraphCypher::FOR)
      | (1ULL << MemgraphCypher::FOREACH)
      | (1ULL << MemgraphCypher::FREE)
      | (1ULL << MemgraphCypher::FROM)
      | (1ULL << MemgraphCypher::GLOBAL)
      | (1ULL << MemgraphCypher::GRANT)
      | (1ULL << MemgraphCypher::HEADER)
      | (1ULL << MemgraphCypher::IDENTIFIED)
      | (1ULL << MemgraphCypher::ISOLATION)
      | (1ULL << MemgraphCypher::KAFKA)
      | (1ULL << MemgraphCypher::LEVEL)
      | (1ULL << MemgraphCypher::LOAD)
      | (1ULL << MemgraphCypher::LOCK)
      | (1ULL << MemgraphCypher::MAIN)
      | (1ULL << MemgraphCypher::MODE)
      | (1ULL << MemgraphCypher::NEXT)
      | (1ULL << MemgraphCypher::NO)
      | (1ULL << MemgraphCypher::PASSWORD)
      | (1ULL << MemgraphCypher::PORT)
      | (1ULL << MemgraphCypher::PRIVILEGES)
      | (1ULL << MemgraphCypher::PULSAR)
      | (1ULL << MemgraphCypher::READ)
      | (1ULL << MemgraphCypher::REGISTER)
      | (1ULL << MemgraphCypher::REPLICA)
      | (1ULL << MemgraphCypher::REPLICAS)
      | (1ULL << MemgraphCypher::REPLICATION)
      | (1ULL << MemgraphCypher::REVOKE)
      | (1ULL << MemgraphCypher::ROLE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (MemgraphCypher::ROLES - 64))
      | (1ULL << (MemgraphCypher::QUOTE - 64))
      | (1ULL << (MemgraphCypher::SESSION - 64))
      | (1ULL << (MemgraphCypher::SETTING - 64))
      | (1ULL << (MemgraphCypher::SETTINGS - 64))
      | (1ULL << (MemgraphCypher::SNAPSHOT - 64))
      | (1ULL << (MemgraphCypher::START - 64))
      | (1ULL << (MemgraphCypher::STATS - 64))
      | (1ULL << (MemgraphCypher::STREAM - 64))
      | (1ULL << (MemgraphCypher::STREAMS - 64))
      | (1ULL << (MemgraphCypher::SYNC - 64))
      | (1ULL << (MemgraphCypher::TIMEOUT - 64))
      | (1ULL << (MemgraphCypher::TO - 64))
      | (1ULL << (MemgraphCypher::TOPICS - 64))
      | (1ULL << (MemgraphCypher::TRANSACTION - 64))
      | (1ULL << (MemgraphCypher::TRANSFORM - 64))
      | (1ULL << (MemgraphCypher::TRIGGER - 64))
      | (1ULL << (MemgraphCypher::TRIGGERS - 64))
      | (1ULL << (MemgraphCypher::UNCOMMITTED - 64))
      | (1ULL << (MemgraphCypher::UNLOCK - 64))
      | (1ULL << (MemgraphCypher::UPDATE - 64))
      | (1ULL << (MemgraphCypher::USER - 64))
      | (1ULL << (MemgraphCypher::USERS - 64))
      | (1ULL << (MemgraphCypher::VERSION - 64))
      | (1ULL << (MemgraphCypher::ALL - 64))
      | (1ULL << (MemgraphCypher::AND - 64))
      | (1ULL << (MemgraphCypher::ANY - 64))
      | (1ULL << (MemgraphCypher::AS - 64))
      | (1ULL << (MemgraphCypher::ASC - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (MemgraphCypher::ASCENDING - 128))
      | (1ULL << (MemgraphCypher::ASSERT - 128))
      | (1ULL << (MemgraphCypher::BFS - 128))
      | (1ULL << (MemgraphCypher::BY - 128))
      | (1ULL << (MemgraphCypher::CALL - 128))
      | (1ULL << (MemgraphCypher::CASE - 128))
      | (1ULL << (MemgraphCypher::CONSTRAINT - 128))
      | (1ULL << (MemgraphCypher::CONTAINS - 128))
      | (1ULL << (MemgraphCypher::COUNT - 128))
      | (1ULL << (MemgraphCypher::CREATE - 128))
      | (1ULL << (MemgraphCypher::CYPHERNULL - 128))
      | (1ULL << (MemgraphCypher::DELETE - 128))
      | (1ULL << (MemgraphCypher::DESC - 128))
      | (1ULL << (MemgraphCypher::DESCENDING - 128))
      | (1ULL << (MemgraphCypher::DETACH - 128))
      | (1ULL << (MemgraphCypher::DISTINCT - 128))
      | (1ULL << (MemgraphCypher::ELSE - 128))
      | (1ULL << (MemgraphCypher::END - 128))
      | (1ULL << (MemgraphCypher::ENDS - 128))
      | (1ULL << (MemgraphCypher::EXISTS - 128))
      | (1ULL << (MemgraphCypher::EXPLAIN - 128))
      | (1ULL << (MemgraphCypher::EXTRACT - 128))
      | (1ULL << (MemgraphCypher::FALSE - 128))
      | (1ULL << (MemgraphCypher::FILTER - 128))
      | (1ULL << (MemgraphCypher::IN - 128))
      | (1ULL << (MemgraphCypher::INDEX - 128))
      | (1ULL << (MemgraphCypher::INFO - 128))
      | (1ULL << (MemgraphCypher::IS - 128))
      | (1ULL << (MemgraphCypher::KEY - 128))
      | (1ULL << (MemgraphCypher::LIMIT - 128))
      | (1ULL << (MemgraphCypher::L_SKIP - 128))
      | (1ULL << (MemgraphCypher::MATCH - 128))
      | (1ULL << (MemgraphCypher::MERGE - 128))
      | (1ULL << (MemgraphCypher::NODE - 128))
      | (1ULL << (MemgraphCypher::NONE - 128))
      | (1ULL << (MemgraphCypher::NOT - 128))
      | (1ULL << (MemgraphCypher::ON - 128))
      | (1ULL << (MemgraphCypher::OPTIONAL - 128))
      | (1ULL << (MemgraphCypher::OR - 128))
      | (1ULL << (MemgraphCypher::ORDER - 128))
      | (1ULL << (MemgraphCypher::PROCEDURE - 128))
      | (1ULL << (MemgraphCypher::PROFILE - 128))
      | (1ULL << (MemgraphCypher::QUERY - 128))
      | (1ULL << (MemgraphCypher::REDUCE - 128))
      | (1ULL << (MemgraphCypher::REMOVE - 128))
      | (1ULL << (MemgraphCypher::RETURN - 128))
      | (1ULL << (MemgraphCypher::SET - 128))
      | (1ULL << (MemgraphCypher::SHOW - 128))
      | (1ULL << (MemgraphCypher::SINGLE - 128))
      | (1ULL << (MemgraphCypher::STARTS - 128))
      | (1ULL << (MemgraphCypher::STORAGE - 128))
      | (1ULL << (MemgraphCypher::THEN - 128))
      | (1ULL << (MemgraphCypher::TRUE - 128))
      | (1ULL << (MemgraphCypher::UNION - 128))
      | (1ULL << (MemgraphCypher::UNIQUE - 128))
      | (1ULL << (MemgraphCypher::UNWIND - 128))
      | (1ULL << (MemgraphCypher::WHEN - 128))
      | (1ULL << (MemgraphCypher::WHERE - 128))
      | (1ULL << (MemgraphCypher::WITH - 128)))) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & ((1ULL << (MemgraphCypher::WSHORTEST - 192))
      | (1ULL << (MemgraphCypher::XOR - 192))
      | (1ULL << (MemgraphCypher::YIELD - 192))
      | (1ULL << (MemgraphCypher::UnescapedSymbolicName - 192))
      | (1ULL << (MemgraphCypher::EscapedSymbolicName - 192)))) != 0)) {
      setState(1307);
      variable();
    }
    setState(1311);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::COLON) {
      setState(1310);
      nodeLabels();
    }
    setState(1314);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::LBRACE

    || _la == MemgraphCypher::DOLLAR) {
      setState(1313);
      properties();
    }
    setState(1316);
    match(MemgraphCypher::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PatternElementChainContext ------------------------------------------------------------------

MemgraphCypher::PatternElementChainContext::PatternElementChainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::RelationshipPatternContext* MemgraphCypher::PatternElementChainContext::relationshipPattern() {
  return getRuleContext<MemgraphCypher::RelationshipPatternContext>(0);
}

MemgraphCypher::NodePatternContext* MemgraphCypher::PatternElementChainContext::nodePattern() {
  return getRuleContext<MemgraphCypher::NodePatternContext>(0);
}


size_t MemgraphCypher::PatternElementChainContext::getRuleIndex() const {
  return MemgraphCypher::RulePatternElementChain;
}

void MemgraphCypher::PatternElementChainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPatternElementChain(this);
}

void MemgraphCypher::PatternElementChainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPatternElementChain(this);
}


std::any MemgraphCypher::PatternElementChainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitPatternElementChain(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::PatternElementChainContext* MemgraphCypher::patternElementChain() {
  PatternElementChainContext *_localctx = _tracker.createInstance<PatternElementChainContext>(_ctx, getState());
  enterRule(_localctx, 256, MemgraphCypher::RulePatternElementChain);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1318);
    relationshipPattern();
    setState(1319);
    nodePattern();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelationshipPatternContext ------------------------------------------------------------------

MemgraphCypher::RelationshipPatternContext::RelationshipPatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::LeftArrowHeadContext* MemgraphCypher::RelationshipPatternContext::leftArrowHead() {
  return getRuleContext<MemgraphCypher::LeftArrowHeadContext>(0);
}

std::vector<MemgraphCypher::DashContext *> MemgraphCypher::RelationshipPatternContext::dash() {
  return getRuleContexts<MemgraphCypher::DashContext>();
}

MemgraphCypher::DashContext* MemgraphCypher::RelationshipPatternContext::dash(size_t i) {
  return getRuleContext<MemgraphCypher::DashContext>(i);
}

MemgraphCypher::RightArrowHeadContext* MemgraphCypher::RelationshipPatternContext::rightArrowHead() {
  return getRuleContext<MemgraphCypher::RightArrowHeadContext>(0);
}

MemgraphCypher::RelationshipDetailContext* MemgraphCypher::RelationshipPatternContext::relationshipDetail() {
  return getRuleContext<MemgraphCypher::RelationshipDetailContext>(0);
}


size_t MemgraphCypher::RelationshipPatternContext::getRuleIndex() const {
  return MemgraphCypher::RuleRelationshipPattern;
}

void MemgraphCypher::RelationshipPatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelationshipPattern(this);
}

void MemgraphCypher::RelationshipPatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelationshipPattern(this);
}


std::any MemgraphCypher::RelationshipPatternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitRelationshipPattern(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::RelationshipPatternContext* MemgraphCypher::relationshipPattern() {
  RelationshipPatternContext *_localctx = _tracker.createInstance<RelationshipPatternContext>(_ctx, getState());
  enterRule(_localctx, 258, MemgraphCypher::RuleRelationshipPattern);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1349);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 91, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1321);
      leftArrowHead();
      setState(1322);
      dash();
      setState(1324);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MemgraphCypher::LBRACK) {
        setState(1323);
        relationshipDetail();
      }
      setState(1326);
      dash();
      setState(1327);
      rightArrowHead();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1329);
      leftArrowHead();
      setState(1330);
      dash();
      setState(1332);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MemgraphCypher::LBRACK) {
        setState(1331);
        relationshipDetail();
      }
      setState(1334);
      dash();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1336);
      dash();
      setState(1338);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MemgraphCypher::LBRACK) {
        setState(1337);
        relationshipDetail();
      }
      setState(1340);
      dash();
      setState(1341);
      rightArrowHead();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1343);
      dash();
      setState(1345);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MemgraphCypher::LBRACK) {
        setState(1344);
        relationshipDetail();
      }
      setState(1347);
      dash();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LeftArrowHeadContext ------------------------------------------------------------------

MemgraphCypher::LeftArrowHeadContext::LeftArrowHeadContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::LeftArrowHeadContext::LT() {
  return getToken(MemgraphCypher::LT, 0);
}

tree::TerminalNode* MemgraphCypher::LeftArrowHeadContext::LeftArrowHeadPart() {
  return getToken(MemgraphCypher::LeftArrowHeadPart, 0);
}


size_t MemgraphCypher::LeftArrowHeadContext::getRuleIndex() const {
  return MemgraphCypher::RuleLeftArrowHead;
}

void MemgraphCypher::LeftArrowHeadContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLeftArrowHead(this);
}

void MemgraphCypher::LeftArrowHeadContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLeftArrowHead(this);
}


std::any MemgraphCypher::LeftArrowHeadContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitLeftArrowHead(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::LeftArrowHeadContext* MemgraphCypher::leftArrowHead() {
  LeftArrowHeadContext *_localctx = _tracker.createInstance<LeftArrowHeadContext>(_ctx, getState());
  enterRule(_localctx, 260, MemgraphCypher::RuleLeftArrowHead);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1351);
    _la = _input->LA(1);
    if (!(_la == MemgraphCypher::LT

    || _la == MemgraphCypher::LeftArrowHeadPart)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RightArrowHeadContext ------------------------------------------------------------------

MemgraphCypher::RightArrowHeadContext::RightArrowHeadContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::RightArrowHeadContext::GT() {
  return getToken(MemgraphCypher::GT, 0);
}

tree::TerminalNode* MemgraphCypher::RightArrowHeadContext::RightArrowHeadPart() {
  return getToken(MemgraphCypher::RightArrowHeadPart, 0);
}


size_t MemgraphCypher::RightArrowHeadContext::getRuleIndex() const {
  return MemgraphCypher::RuleRightArrowHead;
}

void MemgraphCypher::RightArrowHeadContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRightArrowHead(this);
}

void MemgraphCypher::RightArrowHeadContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRightArrowHead(this);
}


std::any MemgraphCypher::RightArrowHeadContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitRightArrowHead(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::RightArrowHeadContext* MemgraphCypher::rightArrowHead() {
  RightArrowHeadContext *_localctx = _tracker.createInstance<RightArrowHeadContext>(_ctx, getState());
  enterRule(_localctx, 262, MemgraphCypher::RuleRightArrowHead);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1353);
    _la = _input->LA(1);
    if (!(_la == MemgraphCypher::GT

    || _la == MemgraphCypher::RightArrowHeadPart)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DashContext ------------------------------------------------------------------

MemgraphCypher::DashContext::DashContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::DashContext::MINUS() {
  return getToken(MemgraphCypher::MINUS, 0);
}

tree::TerminalNode* MemgraphCypher::DashContext::DashPart() {
  return getToken(MemgraphCypher::DashPart, 0);
}


size_t MemgraphCypher::DashContext::getRuleIndex() const {
  return MemgraphCypher::RuleDash;
}

void MemgraphCypher::DashContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDash(this);
}

void MemgraphCypher::DashContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDash(this);
}


std::any MemgraphCypher::DashContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitDash(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::DashContext* MemgraphCypher::dash() {
  DashContext *_localctx = _tracker.createInstance<DashContext>(_ctx, getState());
  enterRule(_localctx, 264, MemgraphCypher::RuleDash);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1355);
    _la = _input->LA(1);
    if (!(_la == MemgraphCypher::MINUS

    || _la == MemgraphCypher::DashPart)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelationshipDetailContext ------------------------------------------------------------------

MemgraphCypher::RelationshipDetailContext::RelationshipDetailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::RelationshipDetailContext::LBRACK() {
  return getToken(MemgraphCypher::LBRACK, 0);
}

std::vector<MemgraphCypher::PropertiesContext *> MemgraphCypher::RelationshipDetailContext::properties() {
  return getRuleContexts<MemgraphCypher::PropertiesContext>();
}

MemgraphCypher::PropertiesContext* MemgraphCypher::RelationshipDetailContext::properties(size_t i) {
  return getRuleContext<MemgraphCypher::PropertiesContext>(i);
}

tree::TerminalNode* MemgraphCypher::RelationshipDetailContext::RBRACK() {
  return getToken(MemgraphCypher::RBRACK, 0);
}

MemgraphCypher::RelationshipTypesContext* MemgraphCypher::RelationshipDetailContext::relationshipTypes() {
  return getRuleContext<MemgraphCypher::RelationshipTypesContext>(0);
}

MemgraphCypher::VariableExpansionContext* MemgraphCypher::RelationshipDetailContext::variableExpansion() {
  return getRuleContext<MemgraphCypher::VariableExpansionContext>(0);
}

std::vector<MemgraphCypher::VariableContext *> MemgraphCypher::RelationshipDetailContext::variable() {
  return getRuleContexts<MemgraphCypher::VariableContext>();
}

MemgraphCypher::VariableContext* MemgraphCypher::RelationshipDetailContext::variable(size_t i) {
  return getRuleContext<MemgraphCypher::VariableContext>(i);
}

std::vector<MemgraphCypher::RelationshipLambdaContext *> MemgraphCypher::RelationshipDetailContext::relationshipLambda() {
  return getRuleContexts<MemgraphCypher::RelationshipLambdaContext>();
}

MemgraphCypher::RelationshipLambdaContext* MemgraphCypher::RelationshipDetailContext::relationshipLambda(size_t i) {
  return getRuleContext<MemgraphCypher::RelationshipLambdaContext>(i);
}


size_t MemgraphCypher::RelationshipDetailContext::getRuleIndex() const {
  return MemgraphCypher::RuleRelationshipDetail;
}

void MemgraphCypher::RelationshipDetailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelationshipDetail(this);
}

void MemgraphCypher::RelationshipDetailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelationshipDetail(this);
}


std::any MemgraphCypher::RelationshipDetailContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitRelationshipDetail(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::RelationshipDetailContext* MemgraphCypher::relationshipDetail() {
  RelationshipDetailContext *_localctx = _tracker.createInstance<RelationshipDetailContext>(_ctx, getState());
  enterRule(_localctx, 266, MemgraphCypher::RuleRelationshipDetail);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1414);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1357);
      match(MemgraphCypher::LBRACK);
      setState(1359);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MemgraphCypher::AFTER)
        | (1ULL << MemgraphCypher::ALTER)
        | (1ULL << MemgraphCypher::ASYNC)
        | (1ULL << MemgraphCypher::AUTH)
        | (1ULL << MemgraphCypher::BAD)
        | (1ULL << MemgraphCypher::BATCH_INTERVAL)
        | (1ULL << MemgraphCypher::BATCH_LIMIT)
        | (1ULL << MemgraphCypher::BATCH_SIZE)
        | (1ULL << MemgraphCypher::BEFORE)
        | (1ULL << MemgraphCypher::BOOTSTRAP_SERVERS)
        | (1ULL << MemgraphCypher::CHECK)
        | (1ULL << MemgraphCypher::CLEAR)
        | (1ULL << MemgraphCypher::COMMIT)
        | (1ULL << MemgraphCypher::COMMITTED)
        | (1ULL << MemgraphCypher::CONFIG)
        | (1ULL << MemgraphCypher::CONFIGS)
        | (1ULL << MemgraphCypher::CONSUMER_GROUP)
        | (1ULL << MemgraphCypher::CREDENTIALS)
        | (1ULL << MemgraphCypher::CSV)
        | (1ULL << MemgraphCypher::DATA)
        | (1ULL << MemgraphCypher::DELIMITER)
        | (1ULL << MemgraphCypher::DATABASE)
        | (1ULL << MemgraphCypher::DENY)
        | (1ULL << MemgraphCypher::DROP)
        | (1ULL << MemgraphCypher::DUMP)
        | (1ULL << MemgraphCypher::EXECUTE)
        | (1ULL << MemgraphCypher::FOR)
        | (1ULL << MemgraphCypher::FOREACH)
        | (1ULL << MemgraphCypher::FREE)
        | (1ULL << MemgraphCypher::FROM)
        | (1ULL << MemgraphCypher::GLOBAL)
        | (1ULL << MemgraphCypher::GRANT)
        | (1ULL << MemgraphCypher::HEADER)
        | (1ULL << MemgraphCypher::IDENTIFIED)
        | (1ULL << MemgraphCypher::ISOLATION)
        | (1ULL << MemgraphCypher::KAFKA)
        | (1ULL << MemgraphCypher::LEVEL)
        | (1ULL << MemgraphCypher::LOAD)
        | (1ULL << MemgraphCypher::LOCK)
        | (1ULL << MemgraphCypher::MAIN)
        | (1ULL << MemgraphCypher::MODE)
        | (1ULL << MemgraphCypher::NEXT)
        | (1ULL << MemgraphCypher::NO)
        | (1ULL << MemgraphCypher::PASSWORD)
        | (1ULL << MemgraphCypher::PORT)
        | (1ULL << MemgraphCypher::PRIVILEGES)
        | (1ULL << MemgraphCypher::PULSAR)
        | (1ULL << MemgraphCypher::READ)
        | (1ULL << MemgraphCypher::REGISTER)
        | (1ULL << MemgraphCypher::REPLICA)
        | (1ULL << MemgraphCypher::REPLICAS)
        | (1ULL << MemgraphCypher::REPLICATION)
        | (1ULL << MemgraphCypher::REVOKE)
        | (1ULL << MemgraphCypher::ROLE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (MemgraphCypher::ROLES - 64))
        | (1ULL << (MemgraphCypher::QUOTE - 64))
        | (1ULL << (MemgraphCypher::SESSION - 64))
        | (1ULL << (MemgraphCypher::SETTING - 64))
        | (1ULL << (MemgraphCypher::SETTINGS - 64))
        | (1ULL << (MemgraphCypher::SNAPSHOT - 64))
        | (1ULL << (MemgraphCypher::START - 64))
        | (1ULL << (MemgraphCypher::STATS - 64))
        | (1ULL << (MemgraphCypher::STREAM - 64))
        | (1ULL << (MemgraphCypher::STREAMS - 64))
        | (1ULL << (MemgraphCypher::SYNC - 64))
        | (1ULL << (MemgraphCypher::TIMEOUT - 64))
        | (1ULL << (MemgraphCypher::TO - 64))
        | (1ULL << (MemgraphCypher::TOPICS - 64))
        | (1ULL << (MemgraphCypher::TRANSACTION - 64))
        | (1ULL << (MemgraphCypher::TRANSFORM - 64))
        | (1ULL << (MemgraphCypher::TRIGGER - 64))
        | (1ULL << (MemgraphCypher::TRIGGERS - 64))
        | (1ULL << (MemgraphCypher::UNCOMMITTED - 64))
        | (1ULL << (MemgraphCypher::UNLOCK - 64))
        | (1ULL << (MemgraphCypher::UPDATE - 64))
        | (1ULL << (MemgraphCypher::USER - 64))
        | (1ULL << (MemgraphCypher::USERS - 64))
        | (1ULL << (MemgraphCypher::VERSION - 64))
        | (1ULL << (MemgraphCypher::ALL - 64))
        | (1ULL << (MemgraphCypher::AND - 64))
        | (1ULL << (MemgraphCypher::ANY - 64))
        | (1ULL << (MemgraphCypher::AS - 64))
        | (1ULL << (MemgraphCypher::ASC - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & ((1ULL << (MemgraphCypher::ASCENDING - 128))
        | (1ULL << (MemgraphCypher::ASSERT - 128))
        | (1ULL << (MemgraphCypher::BFS - 128))
        | (1ULL << (MemgraphCypher::BY - 128))
        | (1ULL << (MemgraphCypher::CALL - 128))
        | (1ULL << (MemgraphCypher::CASE - 128))
        | (1ULL << (MemgraphCypher::CONSTRAINT - 128))
        | (1ULL << (MemgraphCypher::CONTAINS - 128))
        | (1ULL << (MemgraphCypher::COUNT - 128))
        | (1ULL << (MemgraphCypher::CREATE - 128))
        | (1ULL << (MemgraphCypher::CYPHERNULL - 128))
        | (1ULL << (MemgraphCypher::DELETE - 128))
        | (1ULL << (MemgraphCypher::DESC - 128))
        | (1ULL << (MemgraphCypher::DESCENDING - 128))
        | (1ULL << (MemgraphCypher::DETACH - 128))
        | (1ULL << (MemgraphCypher::DISTINCT - 128))
        | (1ULL << (MemgraphCypher::ELSE - 128))
        | (1ULL << (MemgraphCypher::END - 128))
        | (1ULL << (MemgraphCypher::ENDS - 128))
        | (1ULL << (MemgraphCypher::EXISTS - 128))
        | (1ULL << (MemgraphCypher::EXPLAIN - 128))
        | (1ULL << (MemgraphCypher::EXTRACT - 128))
        | (1ULL << (MemgraphCypher::FALSE - 128))
        | (1ULL << (MemgraphCypher::FILTER - 128))
        | (1ULL << (MemgraphCypher::IN - 128))
        | (1ULL << (MemgraphCypher::INDEX - 128))
        | (1ULL << (MemgraphCypher::INFO - 128))
        | (1ULL << (MemgraphCypher::IS - 128))
        | (1ULL << (MemgraphCypher::KEY - 128))
        | (1ULL << (MemgraphCypher::LIMIT - 128))
        | (1ULL << (MemgraphCypher::L_SKIP - 128))
        | (1ULL << (MemgraphCypher::MATCH - 128))
        | (1ULL << (MemgraphCypher::MERGE - 128))
        | (1ULL << (MemgraphCypher::NODE - 128))
        | (1ULL << (MemgraphCypher::NONE - 128))
        | (1ULL << (MemgraphCypher::NOT - 128))
        | (1ULL << (MemgraphCypher::ON - 128))
        | (1ULL << (MemgraphCypher::OPTIONAL - 128))
        | (1ULL << (MemgraphCypher::OR - 128))
        | (1ULL << (MemgraphCypher::ORDER - 128))
        | (1ULL << (MemgraphCypher::PROCEDURE - 128))
        | (1ULL << (MemgraphCypher::PROFILE - 128))
        | (1ULL << (MemgraphCypher::QUERY - 128))
        | (1ULL << (MemgraphCypher::REDUCE - 128))
        | (1ULL << (MemgraphCypher::REMOVE - 128))
        | (1ULL << (MemgraphCypher::RETURN - 128))
        | (1ULL << (MemgraphCypher::SET - 128))
        | (1ULL << (MemgraphCypher::SHOW - 128))
        | (1ULL << (MemgraphCypher::SINGLE - 128))
        | (1ULL << (MemgraphCypher::STARTS - 128))
        | (1ULL << (MemgraphCypher::STORAGE - 128))
        | (1ULL << (MemgraphCypher::THEN - 128))
        | (1ULL << (MemgraphCypher::TRUE - 128))
        | (1ULL << (MemgraphCypher::UNION - 128))
        | (1ULL << (MemgraphCypher::UNIQUE - 128))
        | (1ULL << (MemgraphCypher::UNWIND - 128))
        | (1ULL << (MemgraphCypher::WHEN - 128))
        | (1ULL << (MemgraphCypher::WHERE - 128))
        | (1ULL << (MemgraphCypher::WITH - 128)))) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 192)) & ((1ULL << (MemgraphCypher::WSHORTEST - 192))
        | (1ULL << (MemgraphCypher::XOR - 192))
        | (1ULL << (MemgraphCypher::YIELD - 192))
        | (1ULL << (MemgraphCypher::UnescapedSymbolicName - 192))
        | (1ULL << (MemgraphCypher::EscapedSymbolicName - 192)))) != 0)) {
        setState(1358);
        antlrcpp::downCast<RelationshipDetailContext *>(_localctx)->name = variable();
      }
      setState(1362);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MemgraphCypher::COLON) {
        setState(1361);
        relationshipTypes();
      }
      setState(1365);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MemgraphCypher::ASTERISK) {
        setState(1364);
        variableExpansion();
      }
      setState(1367);
      properties();
      setState(1368);
      match(MemgraphCypher::RBRACK);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1370);
      match(MemgraphCypher::LBRACK);
      setState(1372);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MemgraphCypher::AFTER)
        | (1ULL << MemgraphCypher::ALTER)
        | (1ULL << MemgraphCypher::ASYNC)
        | (1ULL << MemgraphCypher::AUTH)
        | (1ULL << MemgraphCypher::BAD)
        | (1ULL << MemgraphCypher::BATCH_INTERVAL)
        | (1ULL << MemgraphCypher::BATCH_LIMIT)
        | (1ULL << MemgraphCypher::BATCH_SIZE)
        | (1ULL << MemgraphCypher::BEFORE)
        | (1ULL << MemgraphCypher::BOOTSTRAP_SERVERS)
        | (1ULL << MemgraphCypher::CHECK)
        | (1ULL << MemgraphCypher::CLEAR)
        | (1ULL << MemgraphCypher::COMMIT)
        | (1ULL << MemgraphCypher::COMMITTED)
        | (1ULL << MemgraphCypher::CONFIG)
        | (1ULL << MemgraphCypher::CONFIGS)
        | (1ULL << MemgraphCypher::CONSUMER_GROUP)
        | (1ULL << MemgraphCypher::CREDENTIALS)
        | (1ULL << MemgraphCypher::CSV)
        | (1ULL << MemgraphCypher::DATA)
        | (1ULL << MemgraphCypher::DELIMITER)
        | (1ULL << MemgraphCypher::DATABASE)
        | (1ULL << MemgraphCypher::DENY)
        | (1ULL << MemgraphCypher::DROP)
        | (1ULL << MemgraphCypher::DUMP)
        | (1ULL << MemgraphCypher::EXECUTE)
        | (1ULL << MemgraphCypher::FOR)
        | (1ULL << MemgraphCypher::FOREACH)
        | (1ULL << MemgraphCypher::FREE)
        | (1ULL << MemgraphCypher::FROM)
        | (1ULL << MemgraphCypher::GLOBAL)
        | (1ULL << MemgraphCypher::GRANT)
        | (1ULL << MemgraphCypher::HEADER)
        | (1ULL << MemgraphCypher::IDENTIFIED)
        | (1ULL << MemgraphCypher::ISOLATION)
        | (1ULL << MemgraphCypher::KAFKA)
        | (1ULL << MemgraphCypher::LEVEL)
        | (1ULL << MemgraphCypher::LOAD)
        | (1ULL << MemgraphCypher::LOCK)
        | (1ULL << MemgraphCypher::MAIN)
        | (1ULL << MemgraphCypher::MODE)
        | (1ULL << MemgraphCypher::NEXT)
        | (1ULL << MemgraphCypher::NO)
        | (1ULL << MemgraphCypher::PASSWORD)
        | (1ULL << MemgraphCypher::PORT)
        | (1ULL << MemgraphCypher::PRIVILEGES)
        | (1ULL << MemgraphCypher::PULSAR)
        | (1ULL << MemgraphCypher::READ)
        | (1ULL << MemgraphCypher::REGISTER)
        | (1ULL << MemgraphCypher::REPLICA)
        | (1ULL << MemgraphCypher::REPLICAS)
        | (1ULL << MemgraphCypher::REPLICATION)
        | (1ULL << MemgraphCypher::REVOKE)
        | (1ULL << MemgraphCypher::ROLE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (MemgraphCypher::ROLES - 64))
        | (1ULL << (MemgraphCypher::QUOTE - 64))
        | (1ULL << (MemgraphCypher::SESSION - 64))
        | (1ULL << (MemgraphCypher::SETTING - 64))
        | (1ULL << (MemgraphCypher::SETTINGS - 64))
        | (1ULL << (MemgraphCypher::SNAPSHOT - 64))
        | (1ULL << (MemgraphCypher::START - 64))
        | (1ULL << (MemgraphCypher::STATS - 64))
        | (1ULL << (MemgraphCypher::STREAM - 64))
        | (1ULL << (MemgraphCypher::STREAMS - 64))
        | (1ULL << (MemgraphCypher::SYNC - 64))
        | (1ULL << (MemgraphCypher::TIMEOUT - 64))
        | (1ULL << (MemgraphCypher::TO - 64))
        | (1ULL << (MemgraphCypher::TOPICS - 64))
        | (1ULL << (MemgraphCypher::TRANSACTION - 64))
        | (1ULL << (MemgraphCypher::TRANSFORM - 64))
        | (1ULL << (MemgraphCypher::TRIGGER - 64))
        | (1ULL << (MemgraphCypher::TRIGGERS - 64))
        | (1ULL << (MemgraphCypher::UNCOMMITTED - 64))
        | (1ULL << (MemgraphCypher::UNLOCK - 64))
        | (1ULL << (MemgraphCypher::UPDATE - 64))
        | (1ULL << (MemgraphCypher::USER - 64))
        | (1ULL << (MemgraphCypher::USERS - 64))
        | (1ULL << (MemgraphCypher::VERSION - 64))
        | (1ULL << (MemgraphCypher::ALL - 64))
        | (1ULL << (MemgraphCypher::AND - 64))
        | (1ULL << (MemgraphCypher::ANY - 64))
        | (1ULL << (MemgraphCypher::AS - 64))
        | (1ULL << (MemgraphCypher::ASC - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & ((1ULL << (MemgraphCypher::ASCENDING - 128))
        | (1ULL << (MemgraphCypher::ASSERT - 128))
        | (1ULL << (MemgraphCypher::BFS - 128))
        | (1ULL << (MemgraphCypher::BY - 128))
        | (1ULL << (MemgraphCypher::CALL - 128))
        | (1ULL << (MemgraphCypher::CASE - 128))
        | (1ULL << (MemgraphCypher::CONSTRAINT - 128))
        | (1ULL << (MemgraphCypher::CONTAINS - 128))
        | (1ULL << (MemgraphCypher::COUNT - 128))
        | (1ULL << (MemgraphCypher::CREATE - 128))
        | (1ULL << (MemgraphCypher::CYPHERNULL - 128))
        | (1ULL << (MemgraphCypher::DELETE - 128))
        | (1ULL << (MemgraphCypher::DESC - 128))
        | (1ULL << (MemgraphCypher::DESCENDING - 128))
        | (1ULL << (MemgraphCypher::DETACH - 128))
        | (1ULL << (MemgraphCypher::DISTINCT - 128))
        | (1ULL << (MemgraphCypher::ELSE - 128))
        | (1ULL << (MemgraphCypher::END - 128))
        | (1ULL << (MemgraphCypher::ENDS - 128))
        | (1ULL << (MemgraphCypher::EXISTS - 128))
        | (1ULL << (MemgraphCypher::EXPLAIN - 128))
        | (1ULL << (MemgraphCypher::EXTRACT - 128))
        | (1ULL << (MemgraphCypher::FALSE - 128))
        | (1ULL << (MemgraphCypher::FILTER - 128))
        | (1ULL << (MemgraphCypher::IN - 128))
        | (1ULL << (MemgraphCypher::INDEX - 128))
        | (1ULL << (MemgraphCypher::INFO - 128))
        | (1ULL << (MemgraphCypher::IS - 128))
        | (1ULL << (MemgraphCypher::KEY - 128))
        | (1ULL << (MemgraphCypher::LIMIT - 128))
        | (1ULL << (MemgraphCypher::L_SKIP - 128))
        | (1ULL << (MemgraphCypher::MATCH - 128))
        | (1ULL << (MemgraphCypher::MERGE - 128))
        | (1ULL << (MemgraphCypher::NODE - 128))
        | (1ULL << (MemgraphCypher::NONE - 128))
        | (1ULL << (MemgraphCypher::NOT - 128))
        | (1ULL << (MemgraphCypher::ON - 128))
        | (1ULL << (MemgraphCypher::OPTIONAL - 128))
        | (1ULL << (MemgraphCypher::OR - 128))
        | (1ULL << (MemgraphCypher::ORDER - 128))
        | (1ULL << (MemgraphCypher::PROCEDURE - 128))
        | (1ULL << (MemgraphCypher::PROFILE - 128))
        | (1ULL << (MemgraphCypher::QUERY - 128))
        | (1ULL << (MemgraphCypher::REDUCE - 128))
        | (1ULL << (MemgraphCypher::REMOVE - 128))
        | (1ULL << (MemgraphCypher::RETURN - 128))
        | (1ULL << (MemgraphCypher::SET - 128))
        | (1ULL << (MemgraphCypher::SHOW - 128))
        | (1ULL << (MemgraphCypher::SINGLE - 128))
        | (1ULL << (MemgraphCypher::STARTS - 128))
        | (1ULL << (MemgraphCypher::STORAGE - 128))
        | (1ULL << (MemgraphCypher::THEN - 128))
        | (1ULL << (MemgraphCypher::TRUE - 128))
        | (1ULL << (MemgraphCypher::UNION - 128))
        | (1ULL << (MemgraphCypher::UNIQUE - 128))
        | (1ULL << (MemgraphCypher::UNWIND - 128))
        | (1ULL << (MemgraphCypher::WHEN - 128))
        | (1ULL << (MemgraphCypher::WHERE - 128))
        | (1ULL << (MemgraphCypher::WITH - 128)))) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 192)) & ((1ULL << (MemgraphCypher::WSHORTEST - 192))
        | (1ULL << (MemgraphCypher::XOR - 192))
        | (1ULL << (MemgraphCypher::YIELD - 192))
        | (1ULL << (MemgraphCypher::UnescapedSymbolicName - 192))
        | (1ULL << (MemgraphCypher::EscapedSymbolicName - 192)))) != 0)) {
        setState(1371);
        antlrcpp::downCast<RelationshipDetailContext *>(_localctx)->name = variable();
      }
      setState(1375);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MemgraphCypher::COLON) {
        setState(1374);
        relationshipTypes();
      }
      setState(1378);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MemgraphCypher::ASTERISK) {
        setState(1377);
        variableExpansion();
      }
      setState(1380);
      relationshipLambda();
      setState(1382);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MemgraphCypher::AFTER)
        | (1ULL << MemgraphCypher::ALTER)
        | (1ULL << MemgraphCypher::ASYNC)
        | (1ULL << MemgraphCypher::AUTH)
        | (1ULL << MemgraphCypher::BAD)
        | (1ULL << MemgraphCypher::BATCH_INTERVAL)
        | (1ULL << MemgraphCypher::BATCH_LIMIT)
        | (1ULL << MemgraphCypher::BATCH_SIZE)
        | (1ULL << MemgraphCypher::BEFORE)
        | (1ULL << MemgraphCypher::BOOTSTRAP_SERVERS)
        | (1ULL << MemgraphCypher::CHECK)
        | (1ULL << MemgraphCypher::CLEAR)
        | (1ULL << MemgraphCypher::COMMIT)
        | (1ULL << MemgraphCypher::COMMITTED)
        | (1ULL << MemgraphCypher::CONFIG)
        | (1ULL << MemgraphCypher::CONFIGS)
        | (1ULL << MemgraphCypher::CONSUMER_GROUP)
        | (1ULL << MemgraphCypher::CREDENTIALS)
        | (1ULL << MemgraphCypher::CSV)
        | (1ULL << MemgraphCypher::DATA)
        | (1ULL << MemgraphCypher::DELIMITER)
        | (1ULL << MemgraphCypher::DATABASE)
        | (1ULL << MemgraphCypher::DENY)
        | (1ULL << MemgraphCypher::DROP)
        | (1ULL << MemgraphCypher::DUMP)
        | (1ULL << MemgraphCypher::EXECUTE)
        | (1ULL << MemgraphCypher::FOR)
        | (1ULL << MemgraphCypher::FOREACH)
        | (1ULL << MemgraphCypher::FREE)
        | (1ULL << MemgraphCypher::FROM)
        | (1ULL << MemgraphCypher::GLOBAL)
        | (1ULL << MemgraphCypher::GRANT)
        | (1ULL << MemgraphCypher::HEADER)
        | (1ULL << MemgraphCypher::IDENTIFIED)
        | (1ULL << MemgraphCypher::ISOLATION)
        | (1ULL << MemgraphCypher::KAFKA)
        | (1ULL << MemgraphCypher::LEVEL)
        | (1ULL << MemgraphCypher::LOAD)
        | (1ULL << MemgraphCypher::LOCK)
        | (1ULL << MemgraphCypher::MAIN)
        | (1ULL << MemgraphCypher::MODE)
        | (1ULL << MemgraphCypher::NEXT)
        | (1ULL << MemgraphCypher::NO)
        | (1ULL << MemgraphCypher::PASSWORD)
        | (1ULL << MemgraphCypher::PORT)
        | (1ULL << MemgraphCypher::PRIVILEGES)
        | (1ULL << MemgraphCypher::PULSAR)
        | (1ULL << MemgraphCypher::READ)
        | (1ULL << MemgraphCypher::REGISTER)
        | (1ULL << MemgraphCypher::REPLICA)
        | (1ULL << MemgraphCypher::REPLICAS)
        | (1ULL << MemgraphCypher::REPLICATION)
        | (1ULL << MemgraphCypher::REVOKE)
        | (1ULL << MemgraphCypher::ROLE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (MemgraphCypher::ROLES - 64))
        | (1ULL << (MemgraphCypher::QUOTE - 64))
        | (1ULL << (MemgraphCypher::SESSION - 64))
        | (1ULL << (MemgraphCypher::SETTING - 64))
        | (1ULL << (MemgraphCypher::SETTINGS - 64))
        | (1ULL << (MemgraphCypher::SNAPSHOT - 64))
        | (1ULL << (MemgraphCypher::START - 64))
        | (1ULL << (MemgraphCypher::STATS - 64))
        | (1ULL << (MemgraphCypher::STREAM - 64))
        | (1ULL << (MemgraphCypher::STREAMS - 64))
        | (1ULL << (MemgraphCypher::SYNC - 64))
        | (1ULL << (MemgraphCypher::TIMEOUT - 64))
        | (1ULL << (MemgraphCypher::TO - 64))
        | (1ULL << (MemgraphCypher::TOPICS - 64))
        | (1ULL << (MemgraphCypher::TRANSACTION - 64))
        | (1ULL << (MemgraphCypher::TRANSFORM - 64))
        | (1ULL << (MemgraphCypher::TRIGGER - 64))
        | (1ULL << (MemgraphCypher::TRIGGERS - 64))
        | (1ULL << (MemgraphCypher::UNCOMMITTED - 64))
        | (1ULL << (MemgraphCypher::UNLOCK - 64))
        | (1ULL << (MemgraphCypher::UPDATE - 64))
        | (1ULL << (MemgraphCypher::USER - 64))
        | (1ULL << (MemgraphCypher::USERS - 64))
        | (1ULL << (MemgraphCypher::VERSION - 64))
        | (1ULL << (MemgraphCypher::ALL - 64))
        | (1ULL << (MemgraphCypher::AND - 64))
        | (1ULL << (MemgraphCypher::ANY - 64))
        | (1ULL << (MemgraphCypher::AS - 64))
        | (1ULL << (MemgraphCypher::ASC - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & ((1ULL << (MemgraphCypher::ASCENDING - 128))
        | (1ULL << (MemgraphCypher::ASSERT - 128))
        | (1ULL << (MemgraphCypher::BFS - 128))
        | (1ULL << (MemgraphCypher::BY - 128))
        | (1ULL << (MemgraphCypher::CALL - 128))
        | (1ULL << (MemgraphCypher::CASE - 128))
        | (1ULL << (MemgraphCypher::CONSTRAINT - 128))
        | (1ULL << (MemgraphCypher::CONTAINS - 128))
        | (1ULL << (MemgraphCypher::COUNT - 128))
        | (1ULL << (MemgraphCypher::CREATE - 128))
        | (1ULL << (MemgraphCypher::CYPHERNULL - 128))
        | (1ULL << (MemgraphCypher::DELETE - 128))
        | (1ULL << (MemgraphCypher::DESC - 128))
        | (1ULL << (MemgraphCypher::DESCENDING - 128))
        | (1ULL << (MemgraphCypher::DETACH - 128))
        | (1ULL << (MemgraphCypher::DISTINCT - 128))
        | (1ULL << (MemgraphCypher::ELSE - 128))
        | (1ULL << (MemgraphCypher::END - 128))
        | (1ULL << (MemgraphCypher::ENDS - 128))
        | (1ULL << (MemgraphCypher::EXISTS - 128))
        | (1ULL << (MemgraphCypher::EXPLAIN - 128))
        | (1ULL << (MemgraphCypher::EXTRACT - 128))
        | (1ULL << (MemgraphCypher::FALSE - 128))
        | (1ULL << (MemgraphCypher::FILTER - 128))
        | (1ULL << (MemgraphCypher::IN - 128))
        | (1ULL << (MemgraphCypher::INDEX - 128))
        | (1ULL << (MemgraphCypher::INFO - 128))
        | (1ULL << (MemgraphCypher::IS - 128))
        | (1ULL << (MemgraphCypher::KEY - 128))
        | (1ULL << (MemgraphCypher::LIMIT - 128))
        | (1ULL << (MemgraphCypher::L_SKIP - 128))
        | (1ULL << (MemgraphCypher::MATCH - 128))
        | (1ULL << (MemgraphCypher::MERGE - 128))
        | (1ULL << (MemgraphCypher::NODE - 128))
        | (1ULL << (MemgraphCypher::NONE - 128))
        | (1ULL << (MemgraphCypher::NOT - 128))
        | (1ULL << (MemgraphCypher::ON - 128))
        | (1ULL << (MemgraphCypher::OPTIONAL - 128))
        | (1ULL << (MemgraphCypher::OR - 128))
        | (1ULL << (MemgraphCypher::ORDER - 128))
        | (1ULL << (MemgraphCypher::PROCEDURE - 128))
        | (1ULL << (MemgraphCypher::PROFILE - 128))
        | (1ULL << (MemgraphCypher::QUERY - 128))
        | (1ULL << (MemgraphCypher::REDUCE - 128))
        | (1ULL << (MemgraphCypher::REMOVE - 128))
        | (1ULL << (MemgraphCypher::RETURN - 128))
        | (1ULL << (MemgraphCypher::SET - 128))
        | (1ULL << (MemgraphCypher::SHOW - 128))
        | (1ULL << (MemgraphCypher::SINGLE - 128))
        | (1ULL << (MemgraphCypher::STARTS - 128))
        | (1ULL << (MemgraphCypher::STORAGE - 128))
        | (1ULL << (MemgraphCypher::THEN - 128))
        | (1ULL << (MemgraphCypher::TRUE - 128))
        | (1ULL << (MemgraphCypher::UNION - 128))
        | (1ULL << (MemgraphCypher::UNIQUE - 128))
        | (1ULL << (MemgraphCypher::UNWIND - 128))
        | (1ULL << (MemgraphCypher::WHEN - 128))
        | (1ULL << (MemgraphCypher::WHERE - 128))
        | (1ULL << (MemgraphCypher::WITH - 128)))) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 192)) & ((1ULL << (MemgraphCypher::WSHORTEST - 192))
        | (1ULL << (MemgraphCypher::XOR - 192))
        | (1ULL << (MemgraphCypher::YIELD - 192))
        | (1ULL << (MemgraphCypher::UnescapedSymbolicName - 192))
        | (1ULL << (MemgraphCypher::EscapedSymbolicName - 192)))) != 0)) {
        setState(1381);
        antlrcpp::downCast<RelationshipDetailContext *>(_localctx)->total_weight = variable();
      }
      setState(1385);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MemgraphCypher::LPAREN) {
        setState(1384);
        relationshipLambda();
      }
      setState(1387);
      match(MemgraphCypher::RBRACK);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1389);
      match(MemgraphCypher::LBRACK);
      setState(1391);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MemgraphCypher::AFTER)
        | (1ULL << MemgraphCypher::ALTER)
        | (1ULL << MemgraphCypher::ASYNC)
        | (1ULL << MemgraphCypher::AUTH)
        | (1ULL << MemgraphCypher::BAD)
        | (1ULL << MemgraphCypher::BATCH_INTERVAL)
        | (1ULL << MemgraphCypher::BATCH_LIMIT)
        | (1ULL << MemgraphCypher::BATCH_SIZE)
        | (1ULL << MemgraphCypher::BEFORE)
        | (1ULL << MemgraphCypher::BOOTSTRAP_SERVERS)
        | (1ULL << MemgraphCypher::CHECK)
        | (1ULL << MemgraphCypher::CLEAR)
        | (1ULL << MemgraphCypher::COMMIT)
        | (1ULL << MemgraphCypher::COMMITTED)
        | (1ULL << MemgraphCypher::CONFIG)
        | (1ULL << MemgraphCypher::CONFIGS)
        | (1ULL << MemgraphCypher::CONSUMER_GROUP)
        | (1ULL << MemgraphCypher::CREDENTIALS)
        | (1ULL << MemgraphCypher::CSV)
        | (1ULL << MemgraphCypher::DATA)
        | (1ULL << MemgraphCypher::DELIMITER)
        | (1ULL << MemgraphCypher::DATABASE)
        | (1ULL << MemgraphCypher::DENY)
        | (1ULL << MemgraphCypher::DROP)
        | (1ULL << MemgraphCypher::DUMP)
        | (1ULL << MemgraphCypher::EXECUTE)
        | (1ULL << MemgraphCypher::FOR)
        | (1ULL << MemgraphCypher::FOREACH)
        | (1ULL << MemgraphCypher::FREE)
        | (1ULL << MemgraphCypher::FROM)
        | (1ULL << MemgraphCypher::GLOBAL)
        | (1ULL << MemgraphCypher::GRANT)
        | (1ULL << MemgraphCypher::HEADER)
        | (1ULL << MemgraphCypher::IDENTIFIED)
        | (1ULL << MemgraphCypher::ISOLATION)
        | (1ULL << MemgraphCypher::KAFKA)
        | (1ULL << MemgraphCypher::LEVEL)
        | (1ULL << MemgraphCypher::LOAD)
        | (1ULL << MemgraphCypher::LOCK)
        | (1ULL << MemgraphCypher::MAIN)
        | (1ULL << MemgraphCypher::MODE)
        | (1ULL << MemgraphCypher::NEXT)
        | (1ULL << MemgraphCypher::NO)
        | (1ULL << MemgraphCypher::PASSWORD)
        | (1ULL << MemgraphCypher::PORT)
        | (1ULL << MemgraphCypher::PRIVILEGES)
        | (1ULL << MemgraphCypher::PULSAR)
        | (1ULL << MemgraphCypher::READ)
        | (1ULL << MemgraphCypher::REGISTER)
        | (1ULL << MemgraphCypher::REPLICA)
        | (1ULL << MemgraphCypher::REPLICAS)
        | (1ULL << MemgraphCypher::REPLICATION)
        | (1ULL << MemgraphCypher::REVOKE)
        | (1ULL << MemgraphCypher::ROLE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (MemgraphCypher::ROLES - 64))
        | (1ULL << (MemgraphCypher::QUOTE - 64))
        | (1ULL << (MemgraphCypher::SESSION - 64))
        | (1ULL << (MemgraphCypher::SETTING - 64))
        | (1ULL << (MemgraphCypher::SETTINGS - 64))
        | (1ULL << (MemgraphCypher::SNAPSHOT - 64))
        | (1ULL << (MemgraphCypher::START - 64))
        | (1ULL << (MemgraphCypher::STATS - 64))
        | (1ULL << (MemgraphCypher::STREAM - 64))
        | (1ULL << (MemgraphCypher::STREAMS - 64))
        | (1ULL << (MemgraphCypher::SYNC - 64))
        | (1ULL << (MemgraphCypher::TIMEOUT - 64))
        | (1ULL << (MemgraphCypher::TO - 64))
        | (1ULL << (MemgraphCypher::TOPICS - 64))
        | (1ULL << (MemgraphCypher::TRANSACTION - 64))
        | (1ULL << (MemgraphCypher::TRANSFORM - 64))
        | (1ULL << (MemgraphCypher::TRIGGER - 64))
        | (1ULL << (MemgraphCypher::TRIGGERS - 64))
        | (1ULL << (MemgraphCypher::UNCOMMITTED - 64))
        | (1ULL << (MemgraphCypher::UNLOCK - 64))
        | (1ULL << (MemgraphCypher::UPDATE - 64))
        | (1ULL << (MemgraphCypher::USER - 64))
        | (1ULL << (MemgraphCypher::USERS - 64))
        | (1ULL << (MemgraphCypher::VERSION - 64))
        | (1ULL << (MemgraphCypher::ALL - 64))
        | (1ULL << (MemgraphCypher::AND - 64))
        | (1ULL << (MemgraphCypher::ANY - 64))
        | (1ULL << (MemgraphCypher::AS - 64))
        | (1ULL << (MemgraphCypher::ASC - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & ((1ULL << (MemgraphCypher::ASCENDING - 128))
        | (1ULL << (MemgraphCypher::ASSERT - 128))
        | (1ULL << (MemgraphCypher::BFS - 128))
        | (1ULL << (MemgraphCypher::BY - 128))
        | (1ULL << (MemgraphCypher::CALL - 128))
        | (1ULL << (MemgraphCypher::CASE - 128))
        | (1ULL << (MemgraphCypher::CONSTRAINT - 128))
        | (1ULL << (MemgraphCypher::CONTAINS - 128))
        | (1ULL << (MemgraphCypher::COUNT - 128))
        | (1ULL << (MemgraphCypher::CREATE - 128))
        | (1ULL << (MemgraphCypher::CYPHERNULL - 128))
        | (1ULL << (MemgraphCypher::DELETE - 128))
        | (1ULL << (MemgraphCypher::DESC - 128))
        | (1ULL << (MemgraphCypher::DESCENDING - 128))
        | (1ULL << (MemgraphCypher::DETACH - 128))
        | (1ULL << (MemgraphCypher::DISTINCT - 128))
        | (1ULL << (MemgraphCypher::ELSE - 128))
        | (1ULL << (MemgraphCypher::END - 128))
        | (1ULL << (MemgraphCypher::ENDS - 128))
        | (1ULL << (MemgraphCypher::EXISTS - 128))
        | (1ULL << (MemgraphCypher::EXPLAIN - 128))
        | (1ULL << (MemgraphCypher::EXTRACT - 128))
        | (1ULL << (MemgraphCypher::FALSE - 128))
        | (1ULL << (MemgraphCypher::FILTER - 128))
        | (1ULL << (MemgraphCypher::IN - 128))
        | (1ULL << (MemgraphCypher::INDEX - 128))
        | (1ULL << (MemgraphCypher::INFO - 128))
        | (1ULL << (MemgraphCypher::IS - 128))
        | (1ULL << (MemgraphCypher::KEY - 128))
        | (1ULL << (MemgraphCypher::LIMIT - 128))
        | (1ULL << (MemgraphCypher::L_SKIP - 128))
        | (1ULL << (MemgraphCypher::MATCH - 128))
        | (1ULL << (MemgraphCypher::MERGE - 128))
        | (1ULL << (MemgraphCypher::NODE - 128))
        | (1ULL << (MemgraphCypher::NONE - 128))
        | (1ULL << (MemgraphCypher::NOT - 128))
        | (1ULL << (MemgraphCypher::ON - 128))
        | (1ULL << (MemgraphCypher::OPTIONAL - 128))
        | (1ULL << (MemgraphCypher::OR - 128))
        | (1ULL << (MemgraphCypher::ORDER - 128))
        | (1ULL << (MemgraphCypher::PROCEDURE - 128))
        | (1ULL << (MemgraphCypher::PROFILE - 128))
        | (1ULL << (MemgraphCypher::QUERY - 128))
        | (1ULL << (MemgraphCypher::REDUCE - 128))
        | (1ULL << (MemgraphCypher::REMOVE - 128))
        | (1ULL << (MemgraphCypher::RETURN - 128))
        | (1ULL << (MemgraphCypher::SET - 128))
        | (1ULL << (MemgraphCypher::SHOW - 128))
        | (1ULL << (MemgraphCypher::SINGLE - 128))
        | (1ULL << (MemgraphCypher::STARTS - 128))
        | (1ULL << (MemgraphCypher::STORAGE - 128))
        | (1ULL << (MemgraphCypher::THEN - 128))
        | (1ULL << (MemgraphCypher::TRUE - 128))
        | (1ULL << (MemgraphCypher::UNION - 128))
        | (1ULL << (MemgraphCypher::UNIQUE - 128))
        | (1ULL << (MemgraphCypher::UNWIND - 128))
        | (1ULL << (MemgraphCypher::WHEN - 128))
        | (1ULL << (MemgraphCypher::WHERE - 128))
        | (1ULL << (MemgraphCypher::WITH - 128)))) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 192)) & ((1ULL << (MemgraphCypher::WSHORTEST - 192))
        | (1ULL << (MemgraphCypher::XOR - 192))
        | (1ULL << (MemgraphCypher::YIELD - 192))
        | (1ULL << (MemgraphCypher::UnescapedSymbolicName - 192))
        | (1ULL << (MemgraphCypher::EscapedSymbolicName - 192)))) != 0)) {
        setState(1390);
        antlrcpp::downCast<RelationshipDetailContext *>(_localctx)->name = variable();
      }
      setState(1394);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MemgraphCypher::COLON) {
        setState(1393);
        relationshipTypes();
      }
      setState(1397);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MemgraphCypher::ASTERISK) {
        setState(1396);
        variableExpansion();
      }
      setState(1402);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MemgraphCypher::LBRACE

      || _la == MemgraphCypher::DOLLAR) {
        setState(1399);
        properties();
        setState(1404);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1408);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 104, _ctx)) {
      case 1: {
        setState(1405);
        relationshipLambda();
        setState(1406);
        antlrcpp::downCast<RelationshipDetailContext *>(_localctx)->total_weight = variable();
        break;
      }

      default:
        break;
      }
      setState(1411);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MemgraphCypher::LPAREN) {
        setState(1410);
        relationshipLambda();
      }
      setState(1413);
      match(MemgraphCypher::RBRACK);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelationshipLambdaContext ------------------------------------------------------------------

MemgraphCypher::RelationshipLambdaContext::RelationshipLambdaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::RelationshipLambdaContext::LPAREN() {
  return getToken(MemgraphCypher::LPAREN, 0);
}

tree::TerminalNode* MemgraphCypher::RelationshipLambdaContext::COMMA() {
  return getToken(MemgraphCypher::COMMA, 0);
}

tree::TerminalNode* MemgraphCypher::RelationshipLambdaContext::PIPE() {
  return getToken(MemgraphCypher::PIPE, 0);
}

MemgraphCypher::ExpressionContext* MemgraphCypher::RelationshipLambdaContext::expression() {
  return getRuleContext<MemgraphCypher::ExpressionContext>(0);
}

tree::TerminalNode* MemgraphCypher::RelationshipLambdaContext::RPAREN() {
  return getToken(MemgraphCypher::RPAREN, 0);
}

std::vector<MemgraphCypher::VariableContext *> MemgraphCypher::RelationshipLambdaContext::variable() {
  return getRuleContexts<MemgraphCypher::VariableContext>();
}

MemgraphCypher::VariableContext* MemgraphCypher::RelationshipLambdaContext::variable(size_t i) {
  return getRuleContext<MemgraphCypher::VariableContext>(i);
}


size_t MemgraphCypher::RelationshipLambdaContext::getRuleIndex() const {
  return MemgraphCypher::RuleRelationshipLambda;
}

void MemgraphCypher::RelationshipLambdaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelationshipLambda(this);
}

void MemgraphCypher::RelationshipLambdaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelationshipLambda(this);
}


std::any MemgraphCypher::RelationshipLambdaContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitRelationshipLambda(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::RelationshipLambdaContext* MemgraphCypher::relationshipLambda() {
  RelationshipLambdaContext *_localctx = _tracker.createInstance<RelationshipLambdaContext>(_ctx, getState());
  enterRule(_localctx, 268, MemgraphCypher::RuleRelationshipLambda);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1416);
    match(MemgraphCypher::LPAREN);
    setState(1417);
    antlrcpp::downCast<RelationshipLambdaContext *>(_localctx)->traversed_edge = variable();
    setState(1418);
    match(MemgraphCypher::COMMA);
    setState(1419);
    antlrcpp::downCast<RelationshipLambdaContext *>(_localctx)->traversed_node = variable();
    setState(1420);
    match(MemgraphCypher::PIPE);
    setState(1421);
    expression();
    setState(1422);
    match(MemgraphCypher::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableExpansionContext ------------------------------------------------------------------

MemgraphCypher::VariableExpansionContext::VariableExpansionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::VariableExpansionContext::ASTERISK() {
  return getToken(MemgraphCypher::ASTERISK, 0);
}

std::vector<MemgraphCypher::ExpressionContext *> MemgraphCypher::VariableExpansionContext::expression() {
  return getRuleContexts<MemgraphCypher::ExpressionContext>();
}

MemgraphCypher::ExpressionContext* MemgraphCypher::VariableExpansionContext::expression(size_t i) {
  return getRuleContext<MemgraphCypher::ExpressionContext>(i);
}

tree::TerminalNode* MemgraphCypher::VariableExpansionContext::DOTS() {
  return getToken(MemgraphCypher::DOTS, 0);
}

tree::TerminalNode* MemgraphCypher::VariableExpansionContext::BFS() {
  return getToken(MemgraphCypher::BFS, 0);
}

tree::TerminalNode* MemgraphCypher::VariableExpansionContext::WSHORTEST() {
  return getToken(MemgraphCypher::WSHORTEST, 0);
}


size_t MemgraphCypher::VariableExpansionContext::getRuleIndex() const {
  return MemgraphCypher::RuleVariableExpansion;
}

void MemgraphCypher::VariableExpansionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableExpansion(this);
}

void MemgraphCypher::VariableExpansionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableExpansion(this);
}


std::any MemgraphCypher::VariableExpansionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitVariableExpansion(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::VariableExpansionContext* MemgraphCypher::variableExpansion() {
  VariableExpansionContext *_localctx = _tracker.createInstance<VariableExpansionContext>(_ctx, getState());
  enterRule(_localctx, 270, MemgraphCypher::RuleVariableExpansion);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1424);
    match(MemgraphCypher::ASTERISK);
    setState(1426);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx)) {
    case 1: {
      setState(1425);
      _la = _input->LA(1);
      if (!(_la == MemgraphCypher::BFS

      || _la == MemgraphCypher::WSHORTEST)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
    setState(1429);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, _ctx)) {
    case 1: {
      setState(1428);
      expression();
      break;
    }

    default:
      break;
    }
    setState(1435);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::DOTS) {
      setState(1431);
      match(MemgraphCypher::DOTS);
      setState(1433);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx)) {
      case 1: {
        setState(1432);
        expression();
        break;
      }

      default:
        break;
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertiesContext ------------------------------------------------------------------

MemgraphCypher::PropertiesContext::PropertiesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::MapLiteralContext* MemgraphCypher::PropertiesContext::mapLiteral() {
  return getRuleContext<MemgraphCypher::MapLiteralContext>(0);
}

MemgraphCypher::ParameterContext* MemgraphCypher::PropertiesContext::parameter() {
  return getRuleContext<MemgraphCypher::ParameterContext>(0);
}


size_t MemgraphCypher::PropertiesContext::getRuleIndex() const {
  return MemgraphCypher::RuleProperties;
}

void MemgraphCypher::PropertiesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProperties(this);
}

void MemgraphCypher::PropertiesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProperties(this);
}


std::any MemgraphCypher::PropertiesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitProperties(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::PropertiesContext* MemgraphCypher::properties() {
  PropertiesContext *_localctx = _tracker.createInstance<PropertiesContext>(_ctx, getState());
  enterRule(_localctx, 272, MemgraphCypher::RuleProperties);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1439);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MemgraphCypher::LBRACE: {
        enterOuterAlt(_localctx, 1);
        setState(1437);
        mapLiteral();
        break;
      }

      case MemgraphCypher::DOLLAR: {
        enterOuterAlt(_localctx, 2);
        setState(1438);
        parameter();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelationshipTypesContext ------------------------------------------------------------------

MemgraphCypher::RelationshipTypesContext::RelationshipTypesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MemgraphCypher::RelationshipTypesContext::COLON() {
  return getTokens(MemgraphCypher::COLON);
}

tree::TerminalNode* MemgraphCypher::RelationshipTypesContext::COLON(size_t i) {
  return getToken(MemgraphCypher::COLON, i);
}

std::vector<MemgraphCypher::RelTypeNameContext *> MemgraphCypher::RelationshipTypesContext::relTypeName() {
  return getRuleContexts<MemgraphCypher::RelTypeNameContext>();
}

MemgraphCypher::RelTypeNameContext* MemgraphCypher::RelationshipTypesContext::relTypeName(size_t i) {
  return getRuleContext<MemgraphCypher::RelTypeNameContext>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::RelationshipTypesContext::PIPE() {
  return getTokens(MemgraphCypher::PIPE);
}

tree::TerminalNode* MemgraphCypher::RelationshipTypesContext::PIPE(size_t i) {
  return getToken(MemgraphCypher::PIPE, i);
}


size_t MemgraphCypher::RelationshipTypesContext::getRuleIndex() const {
  return MemgraphCypher::RuleRelationshipTypes;
}

void MemgraphCypher::RelationshipTypesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelationshipTypes(this);
}

void MemgraphCypher::RelationshipTypesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelationshipTypes(this);
}


std::any MemgraphCypher::RelationshipTypesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitRelationshipTypes(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::RelationshipTypesContext* MemgraphCypher::relationshipTypes() {
  RelationshipTypesContext *_localctx = _tracker.createInstance<RelationshipTypesContext>(_ctx, getState());
  enterRule(_localctx, 274, MemgraphCypher::RuleRelationshipTypes);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1441);
    match(MemgraphCypher::COLON);
    setState(1442);
    relTypeName();
    setState(1450);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::PIPE) {
      setState(1443);
      match(MemgraphCypher::PIPE);
      setState(1445);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MemgraphCypher::COLON) {
        setState(1444);
        match(MemgraphCypher::COLON);
      }
      setState(1447);
      relTypeName();
      setState(1452);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NodeLabelsContext ------------------------------------------------------------------

MemgraphCypher::NodeLabelsContext::NodeLabelsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MemgraphCypher::NodeLabelContext *> MemgraphCypher::NodeLabelsContext::nodeLabel() {
  return getRuleContexts<MemgraphCypher::NodeLabelContext>();
}

MemgraphCypher::NodeLabelContext* MemgraphCypher::NodeLabelsContext::nodeLabel(size_t i) {
  return getRuleContext<MemgraphCypher::NodeLabelContext>(i);
}


size_t MemgraphCypher::NodeLabelsContext::getRuleIndex() const {
  return MemgraphCypher::RuleNodeLabels;
}

void MemgraphCypher::NodeLabelsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNodeLabels(this);
}

void MemgraphCypher::NodeLabelsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNodeLabels(this);
}


std::any MemgraphCypher::NodeLabelsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitNodeLabels(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::NodeLabelsContext* MemgraphCypher::nodeLabels() {
  NodeLabelsContext *_localctx = _tracker.createInstance<NodeLabelsContext>(_ctx, getState());
  enterRule(_localctx, 276, MemgraphCypher::RuleNodeLabels);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1453);
    nodeLabel();
    setState(1457);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::COLON) {
      setState(1454);
      nodeLabel();
      setState(1459);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NodeLabelContext ------------------------------------------------------------------

MemgraphCypher::NodeLabelContext::NodeLabelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::NodeLabelContext::COLON() {
  return getToken(MemgraphCypher::COLON, 0);
}

MemgraphCypher::LabelNameContext* MemgraphCypher::NodeLabelContext::labelName() {
  return getRuleContext<MemgraphCypher::LabelNameContext>(0);
}


size_t MemgraphCypher::NodeLabelContext::getRuleIndex() const {
  return MemgraphCypher::RuleNodeLabel;
}

void MemgraphCypher::NodeLabelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNodeLabel(this);
}

void MemgraphCypher::NodeLabelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNodeLabel(this);
}


std::any MemgraphCypher::NodeLabelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitNodeLabel(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::NodeLabelContext* MemgraphCypher::nodeLabel() {
  NodeLabelContext *_localctx = _tracker.createInstance<NodeLabelContext>(_ctx, getState());
  enterRule(_localctx, 278, MemgraphCypher::RuleNodeLabel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1460);
    match(MemgraphCypher::COLON);
    setState(1461);
    labelName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelNameContext ------------------------------------------------------------------

MemgraphCypher::LabelNameContext::LabelNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::SymbolicNameContext* MemgraphCypher::LabelNameContext::symbolicName() {
  return getRuleContext<MemgraphCypher::SymbolicNameContext>(0);
}


size_t MemgraphCypher::LabelNameContext::getRuleIndex() const {
  return MemgraphCypher::RuleLabelName;
}

void MemgraphCypher::LabelNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabelName(this);
}

void MemgraphCypher::LabelNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabelName(this);
}


std::any MemgraphCypher::LabelNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitLabelName(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::LabelNameContext* MemgraphCypher::labelName() {
  LabelNameContext *_localctx = _tracker.createInstance<LabelNameContext>(_ctx, getState());
  enterRule(_localctx, 280, MemgraphCypher::RuleLabelName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1463);
    symbolicName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelTypeNameContext ------------------------------------------------------------------

MemgraphCypher::RelTypeNameContext::RelTypeNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::SymbolicNameContext* MemgraphCypher::RelTypeNameContext::symbolicName() {
  return getRuleContext<MemgraphCypher::SymbolicNameContext>(0);
}


size_t MemgraphCypher::RelTypeNameContext::getRuleIndex() const {
  return MemgraphCypher::RuleRelTypeName;
}

void MemgraphCypher::RelTypeNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelTypeName(this);
}

void MemgraphCypher::RelTypeNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelTypeName(this);
}


std::any MemgraphCypher::RelTypeNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitRelTypeName(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::RelTypeNameContext* MemgraphCypher::relTypeName() {
  RelTypeNameContext *_localctx = _tracker.createInstance<RelTypeNameContext>(_ctx, getState());
  enterRule(_localctx, 282, MemgraphCypher::RuleRelTypeName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1465);
    symbolicName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

MemgraphCypher::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::Expression12Context* MemgraphCypher::ExpressionContext::expression12() {
  return getRuleContext<MemgraphCypher::Expression12Context>(0);
}


size_t MemgraphCypher::ExpressionContext::getRuleIndex() const {
  return MemgraphCypher::RuleExpression;
}

void MemgraphCypher::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void MemgraphCypher::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}


std::any MemgraphCypher::ExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitExpression(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ExpressionContext* MemgraphCypher::expression() {
  ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, getState());
  enterRule(_localctx, 284, MemgraphCypher::RuleExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1467);
    expression12();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression12Context ------------------------------------------------------------------

MemgraphCypher::Expression12Context::Expression12Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MemgraphCypher::Expression11Context *> MemgraphCypher::Expression12Context::expression11() {
  return getRuleContexts<MemgraphCypher::Expression11Context>();
}

MemgraphCypher::Expression11Context* MemgraphCypher::Expression12Context::expression11(size_t i) {
  return getRuleContext<MemgraphCypher::Expression11Context>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::Expression12Context::OR() {
  return getTokens(MemgraphCypher::OR);
}

tree::TerminalNode* MemgraphCypher::Expression12Context::OR(size_t i) {
  return getToken(MemgraphCypher::OR, i);
}


size_t MemgraphCypher::Expression12Context::getRuleIndex() const {
  return MemgraphCypher::RuleExpression12;
}

void MemgraphCypher::Expression12Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression12(this);
}

void MemgraphCypher::Expression12Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression12(this);
}


std::any MemgraphCypher::Expression12Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitExpression12(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::Expression12Context* MemgraphCypher::expression12() {
  Expression12Context *_localctx = _tracker.createInstance<Expression12Context>(_ctx, getState());
  enterRule(_localctx, 286, MemgraphCypher::RuleExpression12);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1469);
    expression11();
    setState(1474);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::OR) {
      setState(1470);
      match(MemgraphCypher::OR);
      setState(1471);
      expression11();
      setState(1476);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression11Context ------------------------------------------------------------------

MemgraphCypher::Expression11Context::Expression11Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MemgraphCypher::Expression10Context *> MemgraphCypher::Expression11Context::expression10() {
  return getRuleContexts<MemgraphCypher::Expression10Context>();
}

MemgraphCypher::Expression10Context* MemgraphCypher::Expression11Context::expression10(size_t i) {
  return getRuleContext<MemgraphCypher::Expression10Context>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::Expression11Context::XOR() {
  return getTokens(MemgraphCypher::XOR);
}

tree::TerminalNode* MemgraphCypher::Expression11Context::XOR(size_t i) {
  return getToken(MemgraphCypher::XOR, i);
}


size_t MemgraphCypher::Expression11Context::getRuleIndex() const {
  return MemgraphCypher::RuleExpression11;
}

void MemgraphCypher::Expression11Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression11(this);
}

void MemgraphCypher::Expression11Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression11(this);
}


std::any MemgraphCypher::Expression11Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitExpression11(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::Expression11Context* MemgraphCypher::expression11() {
  Expression11Context *_localctx = _tracker.createInstance<Expression11Context>(_ctx, getState());
  enterRule(_localctx, 288, MemgraphCypher::RuleExpression11);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1477);
    expression10();
    setState(1482);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::XOR) {
      setState(1478);
      match(MemgraphCypher::XOR);
      setState(1479);
      expression10();
      setState(1484);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression10Context ------------------------------------------------------------------

MemgraphCypher::Expression10Context::Expression10Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MemgraphCypher::Expression9Context *> MemgraphCypher::Expression10Context::expression9() {
  return getRuleContexts<MemgraphCypher::Expression9Context>();
}

MemgraphCypher::Expression9Context* MemgraphCypher::Expression10Context::expression9(size_t i) {
  return getRuleContext<MemgraphCypher::Expression9Context>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::Expression10Context::AND() {
  return getTokens(MemgraphCypher::AND);
}

tree::TerminalNode* MemgraphCypher::Expression10Context::AND(size_t i) {
  return getToken(MemgraphCypher::AND, i);
}


size_t MemgraphCypher::Expression10Context::getRuleIndex() const {
  return MemgraphCypher::RuleExpression10;
}

void MemgraphCypher::Expression10Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression10(this);
}

void MemgraphCypher::Expression10Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression10(this);
}


std::any MemgraphCypher::Expression10Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitExpression10(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::Expression10Context* MemgraphCypher::expression10() {
  Expression10Context *_localctx = _tracker.createInstance<Expression10Context>(_ctx, getState());
  enterRule(_localctx, 290, MemgraphCypher::RuleExpression10);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1485);
    expression9();
    setState(1490);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::AND) {
      setState(1486);
      match(MemgraphCypher::AND);
      setState(1487);
      expression9();
      setState(1492);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression9Context ------------------------------------------------------------------

MemgraphCypher::Expression9Context::Expression9Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::Expression8Context* MemgraphCypher::Expression9Context::expression8() {
  return getRuleContext<MemgraphCypher::Expression8Context>(0);
}

std::vector<tree::TerminalNode *> MemgraphCypher::Expression9Context::NOT() {
  return getTokens(MemgraphCypher::NOT);
}

tree::TerminalNode* MemgraphCypher::Expression9Context::NOT(size_t i) {
  return getToken(MemgraphCypher::NOT, i);
}


size_t MemgraphCypher::Expression9Context::getRuleIndex() const {
  return MemgraphCypher::RuleExpression9;
}

void MemgraphCypher::Expression9Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression9(this);
}

void MemgraphCypher::Expression9Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression9(this);
}


std::any MemgraphCypher::Expression9Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitExpression9(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::Expression9Context* MemgraphCypher::expression9() {
  Expression9Context *_localctx = _tracker.createInstance<Expression9Context>(_ctx, getState());
  enterRule(_localctx, 292, MemgraphCypher::RuleExpression9);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1496);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1493);
        match(MemgraphCypher::NOT); 
      }
      setState(1498);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, _ctx);
    }
    setState(1499);
    expression8();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression8Context ------------------------------------------------------------------

MemgraphCypher::Expression8Context::Expression8Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::Expression7Context* MemgraphCypher::Expression8Context::expression7() {
  return getRuleContext<MemgraphCypher::Expression7Context>(0);
}

std::vector<MemgraphCypher::PartialComparisonExpressionContext *> MemgraphCypher::Expression8Context::partialComparisonExpression() {
  return getRuleContexts<MemgraphCypher::PartialComparisonExpressionContext>();
}

MemgraphCypher::PartialComparisonExpressionContext* MemgraphCypher::Expression8Context::partialComparisonExpression(size_t i) {
  return getRuleContext<MemgraphCypher::PartialComparisonExpressionContext>(i);
}


size_t MemgraphCypher::Expression8Context::getRuleIndex() const {
  return MemgraphCypher::RuleExpression8;
}

void MemgraphCypher::Expression8Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression8(this);
}

void MemgraphCypher::Expression8Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression8(this);
}


std::any MemgraphCypher::Expression8Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitExpression8(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::Expression8Context* MemgraphCypher::expression8() {
  Expression8Context *_localctx = _tracker.createInstance<Expression8Context>(_ctx, getState());
  enterRule(_localctx, 294, MemgraphCypher::RuleExpression8);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1501);
    expression7();
    setState(1505);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 105) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 105)) & ((1ULL << (MemgraphCypher::EQ - 105))
      | (1ULL << (MemgraphCypher::LT - 105))
      | (1ULL << (MemgraphCypher::GT - 105))
      | (1ULL << (MemgraphCypher::LTE - 105))
      | (1ULL << (MemgraphCypher::GTE - 105))
      | (1ULL << (MemgraphCypher::NEQ1 - 105))
      | (1ULL << (MemgraphCypher::NEQ2 - 105)))) != 0)) {
      setState(1502);
      partialComparisonExpression();
      setState(1507);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression7Context ------------------------------------------------------------------

MemgraphCypher::Expression7Context::Expression7Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MemgraphCypher::Expression6Context *> MemgraphCypher::Expression7Context::expression6() {
  return getRuleContexts<MemgraphCypher::Expression6Context>();
}

MemgraphCypher::Expression6Context* MemgraphCypher::Expression7Context::expression6(size_t i) {
  return getRuleContext<MemgraphCypher::Expression6Context>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::Expression7Context::PLUS() {
  return getTokens(MemgraphCypher::PLUS);
}

tree::TerminalNode* MemgraphCypher::Expression7Context::PLUS(size_t i) {
  return getToken(MemgraphCypher::PLUS, i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::Expression7Context::MINUS() {
  return getTokens(MemgraphCypher::MINUS);
}

tree::TerminalNode* MemgraphCypher::Expression7Context::MINUS(size_t i) {
  return getToken(MemgraphCypher::MINUS, i);
}


size_t MemgraphCypher::Expression7Context::getRuleIndex() const {
  return MemgraphCypher::RuleExpression7;
}

void MemgraphCypher::Expression7Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression7(this);
}

void MemgraphCypher::Expression7Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression7(this);
}


std::any MemgraphCypher::Expression7Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitExpression7(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::Expression7Context* MemgraphCypher::expression7() {
  Expression7Context *_localctx = _tracker.createInstance<Expression7Context>(_ctx, getState());
  enterRule(_localctx, 296, MemgraphCypher::RuleExpression7);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1508);
    expression6();
    setState(1515);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::PLUS

    || _la == MemgraphCypher::MINUS) {
      setState(1513);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MemgraphCypher::PLUS: {
          setState(1509);
          match(MemgraphCypher::PLUS);
          setState(1510);
          expression6();
          break;
        }

        case MemgraphCypher::MINUS: {
          setState(1511);
          match(MemgraphCypher::MINUS);
          setState(1512);
          expression6();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1517);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression6Context ------------------------------------------------------------------

MemgraphCypher::Expression6Context::Expression6Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MemgraphCypher::Expression5Context *> MemgraphCypher::Expression6Context::expression5() {
  return getRuleContexts<MemgraphCypher::Expression5Context>();
}

MemgraphCypher::Expression5Context* MemgraphCypher::Expression6Context::expression5(size_t i) {
  return getRuleContext<MemgraphCypher::Expression5Context>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::Expression6Context::ASTERISK() {
  return getTokens(MemgraphCypher::ASTERISK);
}

tree::TerminalNode* MemgraphCypher::Expression6Context::ASTERISK(size_t i) {
  return getToken(MemgraphCypher::ASTERISK, i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::Expression6Context::SLASH() {
  return getTokens(MemgraphCypher::SLASH);
}

tree::TerminalNode* MemgraphCypher::Expression6Context::SLASH(size_t i) {
  return getToken(MemgraphCypher::SLASH, i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::Expression6Context::PERCENT() {
  return getTokens(MemgraphCypher::PERCENT);
}

tree::TerminalNode* MemgraphCypher::Expression6Context::PERCENT(size_t i) {
  return getToken(MemgraphCypher::PERCENT, i);
}


size_t MemgraphCypher::Expression6Context::getRuleIndex() const {
  return MemgraphCypher::RuleExpression6;
}

void MemgraphCypher::Expression6Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression6(this);
}

void MemgraphCypher::Expression6Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression6(this);
}


std::any MemgraphCypher::Expression6Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitExpression6(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::Expression6Context* MemgraphCypher::expression6() {
  Expression6Context *_localctx = _tracker.createInstance<Expression6Context>(_ctx, getState());
  enterRule(_localctx, 298, MemgraphCypher::RuleExpression6);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1518);
    expression5();
    setState(1527);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 115) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 115)) & ((1ULL << (MemgraphCypher::ASTERISK - 115))
      | (1ULL << (MemgraphCypher::SLASH - 115))
      | (1ULL << (MemgraphCypher::PERCENT - 115)))) != 0)) {
      setState(1525);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MemgraphCypher::ASTERISK: {
          setState(1519);
          match(MemgraphCypher::ASTERISK);
          setState(1520);
          expression5();
          break;
        }

        case MemgraphCypher::SLASH: {
          setState(1521);
          match(MemgraphCypher::SLASH);
          setState(1522);
          expression5();
          break;
        }

        case MemgraphCypher::PERCENT: {
          setState(1523);
          match(MemgraphCypher::PERCENT);
          setState(1524);
          expression5();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1529);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression5Context ------------------------------------------------------------------

MemgraphCypher::Expression5Context::Expression5Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MemgraphCypher::Expression4Context *> MemgraphCypher::Expression5Context::expression4() {
  return getRuleContexts<MemgraphCypher::Expression4Context>();
}

MemgraphCypher::Expression4Context* MemgraphCypher::Expression5Context::expression4(size_t i) {
  return getRuleContext<MemgraphCypher::Expression4Context>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::Expression5Context::CARET() {
  return getTokens(MemgraphCypher::CARET);
}

tree::TerminalNode* MemgraphCypher::Expression5Context::CARET(size_t i) {
  return getToken(MemgraphCypher::CARET, i);
}


size_t MemgraphCypher::Expression5Context::getRuleIndex() const {
  return MemgraphCypher::RuleExpression5;
}

void MemgraphCypher::Expression5Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression5(this);
}

void MemgraphCypher::Expression5Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression5(this);
}


std::any MemgraphCypher::Expression5Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitExpression5(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::Expression5Context* MemgraphCypher::expression5() {
  Expression5Context *_localctx = _tracker.createInstance<Expression5Context>(_ctx, getState());
  enterRule(_localctx, 300, MemgraphCypher::RuleExpression5);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1530);
    expression4();
    setState(1535);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::CARET) {
      setState(1531);
      match(MemgraphCypher::CARET);
      setState(1532);
      expression4();
      setState(1537);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression4Context ------------------------------------------------------------------

MemgraphCypher::Expression4Context::Expression4Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::Expression3aContext* MemgraphCypher::Expression4Context::expression3a() {
  return getRuleContext<MemgraphCypher::Expression3aContext>(0);
}

std::vector<tree::TerminalNode *> MemgraphCypher::Expression4Context::PLUS() {
  return getTokens(MemgraphCypher::PLUS);
}

tree::TerminalNode* MemgraphCypher::Expression4Context::PLUS(size_t i) {
  return getToken(MemgraphCypher::PLUS, i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::Expression4Context::MINUS() {
  return getTokens(MemgraphCypher::MINUS);
}

tree::TerminalNode* MemgraphCypher::Expression4Context::MINUS(size_t i) {
  return getToken(MemgraphCypher::MINUS, i);
}


size_t MemgraphCypher::Expression4Context::getRuleIndex() const {
  return MemgraphCypher::RuleExpression4;
}

void MemgraphCypher::Expression4Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression4(this);
}

void MemgraphCypher::Expression4Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression4(this);
}


std::any MemgraphCypher::Expression4Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitExpression4(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::Expression4Context* MemgraphCypher::expression4() {
  Expression4Context *_localctx = _tracker.createInstance<Expression4Context>(_ctx, getState());
  enterRule(_localctx, 302, MemgraphCypher::RuleExpression4);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1541);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::PLUS

    || _la == MemgraphCypher::MINUS) {
      setState(1538);
      _la = _input->LA(1);
      if (!(_la == MemgraphCypher::PLUS

      || _la == MemgraphCypher::MINUS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1543);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1544);
    expression3a();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression3aContext ------------------------------------------------------------------

MemgraphCypher::Expression3aContext::Expression3aContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::Expression3bContext* MemgraphCypher::Expression3aContext::expression3b() {
  return getRuleContext<MemgraphCypher::Expression3bContext>(0);
}

std::vector<MemgraphCypher::StringAndNullOperatorsContext *> MemgraphCypher::Expression3aContext::stringAndNullOperators() {
  return getRuleContexts<MemgraphCypher::StringAndNullOperatorsContext>();
}

MemgraphCypher::StringAndNullOperatorsContext* MemgraphCypher::Expression3aContext::stringAndNullOperators(size_t i) {
  return getRuleContext<MemgraphCypher::StringAndNullOperatorsContext>(i);
}


size_t MemgraphCypher::Expression3aContext::getRuleIndex() const {
  return MemgraphCypher::RuleExpression3a;
}

void MemgraphCypher::Expression3aContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression3a(this);
}

void MemgraphCypher::Expression3aContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression3a(this);
}


std::any MemgraphCypher::Expression3aContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitExpression3a(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::Expression3aContext* MemgraphCypher::expression3a() {
  Expression3aContext *_localctx = _tracker.createInstance<Expression3aContext>(_ctx, getState());
  enterRule(_localctx, 304, MemgraphCypher::RuleExpression3a);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1546);
    expression3b();
    setState(1550);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 112) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 112)) & ((1ULL << (MemgraphCypher::SIM - 112))
      | (1ULL << (MemgraphCypher::CONTAINS - 112))
      | (1ULL << (MemgraphCypher::ENDS - 112))
      | (1ULL << (MemgraphCypher::IN - 112))
      | (1ULL << (MemgraphCypher::IS - 112)))) != 0) || _la == MemgraphCypher::STARTS) {
      setState(1547);
      stringAndNullOperators();
      setState(1552);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringAndNullOperatorsContext ------------------------------------------------------------------

MemgraphCypher::StringAndNullOperatorsContext::StringAndNullOperatorsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::Expression3bContext* MemgraphCypher::StringAndNullOperatorsContext::expression3b() {
  return getRuleContext<MemgraphCypher::Expression3bContext>(0);
}

tree::TerminalNode* MemgraphCypher::StringAndNullOperatorsContext::IS() {
  return getToken(MemgraphCypher::IS, 0);
}

tree::TerminalNode* MemgraphCypher::StringAndNullOperatorsContext::CYPHERNULL() {
  return getToken(MemgraphCypher::CYPHERNULL, 0);
}

tree::TerminalNode* MemgraphCypher::StringAndNullOperatorsContext::NOT() {
  return getToken(MemgraphCypher::NOT, 0);
}

tree::TerminalNode* MemgraphCypher::StringAndNullOperatorsContext::SIM() {
  return getToken(MemgraphCypher::SIM, 0);
}

tree::TerminalNode* MemgraphCypher::StringAndNullOperatorsContext::IN() {
  return getToken(MemgraphCypher::IN, 0);
}

tree::TerminalNode* MemgraphCypher::StringAndNullOperatorsContext::STARTS() {
  return getToken(MemgraphCypher::STARTS, 0);
}

tree::TerminalNode* MemgraphCypher::StringAndNullOperatorsContext::WITH() {
  return getToken(MemgraphCypher::WITH, 0);
}

tree::TerminalNode* MemgraphCypher::StringAndNullOperatorsContext::ENDS() {
  return getToken(MemgraphCypher::ENDS, 0);
}

tree::TerminalNode* MemgraphCypher::StringAndNullOperatorsContext::CONTAINS() {
  return getToken(MemgraphCypher::CONTAINS, 0);
}


size_t MemgraphCypher::StringAndNullOperatorsContext::getRuleIndex() const {
  return MemgraphCypher::RuleStringAndNullOperators;
}

void MemgraphCypher::StringAndNullOperatorsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringAndNullOperators(this);
}

void MemgraphCypher::StringAndNullOperatorsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringAndNullOperators(this);
}


std::any MemgraphCypher::StringAndNullOperatorsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitStringAndNullOperators(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::StringAndNullOperatorsContext* MemgraphCypher::stringAndNullOperators() {
  StringAndNullOperatorsContext *_localctx = _tracker.createInstance<StringAndNullOperatorsContext>(_ctx, getState());
  enterRule(_localctx, 306, MemgraphCypher::RuleStringAndNullOperators);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1568);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 128, _ctx)) {
    case 1: {
      setState(1560);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MemgraphCypher::SIM: {
          setState(1553);
          match(MemgraphCypher::SIM);
          break;
        }

        case MemgraphCypher::IN: {
          setState(1554);
          match(MemgraphCypher::IN);
          break;
        }

        case MemgraphCypher::STARTS: {
          setState(1555);
          match(MemgraphCypher::STARTS);
          setState(1556);
          match(MemgraphCypher::WITH);
          break;
        }

        case MemgraphCypher::ENDS: {
          setState(1557);
          match(MemgraphCypher::ENDS);
          setState(1558);
          match(MemgraphCypher::WITH);
          break;
        }

        case MemgraphCypher::CONTAINS: {
          setState(1559);
          match(MemgraphCypher::CONTAINS);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1562);
      expression3b();
      break;
    }

    case 2: {
      setState(1563);
      match(MemgraphCypher::IS);
      setState(1564);
      match(MemgraphCypher::CYPHERNULL);
      break;
    }

    case 3: {
      setState(1565);
      match(MemgraphCypher::IS);
      setState(1566);
      match(MemgraphCypher::NOT);
      setState(1567);
      match(MemgraphCypher::CYPHERNULL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression3bContext ------------------------------------------------------------------

MemgraphCypher::Expression3bContext::Expression3bContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::Expression2aContext* MemgraphCypher::Expression3bContext::expression2a() {
  return getRuleContext<MemgraphCypher::Expression2aContext>(0);
}

std::vector<MemgraphCypher::ListIndexingOrSlicingContext *> MemgraphCypher::Expression3bContext::listIndexingOrSlicing() {
  return getRuleContexts<MemgraphCypher::ListIndexingOrSlicingContext>();
}

MemgraphCypher::ListIndexingOrSlicingContext* MemgraphCypher::Expression3bContext::listIndexingOrSlicing(size_t i) {
  return getRuleContext<MemgraphCypher::ListIndexingOrSlicingContext>(i);
}


size_t MemgraphCypher::Expression3bContext::getRuleIndex() const {
  return MemgraphCypher::RuleExpression3b;
}

void MemgraphCypher::Expression3bContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression3b(this);
}

void MemgraphCypher::Expression3bContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression3b(this);
}


std::any MemgraphCypher::Expression3bContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitExpression3b(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::Expression3bContext* MemgraphCypher::expression3b() {
  Expression3bContext *_localctx = _tracker.createInstance<Expression3bContext>(_ctx, getState());
  enterRule(_localctx, 308, MemgraphCypher::RuleExpression3b);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1570);
    expression2a();
    setState(1574);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::LBRACK) {
      setState(1571);
      listIndexingOrSlicing();
      setState(1576);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ListIndexingOrSlicingContext ------------------------------------------------------------------

MemgraphCypher::ListIndexingOrSlicingContext::ListIndexingOrSlicingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ListIndexingOrSlicingContext::LBRACK() {
  return getToken(MemgraphCypher::LBRACK, 0);
}

std::vector<MemgraphCypher::ExpressionContext *> MemgraphCypher::ListIndexingOrSlicingContext::expression() {
  return getRuleContexts<MemgraphCypher::ExpressionContext>();
}

MemgraphCypher::ExpressionContext* MemgraphCypher::ListIndexingOrSlicingContext::expression(size_t i) {
  return getRuleContext<MemgraphCypher::ExpressionContext>(i);
}

tree::TerminalNode* MemgraphCypher::ListIndexingOrSlicingContext::RBRACK() {
  return getToken(MemgraphCypher::RBRACK, 0);
}

tree::TerminalNode* MemgraphCypher::ListIndexingOrSlicingContext::DOTS() {
  return getToken(MemgraphCypher::DOTS, 0);
}


size_t MemgraphCypher::ListIndexingOrSlicingContext::getRuleIndex() const {
  return MemgraphCypher::RuleListIndexingOrSlicing;
}

void MemgraphCypher::ListIndexingOrSlicingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterListIndexingOrSlicing(this);
}

void MemgraphCypher::ListIndexingOrSlicingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitListIndexingOrSlicing(this);
}


std::any MemgraphCypher::ListIndexingOrSlicingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitListIndexingOrSlicing(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ListIndexingOrSlicingContext* MemgraphCypher::listIndexingOrSlicing() {
  ListIndexingOrSlicingContext *_localctx = _tracker.createInstance<ListIndexingOrSlicingContext>(_ctx, getState());
  enterRule(_localctx, 310, MemgraphCypher::RuleListIndexingOrSlicing);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1590);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1577);
      match(MemgraphCypher::LBRACK);
      setState(1578);
      expression();
      setState(1579);
      match(MemgraphCypher::RBRACK);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1581);
      match(MemgraphCypher::LBRACK);
      setState(1583);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MemgraphCypher::AFTER)
        | (1ULL << MemgraphCypher::ALTER)
        | (1ULL << MemgraphCypher::ASYNC)
        | (1ULL << MemgraphCypher::AUTH)
        | (1ULL << MemgraphCypher::BAD)
        | (1ULL << MemgraphCypher::BATCH_INTERVAL)
        | (1ULL << MemgraphCypher::BATCH_LIMIT)
        | (1ULL << MemgraphCypher::BATCH_SIZE)
        | (1ULL << MemgraphCypher::BEFORE)
        | (1ULL << MemgraphCypher::BOOTSTRAP_SERVERS)
        | (1ULL << MemgraphCypher::CHECK)
        | (1ULL << MemgraphCypher::CLEAR)
        | (1ULL << MemgraphCypher::COMMIT)
        | (1ULL << MemgraphCypher::COMMITTED)
        | (1ULL << MemgraphCypher::CONFIG)
        | (1ULL << MemgraphCypher::CONFIGS)
        | (1ULL << MemgraphCypher::CONSUMER_GROUP)
        | (1ULL << MemgraphCypher::CREDENTIALS)
        | (1ULL << MemgraphCypher::CSV)
        | (1ULL << MemgraphCypher::DATA)
        | (1ULL << MemgraphCypher::DELIMITER)
        | (1ULL << MemgraphCypher::DATABASE)
        | (1ULL << MemgraphCypher::DENY)
        | (1ULL << MemgraphCypher::DROP)
        | (1ULL << MemgraphCypher::DUMP)
        | (1ULL << MemgraphCypher::EXECUTE)
        | (1ULL << MemgraphCypher::FOR)
        | (1ULL << MemgraphCypher::FOREACH)
        | (1ULL << MemgraphCypher::FREE)
        | (1ULL << MemgraphCypher::FROM)
        | (1ULL << MemgraphCypher::GLOBAL)
        | (1ULL << MemgraphCypher::GRANT)
        | (1ULL << MemgraphCypher::HEADER)
        | (1ULL << MemgraphCypher::IDENTIFIED)
        | (1ULL << MemgraphCypher::ISOLATION)
        | (1ULL << MemgraphCypher::KAFKA)
        | (1ULL << MemgraphCypher::LEVEL)
        | (1ULL << MemgraphCypher::LOAD)
        | (1ULL << MemgraphCypher::LOCK)
        | (1ULL << MemgraphCypher::MAIN)
        | (1ULL << MemgraphCypher::MODE)
        | (1ULL << MemgraphCypher::NEXT)
        | (1ULL << MemgraphCypher::NO)
        | (1ULL << MemgraphCypher::PASSWORD)
        | (1ULL << MemgraphCypher::PORT)
        | (1ULL << MemgraphCypher::PRIVILEGES)
        | (1ULL << MemgraphCypher::PULSAR)
        | (1ULL << MemgraphCypher::READ)
        | (1ULL << MemgraphCypher::REGISTER)
        | (1ULL << MemgraphCypher::REPLICA)
        | (1ULL << MemgraphCypher::REPLICAS)
        | (1ULL << MemgraphCypher::REPLICATION)
        | (1ULL << MemgraphCypher::REVOKE)
        | (1ULL << MemgraphCypher::ROLE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (MemgraphCypher::ROLES - 64))
        | (1ULL << (MemgraphCypher::QUOTE - 64))
        | (1ULL << (MemgraphCypher::SESSION - 64))
        | (1ULL << (MemgraphCypher::SETTING - 64))
        | (1ULL << (MemgraphCypher::SETTINGS - 64))
        | (1ULL << (MemgraphCypher::SNAPSHOT - 64))
        | (1ULL << (MemgraphCypher::START - 64))
        | (1ULL << (MemgraphCypher::STATS - 64))
        | (1ULL << (MemgraphCypher::STREAM - 64))
        | (1ULL << (MemgraphCypher::STREAMS - 64))
        | (1ULL << (MemgraphCypher::SYNC - 64))
        | (1ULL << (MemgraphCypher::TIMEOUT - 64))
        | (1ULL << (MemgraphCypher::TO - 64))
        | (1ULL << (MemgraphCypher::TOPICS - 64))
        | (1ULL << (MemgraphCypher::TRANSACTION - 64))
        | (1ULL << (MemgraphCypher::TRANSFORM - 64))
        | (1ULL << (MemgraphCypher::TRIGGER - 64))
        | (1ULL << (MemgraphCypher::TRIGGERS - 64))
        | (1ULL << (MemgraphCypher::UNCOMMITTED - 64))
        | (1ULL << (MemgraphCypher::UNLOCK - 64))
        | (1ULL << (MemgraphCypher::UPDATE - 64))
        | (1ULL << (MemgraphCypher::USER - 64))
        | (1ULL << (MemgraphCypher::USERS - 64))
        | (1ULL << (MemgraphCypher::VERSION - 64))
        | (1ULL << (MemgraphCypher::LPAREN - 64))
        | (1ULL << (MemgraphCypher::LBRACK - 64))
        | (1ULL << (MemgraphCypher::LBRACE - 64))
        | (1ULL << (MemgraphCypher::DOLLAR - 64))
        | (1ULL << (MemgraphCypher::PLUS - 64))
        | (1ULL << (MemgraphCypher::MINUS - 64))
        | (1ULL << (MemgraphCypher::ALL - 64))
        | (1ULL << (MemgraphCypher::AND - 64))
        | (1ULL << (MemgraphCypher::ANY - 64))
        | (1ULL << (MemgraphCypher::AS - 64))
        | (1ULL << (MemgraphCypher::ASC - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & ((1ULL << (MemgraphCypher::ASCENDING - 128))
        | (1ULL << (MemgraphCypher::ASSERT - 128))
        | (1ULL << (MemgraphCypher::BFS - 128))
        | (1ULL << (MemgraphCypher::BY - 128))
        | (1ULL << (MemgraphCypher::CALL - 128))
        | (1ULL << (MemgraphCypher::CASE - 128))
        | (1ULL << (MemgraphCypher::COALESCE - 128))
        | (1ULL << (MemgraphCypher::CONSTRAINT - 128))
        | (1ULL << (MemgraphCypher::CONTAINS - 128))
        | (1ULL << (MemgraphCypher::COUNT - 128))
        | (1ULL << (MemgraphCypher::CREATE - 128))
        | (1ULL << (MemgraphCypher::CYPHERNULL - 128))
        | (1ULL << (MemgraphCypher::DELETE - 128))
        | (1ULL << (MemgraphCypher::DESC - 128))
        | (1ULL << (MemgraphCypher::DESCENDING - 128))
        | (1ULL << (MemgraphCypher::DETACH - 128))
        | (1ULL << (MemgraphCypher::DISTINCT - 128))
        | (1ULL << (MemgraphCypher::ELSE - 128))
        | (1ULL << (MemgraphCypher::END - 128))
        | (1ULL << (MemgraphCypher::ENDS - 128))
        | (1ULL << (MemgraphCypher::EXISTS - 128))
        | (1ULL << (MemgraphCypher::EXPLAIN - 128))
        | (1ULL << (MemgraphCypher::EXTRACT - 128))
        | (1ULL << (MemgraphCypher::FALSE - 128))
        | (1ULL << (MemgraphCypher::FILTER - 128))
        | (1ULL << (MemgraphCypher::IN - 128))
        | (1ULL << (MemgraphCypher::INDEX - 128))
        | (1ULL << (MemgraphCypher::INFO - 128))
        | (1ULL << (MemgraphCypher::IS - 128))
        | (1ULL << (MemgraphCypher::KEY - 128))
        | (1ULL << (MemgraphCypher::LIMIT - 128))
        | (1ULL << (MemgraphCypher::L_SKIP - 128))
        | (1ULL << (MemgraphCypher::MATCH - 128))
        | (1ULL << (MemgraphCypher::MERGE - 128))
        | (1ULL << (MemgraphCypher::NODE - 128))
        | (1ULL << (MemgraphCypher::NONE - 128))
        | (1ULL << (MemgraphCypher::NOT - 128))
        | (1ULL << (MemgraphCypher::ON - 128))
        | (1ULL << (MemgraphCypher::OPTIONAL - 128))
        | (1ULL << (MemgraphCypher::OR - 128))
        | (1ULL << (MemgraphCypher::ORDER - 128))
        | (1ULL << (MemgraphCypher::PROCEDURE - 128))
        | (1ULL << (MemgraphCypher::PROFILE - 128))
        | (1ULL << (MemgraphCypher::QUERY - 128))
        | (1ULL << (MemgraphCypher::REDUCE - 128))
        | (1ULL << (MemgraphCypher::REMOVE - 128))
        | (1ULL << (MemgraphCypher::RETURN - 128))
        | (1ULL << (MemgraphCypher::SET - 128))
        | (1ULL << (MemgraphCypher::SHOW - 128))
        | (1ULL << (MemgraphCypher::SINGLE - 128))
        | (1ULL << (MemgraphCypher::STARTS - 128))
        | (1ULL << (MemgraphCypher::STORAGE - 128))
        | (1ULL << (MemgraphCypher::THEN - 128))
        | (1ULL << (MemgraphCypher::TRUE - 128))
        | (1ULL << (MemgraphCypher::UNION - 128))
        | (1ULL << (MemgraphCypher::UNIQUE - 128))
        | (1ULL << (MemgraphCypher::UNWIND - 128))
        | (1ULL << (MemgraphCypher::WHEN - 128))
        | (1ULL << (MemgraphCypher::WHERE - 128))
        | (1ULL << (MemgraphCypher::WITH - 128)))) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 192)) & ((1ULL << (MemgraphCypher::WSHORTEST - 192))
        | (1ULL << (MemgraphCypher::XOR - 192))
        | (1ULL << (MemgraphCypher::YIELD - 192))
        | (1ULL << (MemgraphCypher::StringLiteral - 192))
        | (1ULL << (MemgraphCypher::DecimalLiteral - 192))
        | (1ULL << (MemgraphCypher::OctalLiteral - 192))
        | (1ULL << (MemgraphCypher::HexadecimalLiteral - 192))
        | (1ULL << (MemgraphCypher::FloatingLiteral - 192))
        | (1ULL << (MemgraphCypher::UnescapedSymbolicName - 192))
        | (1ULL << (MemgraphCypher::EscapedSymbolicName - 192)))) != 0)) {
        setState(1582);
        antlrcpp::downCast<ListIndexingOrSlicingContext *>(_localctx)->lower_bound = expression();
      }
      setState(1585);
      match(MemgraphCypher::DOTS);
      setState(1587);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MemgraphCypher::AFTER)
        | (1ULL << MemgraphCypher::ALTER)
        | (1ULL << MemgraphCypher::ASYNC)
        | (1ULL << MemgraphCypher::AUTH)
        | (1ULL << MemgraphCypher::BAD)
        | (1ULL << MemgraphCypher::BATCH_INTERVAL)
        | (1ULL << MemgraphCypher::BATCH_LIMIT)
        | (1ULL << MemgraphCypher::BATCH_SIZE)
        | (1ULL << MemgraphCypher::BEFORE)
        | (1ULL << MemgraphCypher::BOOTSTRAP_SERVERS)
        | (1ULL << MemgraphCypher::CHECK)
        | (1ULL << MemgraphCypher::CLEAR)
        | (1ULL << MemgraphCypher::COMMIT)
        | (1ULL << MemgraphCypher::COMMITTED)
        | (1ULL << MemgraphCypher::CONFIG)
        | (1ULL << MemgraphCypher::CONFIGS)
        | (1ULL << MemgraphCypher::CONSUMER_GROUP)
        | (1ULL << MemgraphCypher::CREDENTIALS)
        | (1ULL << MemgraphCypher::CSV)
        | (1ULL << MemgraphCypher::DATA)
        | (1ULL << MemgraphCypher::DELIMITER)
        | (1ULL << MemgraphCypher::DATABASE)
        | (1ULL << MemgraphCypher::DENY)
        | (1ULL << MemgraphCypher::DROP)
        | (1ULL << MemgraphCypher::DUMP)
        | (1ULL << MemgraphCypher::EXECUTE)
        | (1ULL << MemgraphCypher::FOR)
        | (1ULL << MemgraphCypher::FOREACH)
        | (1ULL << MemgraphCypher::FREE)
        | (1ULL << MemgraphCypher::FROM)
        | (1ULL << MemgraphCypher::GLOBAL)
        | (1ULL << MemgraphCypher::GRANT)
        | (1ULL << MemgraphCypher::HEADER)
        | (1ULL << MemgraphCypher::IDENTIFIED)
        | (1ULL << MemgraphCypher::ISOLATION)
        | (1ULL << MemgraphCypher::KAFKA)
        | (1ULL << MemgraphCypher::LEVEL)
        | (1ULL << MemgraphCypher::LOAD)
        | (1ULL << MemgraphCypher::LOCK)
        | (1ULL << MemgraphCypher::MAIN)
        | (1ULL << MemgraphCypher::MODE)
        | (1ULL << MemgraphCypher::NEXT)
        | (1ULL << MemgraphCypher::NO)
        | (1ULL << MemgraphCypher::PASSWORD)
        | (1ULL << MemgraphCypher::PORT)
        | (1ULL << MemgraphCypher::PRIVILEGES)
        | (1ULL << MemgraphCypher::PULSAR)
        | (1ULL << MemgraphCypher::READ)
        | (1ULL << MemgraphCypher::REGISTER)
        | (1ULL << MemgraphCypher::REPLICA)
        | (1ULL << MemgraphCypher::REPLICAS)
        | (1ULL << MemgraphCypher::REPLICATION)
        | (1ULL << MemgraphCypher::REVOKE)
        | (1ULL << MemgraphCypher::ROLE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (MemgraphCypher::ROLES - 64))
        | (1ULL << (MemgraphCypher::QUOTE - 64))
        | (1ULL << (MemgraphCypher::SESSION - 64))
        | (1ULL << (MemgraphCypher::SETTING - 64))
        | (1ULL << (MemgraphCypher::SETTINGS - 64))
        | (1ULL << (MemgraphCypher::SNAPSHOT - 64))
        | (1ULL << (MemgraphCypher::START - 64))
        | (1ULL << (MemgraphCypher::STATS - 64))
        | (1ULL << (MemgraphCypher::STREAM - 64))
        | (1ULL << (MemgraphCypher::STREAMS - 64))
        | (1ULL << (MemgraphCypher::SYNC - 64))
        | (1ULL << (MemgraphCypher::TIMEOUT - 64))
        | (1ULL << (MemgraphCypher::TO - 64))
        | (1ULL << (MemgraphCypher::TOPICS - 64))
        | (1ULL << (MemgraphCypher::TRANSACTION - 64))
        | (1ULL << (MemgraphCypher::TRANSFORM - 64))
        | (1ULL << (MemgraphCypher::TRIGGER - 64))
        | (1ULL << (MemgraphCypher::TRIGGERS - 64))
        | (1ULL << (MemgraphCypher::UNCOMMITTED - 64))
        | (1ULL << (MemgraphCypher::UNLOCK - 64))
        | (1ULL << (MemgraphCypher::UPDATE - 64))
        | (1ULL << (MemgraphCypher::USER - 64))
        | (1ULL << (MemgraphCypher::USERS - 64))
        | (1ULL << (MemgraphCypher::VERSION - 64))
        | (1ULL << (MemgraphCypher::LPAREN - 64))
        | (1ULL << (MemgraphCypher::LBRACK - 64))
        | (1ULL << (MemgraphCypher::LBRACE - 64))
        | (1ULL << (MemgraphCypher::DOLLAR - 64))
        | (1ULL << (MemgraphCypher::PLUS - 64))
        | (1ULL << (MemgraphCypher::MINUS - 64))
        | (1ULL << (MemgraphCypher::ALL - 64))
        | (1ULL << (MemgraphCypher::AND - 64))
        | (1ULL << (MemgraphCypher::ANY - 64))
        | (1ULL << (MemgraphCypher::AS - 64))
        | (1ULL << (MemgraphCypher::ASC - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & ((1ULL << (MemgraphCypher::ASCENDING - 128))
        | (1ULL << (MemgraphCypher::ASSERT - 128))
        | (1ULL << (MemgraphCypher::BFS - 128))
        | (1ULL << (MemgraphCypher::BY - 128))
        | (1ULL << (MemgraphCypher::CALL - 128))
        | (1ULL << (MemgraphCypher::CASE - 128))
        | (1ULL << (MemgraphCypher::COALESCE - 128))
        | (1ULL << (MemgraphCypher::CONSTRAINT - 128))
        | (1ULL << (MemgraphCypher::CONTAINS - 128))
        | (1ULL << (MemgraphCypher::COUNT - 128))
        | (1ULL << (MemgraphCypher::CREATE - 128))
        | (1ULL << (MemgraphCypher::CYPHERNULL - 128))
        | (1ULL << (MemgraphCypher::DELETE - 128))
        | (1ULL << (MemgraphCypher::DESC - 128))
        | (1ULL << (MemgraphCypher::DESCENDING - 128))
        | (1ULL << (MemgraphCypher::DETACH - 128))
        | (1ULL << (MemgraphCypher::DISTINCT - 128))
        | (1ULL << (MemgraphCypher::ELSE - 128))
        | (1ULL << (MemgraphCypher::END - 128))
        | (1ULL << (MemgraphCypher::ENDS - 128))
        | (1ULL << (MemgraphCypher::EXISTS - 128))
        | (1ULL << (MemgraphCypher::EXPLAIN - 128))
        | (1ULL << (MemgraphCypher::EXTRACT - 128))
        | (1ULL << (MemgraphCypher::FALSE - 128))
        | (1ULL << (MemgraphCypher::FILTER - 128))
        | (1ULL << (MemgraphCypher::IN - 128))
        | (1ULL << (MemgraphCypher::INDEX - 128))
        | (1ULL << (MemgraphCypher::INFO - 128))
        | (1ULL << (MemgraphCypher::IS - 128))
        | (1ULL << (MemgraphCypher::KEY - 128))
        | (1ULL << (MemgraphCypher::LIMIT - 128))
        | (1ULL << (MemgraphCypher::L_SKIP - 128))
        | (1ULL << (MemgraphCypher::MATCH - 128))
        | (1ULL << (MemgraphCypher::MERGE - 128))
        | (1ULL << (MemgraphCypher::NODE - 128))
        | (1ULL << (MemgraphCypher::NONE - 128))
        | (1ULL << (MemgraphCypher::NOT - 128))
        | (1ULL << (MemgraphCypher::ON - 128))
        | (1ULL << (MemgraphCypher::OPTIONAL - 128))
        | (1ULL << (MemgraphCypher::OR - 128))
        | (1ULL << (MemgraphCypher::ORDER - 128))
        | (1ULL << (MemgraphCypher::PROCEDURE - 128))
        | (1ULL << (MemgraphCypher::PROFILE - 128))
        | (1ULL << (MemgraphCypher::QUERY - 128))
        | (1ULL << (MemgraphCypher::REDUCE - 128))
        | (1ULL << (MemgraphCypher::REMOVE - 128))
        | (1ULL << (MemgraphCypher::RETURN - 128))
        | (1ULL << (MemgraphCypher::SET - 128))
        | (1ULL << (MemgraphCypher::SHOW - 128))
        | (1ULL << (MemgraphCypher::SINGLE - 128))
        | (1ULL << (MemgraphCypher::STARTS - 128))
        | (1ULL << (MemgraphCypher::STORAGE - 128))
        | (1ULL << (MemgraphCypher::THEN - 128))
        | (1ULL << (MemgraphCypher::TRUE - 128))
        | (1ULL << (MemgraphCypher::UNION - 128))
        | (1ULL << (MemgraphCypher::UNIQUE - 128))
        | (1ULL << (MemgraphCypher::UNWIND - 128))
        | (1ULL << (MemgraphCypher::WHEN - 128))
        | (1ULL << (MemgraphCypher::WHERE - 128))
        | (1ULL << (MemgraphCypher::WITH - 128)))) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 192)) & ((1ULL << (MemgraphCypher::WSHORTEST - 192))
        | (1ULL << (MemgraphCypher::XOR - 192))
        | (1ULL << (MemgraphCypher::YIELD - 192))
        | (1ULL << (MemgraphCypher::StringLiteral - 192))
        | (1ULL << (MemgraphCypher::DecimalLiteral - 192))
        | (1ULL << (MemgraphCypher::OctalLiteral - 192))
        | (1ULL << (MemgraphCypher::HexadecimalLiteral - 192))
        | (1ULL << (MemgraphCypher::FloatingLiteral - 192))
        | (1ULL << (MemgraphCypher::UnescapedSymbolicName - 192))
        | (1ULL << (MemgraphCypher::EscapedSymbolicName - 192)))) != 0)) {
        setState(1586);
        antlrcpp::downCast<ListIndexingOrSlicingContext *>(_localctx)->upper_bound = expression();
      }
      setState(1589);
      match(MemgraphCypher::RBRACK);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression2aContext ------------------------------------------------------------------

MemgraphCypher::Expression2aContext::Expression2aContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::Expression2bContext* MemgraphCypher::Expression2aContext::expression2b() {
  return getRuleContext<MemgraphCypher::Expression2bContext>(0);
}

MemgraphCypher::NodeLabelsContext* MemgraphCypher::Expression2aContext::nodeLabels() {
  return getRuleContext<MemgraphCypher::NodeLabelsContext>(0);
}


size_t MemgraphCypher::Expression2aContext::getRuleIndex() const {
  return MemgraphCypher::RuleExpression2a;
}

void MemgraphCypher::Expression2aContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression2a(this);
}

void MemgraphCypher::Expression2aContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression2a(this);
}


std::any MemgraphCypher::Expression2aContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitExpression2a(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::Expression2aContext* MemgraphCypher::expression2a() {
  Expression2aContext *_localctx = _tracker.createInstance<Expression2aContext>(_ctx, getState());
  enterRule(_localctx, 312, MemgraphCypher::RuleExpression2a);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1592);
    expression2b();
    setState(1594);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::COLON) {
      setState(1593);
      nodeLabels();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression2bContext ------------------------------------------------------------------

MemgraphCypher::Expression2bContext::Expression2bContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::AtomContext* MemgraphCypher::Expression2bContext::atom() {
  return getRuleContext<MemgraphCypher::AtomContext>(0);
}

std::vector<MemgraphCypher::PropertyLookupContext *> MemgraphCypher::Expression2bContext::propertyLookup() {
  return getRuleContexts<MemgraphCypher::PropertyLookupContext>();
}

MemgraphCypher::PropertyLookupContext* MemgraphCypher::Expression2bContext::propertyLookup(size_t i) {
  return getRuleContext<MemgraphCypher::PropertyLookupContext>(i);
}


size_t MemgraphCypher::Expression2bContext::getRuleIndex() const {
  return MemgraphCypher::RuleExpression2b;
}

void MemgraphCypher::Expression2bContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression2b(this);
}

void MemgraphCypher::Expression2bContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression2b(this);
}


std::any MemgraphCypher::Expression2bContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitExpression2b(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::Expression2bContext* MemgraphCypher::expression2b() {
  Expression2bContext *_localctx = _tracker.createInstance<Expression2bContext>(_ctx, getState());
  enterRule(_localctx, 314, MemgraphCypher::RuleExpression2b);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1596);
    atom();
    setState(1600);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::DOT) {
      setState(1597);
      propertyLookup();
      setState(1602);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AtomContext ------------------------------------------------------------------

MemgraphCypher::AtomContext::AtomContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::LiteralContext* MemgraphCypher::AtomContext::literal() {
  return getRuleContext<MemgraphCypher::LiteralContext>(0);
}

MemgraphCypher::ParameterContext* MemgraphCypher::AtomContext::parameter() {
  return getRuleContext<MemgraphCypher::ParameterContext>(0);
}

MemgraphCypher::CaseExpressionContext* MemgraphCypher::AtomContext::caseExpression() {
  return getRuleContext<MemgraphCypher::CaseExpressionContext>(0);
}

tree::TerminalNode* MemgraphCypher::AtomContext::COUNT() {
  return getToken(MemgraphCypher::COUNT, 0);
}

tree::TerminalNode* MemgraphCypher::AtomContext::LPAREN() {
  return getToken(MemgraphCypher::LPAREN, 0);
}

tree::TerminalNode* MemgraphCypher::AtomContext::ASTERISK() {
  return getToken(MemgraphCypher::ASTERISK, 0);
}

tree::TerminalNode* MemgraphCypher::AtomContext::RPAREN() {
  return getToken(MemgraphCypher::RPAREN, 0);
}

MemgraphCypher::ListComprehensionContext* MemgraphCypher::AtomContext::listComprehension() {
  return getRuleContext<MemgraphCypher::ListComprehensionContext>(0);
}

MemgraphCypher::PatternComprehensionContext* MemgraphCypher::AtomContext::patternComprehension() {
  return getRuleContext<MemgraphCypher::PatternComprehensionContext>(0);
}

tree::TerminalNode* MemgraphCypher::AtomContext::FILTER() {
  return getToken(MemgraphCypher::FILTER, 0);
}

MemgraphCypher::FilterExpressionContext* MemgraphCypher::AtomContext::filterExpression() {
  return getRuleContext<MemgraphCypher::FilterExpressionContext>(0);
}

tree::TerminalNode* MemgraphCypher::AtomContext::EXTRACT() {
  return getToken(MemgraphCypher::EXTRACT, 0);
}

MemgraphCypher::ExtractExpressionContext* MemgraphCypher::AtomContext::extractExpression() {
  return getRuleContext<MemgraphCypher::ExtractExpressionContext>(0);
}

tree::TerminalNode* MemgraphCypher::AtomContext::REDUCE() {
  return getToken(MemgraphCypher::REDUCE, 0);
}

MemgraphCypher::ReduceExpressionContext* MemgraphCypher::AtomContext::reduceExpression() {
  return getRuleContext<MemgraphCypher::ReduceExpressionContext>(0);
}

tree::TerminalNode* MemgraphCypher::AtomContext::COALESCE() {
  return getToken(MemgraphCypher::COALESCE, 0);
}

std::vector<MemgraphCypher::ExpressionContext *> MemgraphCypher::AtomContext::expression() {
  return getRuleContexts<MemgraphCypher::ExpressionContext>();
}

MemgraphCypher::ExpressionContext* MemgraphCypher::AtomContext::expression(size_t i) {
  return getRuleContext<MemgraphCypher::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::AtomContext::COMMA() {
  return getTokens(MemgraphCypher::COMMA);
}

tree::TerminalNode* MemgraphCypher::AtomContext::COMMA(size_t i) {
  return getToken(MemgraphCypher::COMMA, i);
}

tree::TerminalNode* MemgraphCypher::AtomContext::ALL() {
  return getToken(MemgraphCypher::ALL, 0);
}

tree::TerminalNode* MemgraphCypher::AtomContext::ANY() {
  return getToken(MemgraphCypher::ANY, 0);
}

tree::TerminalNode* MemgraphCypher::AtomContext::NONE() {
  return getToken(MemgraphCypher::NONE, 0);
}

tree::TerminalNode* MemgraphCypher::AtomContext::SINGLE() {
  return getToken(MemgraphCypher::SINGLE, 0);
}

MemgraphCypher::RelationshipsPatternContext* MemgraphCypher::AtomContext::relationshipsPattern() {
  return getRuleContext<MemgraphCypher::RelationshipsPatternContext>(0);
}

MemgraphCypher::ParenthesizedExpressionContext* MemgraphCypher::AtomContext::parenthesizedExpression() {
  return getRuleContext<MemgraphCypher::ParenthesizedExpressionContext>(0);
}

MemgraphCypher::FunctionInvocationContext* MemgraphCypher::AtomContext::functionInvocation() {
  return getRuleContext<MemgraphCypher::FunctionInvocationContext>(0);
}

MemgraphCypher::VariableContext* MemgraphCypher::AtomContext::variable() {
  return getRuleContext<MemgraphCypher::VariableContext>(0);
}


size_t MemgraphCypher::AtomContext::getRuleIndex() const {
  return MemgraphCypher::RuleAtom;
}

void MemgraphCypher::AtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtom(this);
}

void MemgraphCypher::AtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtom(this);
}


std::any MemgraphCypher::AtomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitAtom(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::AtomContext* MemgraphCypher::atom() {
  AtomContext *_localctx = _tracker.createInstance<AtomContext>(_ctx, getState());
  enterRule(_localctx, 316, MemgraphCypher::RuleAtom);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1663);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 136, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1603);
      literal();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1604);
      parameter();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1605);
      caseExpression();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1606);
      match(MemgraphCypher::COUNT);
      setState(1607);
      match(MemgraphCypher::LPAREN);
      setState(1608);
      match(MemgraphCypher::ASTERISK);
      setState(1609);
      match(MemgraphCypher::RPAREN);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1610);
      listComprehension();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1611);
      patternComprehension();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1612);
      match(MemgraphCypher::FILTER);
      setState(1613);
      match(MemgraphCypher::LPAREN);
      setState(1614);
      filterExpression();
      setState(1615);
      match(MemgraphCypher::RPAREN);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1617);
      match(MemgraphCypher::EXTRACT);
      setState(1618);
      match(MemgraphCypher::LPAREN);
      setState(1619);
      extractExpression();
      setState(1620);
      match(MemgraphCypher::RPAREN);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1622);
      match(MemgraphCypher::REDUCE);
      setState(1623);
      match(MemgraphCypher::LPAREN);
      setState(1624);
      reduceExpression();
      setState(1625);
      match(MemgraphCypher::RPAREN);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1627);
      match(MemgraphCypher::COALESCE);
      setState(1628);
      match(MemgraphCypher::LPAREN);
      setState(1629);
      expression();
      setState(1634);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MemgraphCypher::COMMA) {
        setState(1630);
        match(MemgraphCypher::COMMA);
        setState(1631);
        expression();
        setState(1636);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1637);
      match(MemgraphCypher::RPAREN);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1639);
      match(MemgraphCypher::ALL);
      setState(1640);
      match(MemgraphCypher::LPAREN);
      setState(1641);
      filterExpression();
      setState(1642);
      match(MemgraphCypher::RPAREN);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(1644);
      match(MemgraphCypher::ANY);
      setState(1645);
      match(MemgraphCypher::LPAREN);
      setState(1646);
      filterExpression();
      setState(1647);
      match(MemgraphCypher::RPAREN);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(1649);
      match(MemgraphCypher::NONE);
      setState(1650);
      match(MemgraphCypher::LPAREN);
      setState(1651);
      filterExpression();
      setState(1652);
      match(MemgraphCypher::RPAREN);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(1654);
      match(MemgraphCypher::SINGLE);
      setState(1655);
      match(MemgraphCypher::LPAREN);
      setState(1656);
      filterExpression();
      setState(1657);
      match(MemgraphCypher::RPAREN);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(1659);
      relationshipsPattern();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(1660);
      parenthesizedExpression();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(1661);
      functionInvocation();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(1662);
      variable();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

MemgraphCypher::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::NumberLiteralContext* MemgraphCypher::LiteralContext::numberLiteral() {
  return getRuleContext<MemgraphCypher::NumberLiteralContext>(0);
}

tree::TerminalNode* MemgraphCypher::LiteralContext::StringLiteral() {
  return getToken(MemgraphCypher::StringLiteral, 0);
}

MemgraphCypher::BooleanLiteralContext* MemgraphCypher::LiteralContext::booleanLiteral() {
  return getRuleContext<MemgraphCypher::BooleanLiteralContext>(0);
}

tree::TerminalNode* MemgraphCypher::LiteralContext::CYPHERNULL() {
  return getToken(MemgraphCypher::CYPHERNULL, 0);
}

MemgraphCypher::MapLiteralContext* MemgraphCypher::LiteralContext::mapLiteral() {
  return getRuleContext<MemgraphCypher::MapLiteralContext>(0);
}

MemgraphCypher::ListLiteralContext* MemgraphCypher::LiteralContext::listLiteral() {
  return getRuleContext<MemgraphCypher::ListLiteralContext>(0);
}


size_t MemgraphCypher::LiteralContext::getRuleIndex() const {
  return MemgraphCypher::RuleLiteral;
}

void MemgraphCypher::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}

void MemgraphCypher::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}


std::any MemgraphCypher::LiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitLiteral(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::LiteralContext* MemgraphCypher::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 318, MemgraphCypher::RuleLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1671);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MemgraphCypher::DecimalLiteral:
      case MemgraphCypher::OctalLiteral:
      case MemgraphCypher::HexadecimalLiteral:
      case MemgraphCypher::FloatingLiteral: {
        enterOuterAlt(_localctx, 1);
        setState(1665);
        numberLiteral();
        break;
      }

      case MemgraphCypher::StringLiteral: {
        enterOuterAlt(_localctx, 2);
        setState(1666);
        match(MemgraphCypher::StringLiteral);
        break;
      }

      case MemgraphCypher::FALSE:
      case MemgraphCypher::TRUE: {
        enterOuterAlt(_localctx, 3);
        setState(1667);
        booleanLiteral();
        break;
      }

      case MemgraphCypher::CYPHERNULL: {
        enterOuterAlt(_localctx, 4);
        setState(1668);
        match(MemgraphCypher::CYPHERNULL);
        break;
      }

      case MemgraphCypher::LBRACE: {
        enterOuterAlt(_localctx, 5);
        setState(1669);
        mapLiteral();
        break;
      }

      case MemgraphCypher::LBRACK: {
        enterOuterAlt(_localctx, 6);
        setState(1670);
        listLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BooleanLiteralContext ------------------------------------------------------------------

MemgraphCypher::BooleanLiteralContext::BooleanLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::BooleanLiteralContext::TRUE() {
  return getToken(MemgraphCypher::TRUE, 0);
}

tree::TerminalNode* MemgraphCypher::BooleanLiteralContext::FALSE() {
  return getToken(MemgraphCypher::FALSE, 0);
}


size_t MemgraphCypher::BooleanLiteralContext::getRuleIndex() const {
  return MemgraphCypher::RuleBooleanLiteral;
}

void MemgraphCypher::BooleanLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBooleanLiteral(this);
}

void MemgraphCypher::BooleanLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBooleanLiteral(this);
}


std::any MemgraphCypher::BooleanLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitBooleanLiteral(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::BooleanLiteralContext* MemgraphCypher::booleanLiteral() {
  BooleanLiteralContext *_localctx = _tracker.createInstance<BooleanLiteralContext>(_ctx, getState());
  enterRule(_localctx, 320, MemgraphCypher::RuleBooleanLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1673);
    _la = _input->LA(1);
    if (!(_la == MemgraphCypher::FALSE

    || _la == MemgraphCypher::TRUE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ListLiteralContext ------------------------------------------------------------------

MemgraphCypher::ListLiteralContext::ListLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ListLiteralContext::LBRACK() {
  return getToken(MemgraphCypher::LBRACK, 0);
}

tree::TerminalNode* MemgraphCypher::ListLiteralContext::RBRACK() {
  return getToken(MemgraphCypher::RBRACK, 0);
}

std::vector<MemgraphCypher::ExpressionContext *> MemgraphCypher::ListLiteralContext::expression() {
  return getRuleContexts<MemgraphCypher::ExpressionContext>();
}

MemgraphCypher::ExpressionContext* MemgraphCypher::ListLiteralContext::expression(size_t i) {
  return getRuleContext<MemgraphCypher::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::ListLiteralContext::COMMA() {
  return getTokens(MemgraphCypher::COMMA);
}

tree::TerminalNode* MemgraphCypher::ListLiteralContext::COMMA(size_t i) {
  return getToken(MemgraphCypher::COMMA, i);
}


size_t MemgraphCypher::ListLiteralContext::getRuleIndex() const {
  return MemgraphCypher::RuleListLiteral;
}

void MemgraphCypher::ListLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterListLiteral(this);
}

void MemgraphCypher::ListLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitListLiteral(this);
}


std::any MemgraphCypher::ListLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitListLiteral(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ListLiteralContext* MemgraphCypher::listLiteral() {
  ListLiteralContext *_localctx = _tracker.createInstance<ListLiteralContext>(_ctx, getState());
  enterRule(_localctx, 322, MemgraphCypher::RuleListLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1675);
    match(MemgraphCypher::LBRACK);
    setState(1684);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MemgraphCypher::AFTER)
      | (1ULL << MemgraphCypher::ALTER)
      | (1ULL << MemgraphCypher::ASYNC)
      | (1ULL << MemgraphCypher::AUTH)
      | (1ULL << MemgraphCypher::BAD)
      | (1ULL << MemgraphCypher::BATCH_INTERVAL)
      | (1ULL << MemgraphCypher::BATCH_LIMIT)
      | (1ULL << MemgraphCypher::BATCH_SIZE)
      | (1ULL << MemgraphCypher::BEFORE)
      | (1ULL << MemgraphCypher::BOOTSTRAP_SERVERS)
      | (1ULL << MemgraphCypher::CHECK)
      | (1ULL << MemgraphCypher::CLEAR)
      | (1ULL << MemgraphCypher::COMMIT)
      | (1ULL << MemgraphCypher::COMMITTED)
      | (1ULL << MemgraphCypher::CONFIG)
      | (1ULL << MemgraphCypher::CONFIGS)
      | (1ULL << MemgraphCypher::CONSUMER_GROUP)
      | (1ULL << MemgraphCypher::CREDENTIALS)
      | (1ULL << MemgraphCypher::CSV)
      | (1ULL << MemgraphCypher::DATA)
      | (1ULL << MemgraphCypher::DELIMITER)
      | (1ULL << MemgraphCypher::DATABASE)
      | (1ULL << MemgraphCypher::DENY)
      | (1ULL << MemgraphCypher::DROP)
      | (1ULL << MemgraphCypher::DUMP)
      | (1ULL << MemgraphCypher::EXECUTE)
      | (1ULL << MemgraphCypher::FOR)
      | (1ULL << MemgraphCypher::FOREACH)
      | (1ULL << MemgraphCypher::FREE)
      | (1ULL << MemgraphCypher::FROM)
      | (1ULL << MemgraphCypher::GLOBAL)
      | (1ULL << MemgraphCypher::GRANT)
      | (1ULL << MemgraphCypher::HEADER)
      | (1ULL << MemgraphCypher::IDENTIFIED)
      | (1ULL << MemgraphCypher::ISOLATION)
      | (1ULL << MemgraphCypher::KAFKA)
      | (1ULL << MemgraphCypher::LEVEL)
      | (1ULL << MemgraphCypher::LOAD)
      | (1ULL << MemgraphCypher::LOCK)
      | (1ULL << MemgraphCypher::MAIN)
      | (1ULL << MemgraphCypher::MODE)
      | (1ULL << MemgraphCypher::NEXT)
      | (1ULL << MemgraphCypher::NO)
      | (1ULL << MemgraphCypher::PASSWORD)
      | (1ULL << MemgraphCypher::PORT)
      | (1ULL << MemgraphCypher::PRIVILEGES)
      | (1ULL << MemgraphCypher::PULSAR)
      | (1ULL << MemgraphCypher::READ)
      | (1ULL << MemgraphCypher::REGISTER)
      | (1ULL << MemgraphCypher::REPLICA)
      | (1ULL << MemgraphCypher::REPLICAS)
      | (1ULL << MemgraphCypher::REPLICATION)
      | (1ULL << MemgraphCypher::REVOKE)
      | (1ULL << MemgraphCypher::ROLE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (MemgraphCypher::ROLES - 64))
      | (1ULL << (MemgraphCypher::QUOTE - 64))
      | (1ULL << (MemgraphCypher::SESSION - 64))
      | (1ULL << (MemgraphCypher::SETTING - 64))
      | (1ULL << (MemgraphCypher::SETTINGS - 64))
      | (1ULL << (MemgraphCypher::SNAPSHOT - 64))
      | (1ULL << (MemgraphCypher::START - 64))
      | (1ULL << (MemgraphCypher::STATS - 64))
      | (1ULL << (MemgraphCypher::STREAM - 64))
      | (1ULL << (MemgraphCypher::STREAMS - 64))
      | (1ULL << (MemgraphCypher::SYNC - 64))
      | (1ULL << (MemgraphCypher::TIMEOUT - 64))
      | (1ULL << (MemgraphCypher::TO - 64))
      | (1ULL << (MemgraphCypher::TOPICS - 64))
      | (1ULL << (MemgraphCypher::TRANSACTION - 64))
      | (1ULL << (MemgraphCypher::TRANSFORM - 64))
      | (1ULL << (MemgraphCypher::TRIGGER - 64))
      | (1ULL << (MemgraphCypher::TRIGGERS - 64))
      | (1ULL << (MemgraphCypher::UNCOMMITTED - 64))
      | (1ULL << (MemgraphCypher::UNLOCK - 64))
      | (1ULL << (MemgraphCypher::UPDATE - 64))
      | (1ULL << (MemgraphCypher::USER - 64))
      | (1ULL << (MemgraphCypher::USERS - 64))
      | (1ULL << (MemgraphCypher::VERSION - 64))
      | (1ULL << (MemgraphCypher::LPAREN - 64))
      | (1ULL << (MemgraphCypher::LBRACK - 64))
      | (1ULL << (MemgraphCypher::LBRACE - 64))
      | (1ULL << (MemgraphCypher::DOLLAR - 64))
      | (1ULL << (MemgraphCypher::PLUS - 64))
      | (1ULL << (MemgraphCypher::MINUS - 64))
      | (1ULL << (MemgraphCypher::ALL - 64))
      | (1ULL << (MemgraphCypher::AND - 64))
      | (1ULL << (MemgraphCypher::ANY - 64))
      | (1ULL << (MemgraphCypher::AS - 64))
      | (1ULL << (MemgraphCypher::ASC - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (MemgraphCypher::ASCENDING - 128))
      | (1ULL << (MemgraphCypher::ASSERT - 128))
      | (1ULL << (MemgraphCypher::BFS - 128))
      | (1ULL << (MemgraphCypher::BY - 128))
      | (1ULL << (MemgraphCypher::CALL - 128))
      | (1ULL << (MemgraphCypher::CASE - 128))
      | (1ULL << (MemgraphCypher::COALESCE - 128))
      | (1ULL << (MemgraphCypher::CONSTRAINT - 128))
      | (1ULL << (MemgraphCypher::CONTAINS - 128))
      | (1ULL << (MemgraphCypher::COUNT - 128))
      | (1ULL << (MemgraphCypher::CREATE - 128))
      | (1ULL << (MemgraphCypher::CYPHERNULL - 128))
      | (1ULL << (MemgraphCypher::DELETE - 128))
      | (1ULL << (MemgraphCypher::DESC - 128))
      | (1ULL << (MemgraphCypher::DESCENDING - 128))
      | (1ULL << (MemgraphCypher::DETACH - 128))
      | (1ULL << (MemgraphCypher::DISTINCT - 128))
      | (1ULL << (MemgraphCypher::ELSE - 128))
      | (1ULL << (MemgraphCypher::END - 128))
      | (1ULL << (MemgraphCypher::ENDS - 128))
      | (1ULL << (MemgraphCypher::EXISTS - 128))
      | (1ULL << (MemgraphCypher::EXPLAIN - 128))
      | (1ULL << (MemgraphCypher::EXTRACT - 128))
      | (1ULL << (MemgraphCypher::FALSE - 128))
      | (1ULL << (MemgraphCypher::FILTER - 128))
      | (1ULL << (MemgraphCypher::IN - 128))
      | (1ULL << (MemgraphCypher::INDEX - 128))
      | (1ULL << (MemgraphCypher::INFO - 128))
      | (1ULL << (MemgraphCypher::IS - 128))
      | (1ULL << (MemgraphCypher::KEY - 128))
      | (1ULL << (MemgraphCypher::LIMIT - 128))
      | (1ULL << (MemgraphCypher::L_SKIP - 128))
      | (1ULL << (MemgraphCypher::MATCH - 128))
      | (1ULL << (MemgraphCypher::MERGE - 128))
      | (1ULL << (MemgraphCypher::NODE - 128))
      | (1ULL << (MemgraphCypher::NONE - 128))
      | (1ULL << (MemgraphCypher::NOT - 128))
      | (1ULL << (MemgraphCypher::ON - 128))
      | (1ULL << (MemgraphCypher::OPTIONAL - 128))
      | (1ULL << (MemgraphCypher::OR - 128))
      | (1ULL << (MemgraphCypher::ORDER - 128))
      | (1ULL << (MemgraphCypher::PROCEDURE - 128))
      | (1ULL << (MemgraphCypher::PROFILE - 128))
      | (1ULL << (MemgraphCypher::QUERY - 128))
      | (1ULL << (MemgraphCypher::REDUCE - 128))
      | (1ULL << (MemgraphCypher::REMOVE - 128))
      | (1ULL << (MemgraphCypher::RETURN - 128))
      | (1ULL << (MemgraphCypher::SET - 128))
      | (1ULL << (MemgraphCypher::SHOW - 128))
      | (1ULL << (MemgraphCypher::SINGLE - 128))
      | (1ULL << (MemgraphCypher::STARTS - 128))
      | (1ULL << (MemgraphCypher::STORAGE - 128))
      | (1ULL << (MemgraphCypher::THEN - 128))
      | (1ULL << (MemgraphCypher::TRUE - 128))
      | (1ULL << (MemgraphCypher::UNION - 128))
      | (1ULL << (MemgraphCypher::UNIQUE - 128))
      | (1ULL << (MemgraphCypher::UNWIND - 128))
      | (1ULL << (MemgraphCypher::WHEN - 128))
      | (1ULL << (MemgraphCypher::WHERE - 128))
      | (1ULL << (MemgraphCypher::WITH - 128)))) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & ((1ULL << (MemgraphCypher::WSHORTEST - 192))
      | (1ULL << (MemgraphCypher::XOR - 192))
      | (1ULL << (MemgraphCypher::YIELD - 192))
      | (1ULL << (MemgraphCypher::StringLiteral - 192))
      | (1ULL << (MemgraphCypher::DecimalLiteral - 192))
      | (1ULL << (MemgraphCypher::OctalLiteral - 192))
      | (1ULL << (MemgraphCypher::HexadecimalLiteral - 192))
      | (1ULL << (MemgraphCypher::FloatingLiteral - 192))
      | (1ULL << (MemgraphCypher::UnescapedSymbolicName - 192))
      | (1ULL << (MemgraphCypher::EscapedSymbolicName - 192)))) != 0)) {
      setState(1676);
      expression();
      setState(1681);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MemgraphCypher::COMMA) {
        setState(1677);
        match(MemgraphCypher::COMMA);
        setState(1678);
        expression();
        setState(1683);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1686);
    match(MemgraphCypher::RBRACK);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartialComparisonExpressionContext ------------------------------------------------------------------

MemgraphCypher::PartialComparisonExpressionContext::PartialComparisonExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::PartialComparisonExpressionContext::EQ() {
  return getToken(MemgraphCypher::EQ, 0);
}

MemgraphCypher::Expression7Context* MemgraphCypher::PartialComparisonExpressionContext::expression7() {
  return getRuleContext<MemgraphCypher::Expression7Context>(0);
}

tree::TerminalNode* MemgraphCypher::PartialComparisonExpressionContext::NEQ1() {
  return getToken(MemgraphCypher::NEQ1, 0);
}

tree::TerminalNode* MemgraphCypher::PartialComparisonExpressionContext::NEQ2() {
  return getToken(MemgraphCypher::NEQ2, 0);
}

tree::TerminalNode* MemgraphCypher::PartialComparisonExpressionContext::LT() {
  return getToken(MemgraphCypher::LT, 0);
}

tree::TerminalNode* MemgraphCypher::PartialComparisonExpressionContext::GT() {
  return getToken(MemgraphCypher::GT, 0);
}

tree::TerminalNode* MemgraphCypher::PartialComparisonExpressionContext::LTE() {
  return getToken(MemgraphCypher::LTE, 0);
}

tree::TerminalNode* MemgraphCypher::PartialComparisonExpressionContext::GTE() {
  return getToken(MemgraphCypher::GTE, 0);
}


size_t MemgraphCypher::PartialComparisonExpressionContext::getRuleIndex() const {
  return MemgraphCypher::RulePartialComparisonExpression;
}

void MemgraphCypher::PartialComparisonExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartialComparisonExpression(this);
}

void MemgraphCypher::PartialComparisonExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartialComparisonExpression(this);
}


std::any MemgraphCypher::PartialComparisonExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitPartialComparisonExpression(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::PartialComparisonExpressionContext* MemgraphCypher::partialComparisonExpression() {
  PartialComparisonExpressionContext *_localctx = _tracker.createInstance<PartialComparisonExpressionContext>(_ctx, getState());
  enterRule(_localctx, 324, MemgraphCypher::RulePartialComparisonExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1702);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MemgraphCypher::EQ: {
        enterOuterAlt(_localctx, 1);
        setState(1688);
        match(MemgraphCypher::EQ);
        setState(1689);
        expression7();
        break;
      }

      case MemgraphCypher::NEQ1: {
        enterOuterAlt(_localctx, 2);
        setState(1690);
        match(MemgraphCypher::NEQ1);
        setState(1691);
        expression7();
        break;
      }

      case MemgraphCypher::NEQ2: {
        enterOuterAlt(_localctx, 3);
        setState(1692);
        match(MemgraphCypher::NEQ2);
        setState(1693);
        expression7();
        break;
      }

      case MemgraphCypher::LT: {
        enterOuterAlt(_localctx, 4);
        setState(1694);
        match(MemgraphCypher::LT);
        setState(1695);
        expression7();
        break;
      }

      case MemgraphCypher::GT: {
        enterOuterAlt(_localctx, 5);
        setState(1696);
        match(MemgraphCypher::GT);
        setState(1697);
        expression7();
        break;
      }

      case MemgraphCypher::LTE: {
        enterOuterAlt(_localctx, 6);
        setState(1698);
        match(MemgraphCypher::LTE);
        setState(1699);
        expression7();
        break;
      }

      case MemgraphCypher::GTE: {
        enterOuterAlt(_localctx, 7);
        setState(1700);
        match(MemgraphCypher::GTE);
        setState(1701);
        expression7();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParenthesizedExpressionContext ------------------------------------------------------------------

MemgraphCypher::ParenthesizedExpressionContext::ParenthesizedExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ParenthesizedExpressionContext::LPAREN() {
  return getToken(MemgraphCypher::LPAREN, 0);
}

MemgraphCypher::ExpressionContext* MemgraphCypher::ParenthesizedExpressionContext::expression() {
  return getRuleContext<MemgraphCypher::ExpressionContext>(0);
}

tree::TerminalNode* MemgraphCypher::ParenthesizedExpressionContext::RPAREN() {
  return getToken(MemgraphCypher::RPAREN, 0);
}


size_t MemgraphCypher::ParenthesizedExpressionContext::getRuleIndex() const {
  return MemgraphCypher::RuleParenthesizedExpression;
}

void MemgraphCypher::ParenthesizedExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParenthesizedExpression(this);
}

void MemgraphCypher::ParenthesizedExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParenthesizedExpression(this);
}


std::any MemgraphCypher::ParenthesizedExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitParenthesizedExpression(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ParenthesizedExpressionContext* MemgraphCypher::parenthesizedExpression() {
  ParenthesizedExpressionContext *_localctx = _tracker.createInstance<ParenthesizedExpressionContext>(_ctx, getState());
  enterRule(_localctx, 326, MemgraphCypher::RuleParenthesizedExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1704);
    match(MemgraphCypher::LPAREN);
    setState(1705);
    expression();
    setState(1706);
    match(MemgraphCypher::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelationshipsPatternContext ------------------------------------------------------------------

MemgraphCypher::RelationshipsPatternContext::RelationshipsPatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::NodePatternContext* MemgraphCypher::RelationshipsPatternContext::nodePattern() {
  return getRuleContext<MemgraphCypher::NodePatternContext>(0);
}

std::vector<MemgraphCypher::PatternElementChainContext *> MemgraphCypher::RelationshipsPatternContext::patternElementChain() {
  return getRuleContexts<MemgraphCypher::PatternElementChainContext>();
}

MemgraphCypher::PatternElementChainContext* MemgraphCypher::RelationshipsPatternContext::patternElementChain(size_t i) {
  return getRuleContext<MemgraphCypher::PatternElementChainContext>(i);
}


size_t MemgraphCypher::RelationshipsPatternContext::getRuleIndex() const {
  return MemgraphCypher::RuleRelationshipsPattern;
}

void MemgraphCypher::RelationshipsPatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelationshipsPattern(this);
}

void MemgraphCypher::RelationshipsPatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelationshipsPattern(this);
}


std::any MemgraphCypher::RelationshipsPatternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitRelationshipsPattern(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::RelationshipsPatternContext* MemgraphCypher::relationshipsPattern() {
  RelationshipsPatternContext *_localctx = _tracker.createInstance<RelationshipsPatternContext>(_ctx, getState());
  enterRule(_localctx, 328, MemgraphCypher::RuleRelationshipsPattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1708);
    nodePattern();
    setState(1710); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1709);
              patternElementChain();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1712); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterExpressionContext ------------------------------------------------------------------

MemgraphCypher::FilterExpressionContext::FilterExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::IdInCollContext* MemgraphCypher::FilterExpressionContext::idInColl() {
  return getRuleContext<MemgraphCypher::IdInCollContext>(0);
}

MemgraphCypher::WhereContext* MemgraphCypher::FilterExpressionContext::where() {
  return getRuleContext<MemgraphCypher::WhereContext>(0);
}


size_t MemgraphCypher::FilterExpressionContext::getRuleIndex() const {
  return MemgraphCypher::RuleFilterExpression;
}

void MemgraphCypher::FilterExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterExpression(this);
}

void MemgraphCypher::FilterExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterExpression(this);
}


std::any MemgraphCypher::FilterExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitFilterExpression(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::FilterExpressionContext* MemgraphCypher::filterExpression() {
  FilterExpressionContext *_localctx = _tracker.createInstance<FilterExpressionContext>(_ctx, getState());
  enterRule(_localctx, 330, MemgraphCypher::RuleFilterExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1714);
    idInColl();
    setState(1716);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::WHERE) {
      setState(1715);
      where();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReduceExpressionContext ------------------------------------------------------------------

MemgraphCypher::ReduceExpressionContext::ReduceExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ReduceExpressionContext::EQ() {
  return getToken(MemgraphCypher::EQ, 0);
}

tree::TerminalNode* MemgraphCypher::ReduceExpressionContext::COMMA() {
  return getToken(MemgraphCypher::COMMA, 0);
}

MemgraphCypher::IdInCollContext* MemgraphCypher::ReduceExpressionContext::idInColl() {
  return getRuleContext<MemgraphCypher::IdInCollContext>(0);
}

tree::TerminalNode* MemgraphCypher::ReduceExpressionContext::PIPE() {
  return getToken(MemgraphCypher::PIPE, 0);
}

std::vector<MemgraphCypher::ExpressionContext *> MemgraphCypher::ReduceExpressionContext::expression() {
  return getRuleContexts<MemgraphCypher::ExpressionContext>();
}

MemgraphCypher::ExpressionContext* MemgraphCypher::ReduceExpressionContext::expression(size_t i) {
  return getRuleContext<MemgraphCypher::ExpressionContext>(i);
}

MemgraphCypher::VariableContext* MemgraphCypher::ReduceExpressionContext::variable() {
  return getRuleContext<MemgraphCypher::VariableContext>(0);
}


size_t MemgraphCypher::ReduceExpressionContext::getRuleIndex() const {
  return MemgraphCypher::RuleReduceExpression;
}

void MemgraphCypher::ReduceExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReduceExpression(this);
}

void MemgraphCypher::ReduceExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReduceExpression(this);
}


std::any MemgraphCypher::ReduceExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitReduceExpression(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ReduceExpressionContext* MemgraphCypher::reduceExpression() {
  ReduceExpressionContext *_localctx = _tracker.createInstance<ReduceExpressionContext>(_ctx, getState());
  enterRule(_localctx, 332, MemgraphCypher::RuleReduceExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1718);
    antlrcpp::downCast<ReduceExpressionContext *>(_localctx)->accumulator = variable();
    setState(1719);
    match(MemgraphCypher::EQ);
    setState(1720);
    antlrcpp::downCast<ReduceExpressionContext *>(_localctx)->initial = expression();
    setState(1721);
    match(MemgraphCypher::COMMA);
    setState(1722);
    idInColl();
    setState(1723);
    match(MemgraphCypher::PIPE);
    setState(1724);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExtractExpressionContext ------------------------------------------------------------------

MemgraphCypher::ExtractExpressionContext::ExtractExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::IdInCollContext* MemgraphCypher::ExtractExpressionContext::idInColl() {
  return getRuleContext<MemgraphCypher::IdInCollContext>(0);
}

tree::TerminalNode* MemgraphCypher::ExtractExpressionContext::PIPE() {
  return getToken(MemgraphCypher::PIPE, 0);
}

MemgraphCypher::ExpressionContext* MemgraphCypher::ExtractExpressionContext::expression() {
  return getRuleContext<MemgraphCypher::ExpressionContext>(0);
}


size_t MemgraphCypher::ExtractExpressionContext::getRuleIndex() const {
  return MemgraphCypher::RuleExtractExpression;
}

void MemgraphCypher::ExtractExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExtractExpression(this);
}

void MemgraphCypher::ExtractExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExtractExpression(this);
}


std::any MemgraphCypher::ExtractExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitExtractExpression(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ExtractExpressionContext* MemgraphCypher::extractExpression() {
  ExtractExpressionContext *_localctx = _tracker.createInstance<ExtractExpressionContext>(_ctx, getState());
  enterRule(_localctx, 334, MemgraphCypher::RuleExtractExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1726);
    idInColl();
    setState(1727);
    match(MemgraphCypher::PIPE);
    setState(1728);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdInCollContext ------------------------------------------------------------------

MemgraphCypher::IdInCollContext::IdInCollContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::VariableContext* MemgraphCypher::IdInCollContext::variable() {
  return getRuleContext<MemgraphCypher::VariableContext>(0);
}

tree::TerminalNode* MemgraphCypher::IdInCollContext::IN() {
  return getToken(MemgraphCypher::IN, 0);
}

MemgraphCypher::ExpressionContext* MemgraphCypher::IdInCollContext::expression() {
  return getRuleContext<MemgraphCypher::ExpressionContext>(0);
}


size_t MemgraphCypher::IdInCollContext::getRuleIndex() const {
  return MemgraphCypher::RuleIdInColl;
}

void MemgraphCypher::IdInCollContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdInColl(this);
}

void MemgraphCypher::IdInCollContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdInColl(this);
}


std::any MemgraphCypher::IdInCollContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitIdInColl(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::IdInCollContext* MemgraphCypher::idInColl() {
  IdInCollContext *_localctx = _tracker.createInstance<IdInCollContext>(_ctx, getState());
  enterRule(_localctx, 336, MemgraphCypher::RuleIdInColl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1730);
    variable();
    setState(1731);
    match(MemgraphCypher::IN);
    setState(1732);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionInvocationContext ------------------------------------------------------------------

MemgraphCypher::FunctionInvocationContext::FunctionInvocationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::FunctionNameContext* MemgraphCypher::FunctionInvocationContext::functionName() {
  return getRuleContext<MemgraphCypher::FunctionNameContext>(0);
}

tree::TerminalNode* MemgraphCypher::FunctionInvocationContext::LPAREN() {
  return getToken(MemgraphCypher::LPAREN, 0);
}

tree::TerminalNode* MemgraphCypher::FunctionInvocationContext::RPAREN() {
  return getToken(MemgraphCypher::RPAREN, 0);
}

tree::TerminalNode* MemgraphCypher::FunctionInvocationContext::DISTINCT() {
  return getToken(MemgraphCypher::DISTINCT, 0);
}

std::vector<MemgraphCypher::ExpressionContext *> MemgraphCypher::FunctionInvocationContext::expression() {
  return getRuleContexts<MemgraphCypher::ExpressionContext>();
}

MemgraphCypher::ExpressionContext* MemgraphCypher::FunctionInvocationContext::expression(size_t i) {
  return getRuleContext<MemgraphCypher::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::FunctionInvocationContext::COMMA() {
  return getTokens(MemgraphCypher::COMMA);
}

tree::TerminalNode* MemgraphCypher::FunctionInvocationContext::COMMA(size_t i) {
  return getToken(MemgraphCypher::COMMA, i);
}


size_t MemgraphCypher::FunctionInvocationContext::getRuleIndex() const {
  return MemgraphCypher::RuleFunctionInvocation;
}

void MemgraphCypher::FunctionInvocationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionInvocation(this);
}

void MemgraphCypher::FunctionInvocationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionInvocation(this);
}


std::any MemgraphCypher::FunctionInvocationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitFunctionInvocation(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::FunctionInvocationContext* MemgraphCypher::functionInvocation() {
  FunctionInvocationContext *_localctx = _tracker.createInstance<FunctionInvocationContext>(_ctx, getState());
  enterRule(_localctx, 338, MemgraphCypher::RuleFunctionInvocation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1734);
    functionName();
    setState(1735);
    match(MemgraphCypher::LPAREN);
    setState(1737);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 143, _ctx)) {
    case 1: {
      setState(1736);
      match(MemgraphCypher::DISTINCT);
      break;
    }

    default:
      break;
    }
    setState(1747);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MemgraphCypher::AFTER)
      | (1ULL << MemgraphCypher::ALTER)
      | (1ULL << MemgraphCypher::ASYNC)
      | (1ULL << MemgraphCypher::AUTH)
      | (1ULL << MemgraphCypher::BAD)
      | (1ULL << MemgraphCypher::BATCH_INTERVAL)
      | (1ULL << MemgraphCypher::BATCH_LIMIT)
      | (1ULL << MemgraphCypher::BATCH_SIZE)
      | (1ULL << MemgraphCypher::BEFORE)
      | (1ULL << MemgraphCypher::BOOTSTRAP_SERVERS)
      | (1ULL << MemgraphCypher::CHECK)
      | (1ULL << MemgraphCypher::CLEAR)
      | (1ULL << MemgraphCypher::COMMIT)
      | (1ULL << MemgraphCypher::COMMITTED)
      | (1ULL << MemgraphCypher::CONFIG)
      | (1ULL << MemgraphCypher::CONFIGS)
      | (1ULL << MemgraphCypher::CONSUMER_GROUP)
      | (1ULL << MemgraphCypher::CREDENTIALS)
      | (1ULL << MemgraphCypher::CSV)
      | (1ULL << MemgraphCypher::DATA)
      | (1ULL << MemgraphCypher::DELIMITER)
      | (1ULL << MemgraphCypher::DATABASE)
      | (1ULL << MemgraphCypher::DENY)
      | (1ULL << MemgraphCypher::DROP)
      | (1ULL << MemgraphCypher::DUMP)
      | (1ULL << MemgraphCypher::EXECUTE)
      | (1ULL << MemgraphCypher::FOR)
      | (1ULL << MemgraphCypher::FOREACH)
      | (1ULL << MemgraphCypher::FREE)
      | (1ULL << MemgraphCypher::FROM)
      | (1ULL << MemgraphCypher::GLOBAL)
      | (1ULL << MemgraphCypher::GRANT)
      | (1ULL << MemgraphCypher::HEADER)
      | (1ULL << MemgraphCypher::IDENTIFIED)
      | (1ULL << MemgraphCypher::ISOLATION)
      | (1ULL << MemgraphCypher::KAFKA)
      | (1ULL << MemgraphCypher::LEVEL)
      | (1ULL << MemgraphCypher::LOAD)
      | (1ULL << MemgraphCypher::LOCK)
      | (1ULL << MemgraphCypher::MAIN)
      | (1ULL << MemgraphCypher::MODE)
      | (1ULL << MemgraphCypher::NEXT)
      | (1ULL << MemgraphCypher::NO)
      | (1ULL << MemgraphCypher::PASSWORD)
      | (1ULL << MemgraphCypher::PORT)
      | (1ULL << MemgraphCypher::PRIVILEGES)
      | (1ULL << MemgraphCypher::PULSAR)
      | (1ULL << MemgraphCypher::READ)
      | (1ULL << MemgraphCypher::REGISTER)
      | (1ULL << MemgraphCypher::REPLICA)
      | (1ULL << MemgraphCypher::REPLICAS)
      | (1ULL << MemgraphCypher::REPLICATION)
      | (1ULL << MemgraphCypher::REVOKE)
      | (1ULL << MemgraphCypher::ROLE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (MemgraphCypher::ROLES - 64))
      | (1ULL << (MemgraphCypher::QUOTE - 64))
      | (1ULL << (MemgraphCypher::SESSION - 64))
      | (1ULL << (MemgraphCypher::SETTING - 64))
      | (1ULL << (MemgraphCypher::SETTINGS - 64))
      | (1ULL << (MemgraphCypher::SNAPSHOT - 64))
      | (1ULL << (MemgraphCypher::START - 64))
      | (1ULL << (MemgraphCypher::STATS - 64))
      | (1ULL << (MemgraphCypher::STREAM - 64))
      | (1ULL << (MemgraphCypher::STREAMS - 64))
      | (1ULL << (MemgraphCypher::SYNC - 64))
      | (1ULL << (MemgraphCypher::TIMEOUT - 64))
      | (1ULL << (MemgraphCypher::TO - 64))
      | (1ULL << (MemgraphCypher::TOPICS - 64))
      | (1ULL << (MemgraphCypher::TRANSACTION - 64))
      | (1ULL << (MemgraphCypher::TRANSFORM - 64))
      | (1ULL << (MemgraphCypher::TRIGGER - 64))
      | (1ULL << (MemgraphCypher::TRIGGERS - 64))
      | (1ULL << (MemgraphCypher::UNCOMMITTED - 64))
      | (1ULL << (MemgraphCypher::UNLOCK - 64))
      | (1ULL << (MemgraphCypher::UPDATE - 64))
      | (1ULL << (MemgraphCypher::USER - 64))
      | (1ULL << (MemgraphCypher::USERS - 64))
      | (1ULL << (MemgraphCypher::VERSION - 64))
      | (1ULL << (MemgraphCypher::LPAREN - 64))
      | (1ULL << (MemgraphCypher::LBRACK - 64))
      | (1ULL << (MemgraphCypher::LBRACE - 64))
      | (1ULL << (MemgraphCypher::DOLLAR - 64))
      | (1ULL << (MemgraphCypher::PLUS - 64))
      | (1ULL << (MemgraphCypher::MINUS - 64))
      | (1ULL << (MemgraphCypher::ALL - 64))
      | (1ULL << (MemgraphCypher::AND - 64))
      | (1ULL << (MemgraphCypher::ANY - 64))
      | (1ULL << (MemgraphCypher::AS - 64))
      | (1ULL << (MemgraphCypher::ASC - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (MemgraphCypher::ASCENDING - 128))
      | (1ULL << (MemgraphCypher::ASSERT - 128))
      | (1ULL << (MemgraphCypher::BFS - 128))
      | (1ULL << (MemgraphCypher::BY - 128))
      | (1ULL << (MemgraphCypher::CALL - 128))
      | (1ULL << (MemgraphCypher::CASE - 128))
      | (1ULL << (MemgraphCypher::COALESCE - 128))
      | (1ULL << (MemgraphCypher::CONSTRAINT - 128))
      | (1ULL << (MemgraphCypher::CONTAINS - 128))
      | (1ULL << (MemgraphCypher::COUNT - 128))
      | (1ULL << (MemgraphCypher::CREATE - 128))
      | (1ULL << (MemgraphCypher::CYPHERNULL - 128))
      | (1ULL << (MemgraphCypher::DELETE - 128))
      | (1ULL << (MemgraphCypher::DESC - 128))
      | (1ULL << (MemgraphCypher::DESCENDING - 128))
      | (1ULL << (MemgraphCypher::DETACH - 128))
      | (1ULL << (MemgraphCypher::DISTINCT - 128))
      | (1ULL << (MemgraphCypher::ELSE - 128))
      | (1ULL << (MemgraphCypher::END - 128))
      | (1ULL << (MemgraphCypher::ENDS - 128))
      | (1ULL << (MemgraphCypher::EXISTS - 128))
      | (1ULL << (MemgraphCypher::EXPLAIN - 128))
      | (1ULL << (MemgraphCypher::EXTRACT - 128))
      | (1ULL << (MemgraphCypher::FALSE - 128))
      | (1ULL << (MemgraphCypher::FILTER - 128))
      | (1ULL << (MemgraphCypher::IN - 128))
      | (1ULL << (MemgraphCypher::INDEX - 128))
      | (1ULL << (MemgraphCypher::INFO - 128))
      | (1ULL << (MemgraphCypher::IS - 128))
      | (1ULL << (MemgraphCypher::KEY - 128))
      | (1ULL << (MemgraphCypher::LIMIT - 128))
      | (1ULL << (MemgraphCypher::L_SKIP - 128))
      | (1ULL << (MemgraphCypher::MATCH - 128))
      | (1ULL << (MemgraphCypher::MERGE - 128))
      | (1ULL << (MemgraphCypher::NODE - 128))
      | (1ULL << (MemgraphCypher::NONE - 128))
      | (1ULL << (MemgraphCypher::NOT - 128))
      | (1ULL << (MemgraphCypher::ON - 128))
      | (1ULL << (MemgraphCypher::OPTIONAL - 128))
      | (1ULL << (MemgraphCypher::OR - 128))
      | (1ULL << (MemgraphCypher::ORDER - 128))
      | (1ULL << (MemgraphCypher::PROCEDURE - 128))
      | (1ULL << (MemgraphCypher::PROFILE - 128))
      | (1ULL << (MemgraphCypher::QUERY - 128))
      | (1ULL << (MemgraphCypher::REDUCE - 128))
      | (1ULL << (MemgraphCypher::REMOVE - 128))
      | (1ULL << (MemgraphCypher::RETURN - 128))
      | (1ULL << (MemgraphCypher::SET - 128))
      | (1ULL << (MemgraphCypher::SHOW - 128))
      | (1ULL << (MemgraphCypher::SINGLE - 128))
      | (1ULL << (MemgraphCypher::STARTS - 128))
      | (1ULL << (MemgraphCypher::STORAGE - 128))
      | (1ULL << (MemgraphCypher::THEN - 128))
      | (1ULL << (MemgraphCypher::TRUE - 128))
      | (1ULL << (MemgraphCypher::UNION - 128))
      | (1ULL << (MemgraphCypher::UNIQUE - 128))
      | (1ULL << (MemgraphCypher::UNWIND - 128))
      | (1ULL << (MemgraphCypher::WHEN - 128))
      | (1ULL << (MemgraphCypher::WHERE - 128))
      | (1ULL << (MemgraphCypher::WITH - 128)))) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & ((1ULL << (MemgraphCypher::WSHORTEST - 192))
      | (1ULL << (MemgraphCypher::XOR - 192))
      | (1ULL << (MemgraphCypher::YIELD - 192))
      | (1ULL << (MemgraphCypher::StringLiteral - 192))
      | (1ULL << (MemgraphCypher::DecimalLiteral - 192))
      | (1ULL << (MemgraphCypher::OctalLiteral - 192))
      | (1ULL << (MemgraphCypher::HexadecimalLiteral - 192))
      | (1ULL << (MemgraphCypher::FloatingLiteral - 192))
      | (1ULL << (MemgraphCypher::UnescapedSymbolicName - 192))
      | (1ULL << (MemgraphCypher::EscapedSymbolicName - 192)))) != 0)) {
      setState(1739);
      expression();
      setState(1744);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MemgraphCypher::COMMA) {
        setState(1740);
        match(MemgraphCypher::COMMA);
        setState(1741);
        expression();
        setState(1746);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1749);
    match(MemgraphCypher::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionNameContext ------------------------------------------------------------------

MemgraphCypher::FunctionNameContext::FunctionNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MemgraphCypher::SymbolicNameContext *> MemgraphCypher::FunctionNameContext::symbolicName() {
  return getRuleContexts<MemgraphCypher::SymbolicNameContext>();
}

MemgraphCypher::SymbolicNameContext* MemgraphCypher::FunctionNameContext::symbolicName(size_t i) {
  return getRuleContext<MemgraphCypher::SymbolicNameContext>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::FunctionNameContext::DOT() {
  return getTokens(MemgraphCypher::DOT);
}

tree::TerminalNode* MemgraphCypher::FunctionNameContext::DOT(size_t i) {
  return getToken(MemgraphCypher::DOT, i);
}


size_t MemgraphCypher::FunctionNameContext::getRuleIndex() const {
  return MemgraphCypher::RuleFunctionName;
}

void MemgraphCypher::FunctionNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionName(this);
}

void MemgraphCypher::FunctionNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionName(this);
}


std::any MemgraphCypher::FunctionNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitFunctionName(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::FunctionNameContext* MemgraphCypher::functionName() {
  FunctionNameContext *_localctx = _tracker.createInstance<FunctionNameContext>(_ctx, getState());
  enterRule(_localctx, 340, MemgraphCypher::RuleFunctionName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1751);
    symbolicName();
    setState(1756);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MemgraphCypher::DOT) {
      setState(1752);
      match(MemgraphCypher::DOT);
      setState(1753);
      symbolicName();
      setState(1758);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ListComprehensionContext ------------------------------------------------------------------

MemgraphCypher::ListComprehensionContext::ListComprehensionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ListComprehensionContext::LBRACK() {
  return getToken(MemgraphCypher::LBRACK, 0);
}

MemgraphCypher::FilterExpressionContext* MemgraphCypher::ListComprehensionContext::filterExpression() {
  return getRuleContext<MemgraphCypher::FilterExpressionContext>(0);
}

tree::TerminalNode* MemgraphCypher::ListComprehensionContext::RBRACK() {
  return getToken(MemgraphCypher::RBRACK, 0);
}

tree::TerminalNode* MemgraphCypher::ListComprehensionContext::PIPE() {
  return getToken(MemgraphCypher::PIPE, 0);
}

MemgraphCypher::ExpressionContext* MemgraphCypher::ListComprehensionContext::expression() {
  return getRuleContext<MemgraphCypher::ExpressionContext>(0);
}


size_t MemgraphCypher::ListComprehensionContext::getRuleIndex() const {
  return MemgraphCypher::RuleListComprehension;
}

void MemgraphCypher::ListComprehensionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterListComprehension(this);
}

void MemgraphCypher::ListComprehensionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitListComprehension(this);
}


std::any MemgraphCypher::ListComprehensionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitListComprehension(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ListComprehensionContext* MemgraphCypher::listComprehension() {
  ListComprehensionContext *_localctx = _tracker.createInstance<ListComprehensionContext>(_ctx, getState());
  enterRule(_localctx, 342, MemgraphCypher::RuleListComprehension);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1759);
    match(MemgraphCypher::LBRACK);
    setState(1760);
    filterExpression();
    setState(1763);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::PIPE) {
      setState(1761);
      match(MemgraphCypher::PIPE);
      setState(1762);
      expression();
    }
    setState(1765);
    match(MemgraphCypher::RBRACK);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PatternComprehensionContext ------------------------------------------------------------------

MemgraphCypher::PatternComprehensionContext::PatternComprehensionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::PatternComprehensionContext::LBRACK() {
  return getToken(MemgraphCypher::LBRACK, 0);
}

MemgraphCypher::RelationshipsPatternContext* MemgraphCypher::PatternComprehensionContext::relationshipsPattern() {
  return getRuleContext<MemgraphCypher::RelationshipsPatternContext>(0);
}

tree::TerminalNode* MemgraphCypher::PatternComprehensionContext::PIPE() {
  return getToken(MemgraphCypher::PIPE, 0);
}

std::vector<MemgraphCypher::ExpressionContext *> MemgraphCypher::PatternComprehensionContext::expression() {
  return getRuleContexts<MemgraphCypher::ExpressionContext>();
}

MemgraphCypher::ExpressionContext* MemgraphCypher::PatternComprehensionContext::expression(size_t i) {
  return getRuleContext<MemgraphCypher::ExpressionContext>(i);
}

tree::TerminalNode* MemgraphCypher::PatternComprehensionContext::RBRACK() {
  return getToken(MemgraphCypher::RBRACK, 0);
}

MemgraphCypher::VariableContext* MemgraphCypher::PatternComprehensionContext::variable() {
  return getRuleContext<MemgraphCypher::VariableContext>(0);
}

tree::TerminalNode* MemgraphCypher::PatternComprehensionContext::EQ() {
  return getToken(MemgraphCypher::EQ, 0);
}

tree::TerminalNode* MemgraphCypher::PatternComprehensionContext::WHERE() {
  return getToken(MemgraphCypher::WHERE, 0);
}


size_t MemgraphCypher::PatternComprehensionContext::getRuleIndex() const {
  return MemgraphCypher::RulePatternComprehension;
}

void MemgraphCypher::PatternComprehensionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPatternComprehension(this);
}

void MemgraphCypher::PatternComprehensionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPatternComprehension(this);
}


std::any MemgraphCypher::PatternComprehensionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitPatternComprehension(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::PatternComprehensionContext* MemgraphCypher::patternComprehension() {
  PatternComprehensionContext *_localctx = _tracker.createInstance<PatternComprehensionContext>(_ctx, getState());
  enterRule(_localctx, 344, MemgraphCypher::RulePatternComprehension);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1767);
    match(MemgraphCypher::LBRACK);
    setState(1771);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MemgraphCypher::AFTER)
      | (1ULL << MemgraphCypher::ALTER)
      | (1ULL << MemgraphCypher::ASYNC)
      | (1ULL << MemgraphCypher::AUTH)
      | (1ULL << MemgraphCypher::BAD)
      | (1ULL << MemgraphCypher::BATCH_INTERVAL)
      | (1ULL << MemgraphCypher::BATCH_LIMIT)
      | (1ULL << MemgraphCypher::BATCH_SIZE)
      | (1ULL << MemgraphCypher::BEFORE)
      | (1ULL << MemgraphCypher::BOOTSTRAP_SERVERS)
      | (1ULL << MemgraphCypher::CHECK)
      | (1ULL << MemgraphCypher::CLEAR)
      | (1ULL << MemgraphCypher::COMMIT)
      | (1ULL << MemgraphCypher::COMMITTED)
      | (1ULL << MemgraphCypher::CONFIG)
      | (1ULL << MemgraphCypher::CONFIGS)
      | (1ULL << MemgraphCypher::CONSUMER_GROUP)
      | (1ULL << MemgraphCypher::CREDENTIALS)
      | (1ULL << MemgraphCypher::CSV)
      | (1ULL << MemgraphCypher::DATA)
      | (1ULL << MemgraphCypher::DELIMITER)
      | (1ULL << MemgraphCypher::DATABASE)
      | (1ULL << MemgraphCypher::DENY)
      | (1ULL << MemgraphCypher::DROP)
      | (1ULL << MemgraphCypher::DUMP)
      | (1ULL << MemgraphCypher::EXECUTE)
      | (1ULL << MemgraphCypher::FOR)
      | (1ULL << MemgraphCypher::FOREACH)
      | (1ULL << MemgraphCypher::FREE)
      | (1ULL << MemgraphCypher::FROM)
      | (1ULL << MemgraphCypher::GLOBAL)
      | (1ULL << MemgraphCypher::GRANT)
      | (1ULL << MemgraphCypher::HEADER)
      | (1ULL << MemgraphCypher::IDENTIFIED)
      | (1ULL << MemgraphCypher::ISOLATION)
      | (1ULL << MemgraphCypher::KAFKA)
      | (1ULL << MemgraphCypher::LEVEL)
      | (1ULL << MemgraphCypher::LOAD)
      | (1ULL << MemgraphCypher::LOCK)
      | (1ULL << MemgraphCypher::MAIN)
      | (1ULL << MemgraphCypher::MODE)
      | (1ULL << MemgraphCypher::NEXT)
      | (1ULL << MemgraphCypher::NO)
      | (1ULL << MemgraphCypher::PASSWORD)
      | (1ULL << MemgraphCypher::PORT)
      | (1ULL << MemgraphCypher::PRIVILEGES)
      | (1ULL << MemgraphCypher::PULSAR)
      | (1ULL << MemgraphCypher::READ)
      | (1ULL << MemgraphCypher::REGISTER)
      | (1ULL << MemgraphCypher::REPLICA)
      | (1ULL << MemgraphCypher::REPLICAS)
      | (1ULL << MemgraphCypher::REPLICATION)
      | (1ULL << MemgraphCypher::REVOKE)
      | (1ULL << MemgraphCypher::ROLE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (MemgraphCypher::ROLES - 64))
      | (1ULL << (MemgraphCypher::QUOTE - 64))
      | (1ULL << (MemgraphCypher::SESSION - 64))
      | (1ULL << (MemgraphCypher::SETTING - 64))
      | (1ULL << (MemgraphCypher::SETTINGS - 64))
      | (1ULL << (MemgraphCypher::SNAPSHOT - 64))
      | (1ULL << (MemgraphCypher::START - 64))
      | (1ULL << (MemgraphCypher::STATS - 64))
      | (1ULL << (MemgraphCypher::STREAM - 64))
      | (1ULL << (MemgraphCypher::STREAMS - 64))
      | (1ULL << (MemgraphCypher::SYNC - 64))
      | (1ULL << (MemgraphCypher::TIMEOUT - 64))
      | (1ULL << (MemgraphCypher::TO - 64))
      | (1ULL << (MemgraphCypher::TOPICS - 64))
      | (1ULL << (MemgraphCypher::TRANSACTION - 64))
      | (1ULL << (MemgraphCypher::TRANSFORM - 64))
      | (1ULL << (MemgraphCypher::TRIGGER - 64))
      | (1ULL << (MemgraphCypher::TRIGGERS - 64))
      | (1ULL << (MemgraphCypher::UNCOMMITTED - 64))
      | (1ULL << (MemgraphCypher::UNLOCK - 64))
      | (1ULL << (MemgraphCypher::UPDATE - 64))
      | (1ULL << (MemgraphCypher::USER - 64))
      | (1ULL << (MemgraphCypher::USERS - 64))
      | (1ULL << (MemgraphCypher::VERSION - 64))
      | (1ULL << (MemgraphCypher::ALL - 64))
      | (1ULL << (MemgraphCypher::AND - 64))
      | (1ULL << (MemgraphCypher::ANY - 64))
      | (1ULL << (MemgraphCypher::AS - 64))
      | (1ULL << (MemgraphCypher::ASC - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (MemgraphCypher::ASCENDING - 128))
      | (1ULL << (MemgraphCypher::ASSERT - 128))
      | (1ULL << (MemgraphCypher::BFS - 128))
      | (1ULL << (MemgraphCypher::BY - 128))
      | (1ULL << (MemgraphCypher::CALL - 128))
      | (1ULL << (MemgraphCypher::CASE - 128))
      | (1ULL << (MemgraphCypher::CONSTRAINT - 128))
      | (1ULL << (MemgraphCypher::CONTAINS - 128))
      | (1ULL << (MemgraphCypher::COUNT - 128))
      | (1ULL << (MemgraphCypher::CREATE - 128))
      | (1ULL << (MemgraphCypher::CYPHERNULL - 128))
      | (1ULL << (MemgraphCypher::DELETE - 128))
      | (1ULL << (MemgraphCypher::DESC - 128))
      | (1ULL << (MemgraphCypher::DESCENDING - 128))
      | (1ULL << (MemgraphCypher::DETACH - 128))
      | (1ULL << (MemgraphCypher::DISTINCT - 128))
      | (1ULL << (MemgraphCypher::ELSE - 128))
      | (1ULL << (MemgraphCypher::END - 128))
      | (1ULL << (MemgraphCypher::ENDS - 128))
      | (1ULL << (MemgraphCypher::EXISTS - 128))
      | (1ULL << (MemgraphCypher::EXPLAIN - 128))
      | (1ULL << (MemgraphCypher::EXTRACT - 128))
      | (1ULL << (MemgraphCypher::FALSE - 128))
      | (1ULL << (MemgraphCypher::FILTER - 128))
      | (1ULL << (MemgraphCypher::IN - 128))
      | (1ULL << (MemgraphCypher::INDEX - 128))
      | (1ULL << (MemgraphCypher::INFO - 128))
      | (1ULL << (MemgraphCypher::IS - 128))
      | (1ULL << (MemgraphCypher::KEY - 128))
      | (1ULL << (MemgraphCypher::LIMIT - 128))
      | (1ULL << (MemgraphCypher::L_SKIP - 128))
      | (1ULL << (MemgraphCypher::MATCH - 128))
      | (1ULL << (MemgraphCypher::MERGE - 128))
      | (1ULL << (MemgraphCypher::NODE - 128))
      | (1ULL << (MemgraphCypher::NONE - 128))
      | (1ULL << (MemgraphCypher::NOT - 128))
      | (1ULL << (MemgraphCypher::ON - 128))
      | (1ULL << (MemgraphCypher::OPTIONAL - 128))
      | (1ULL << (MemgraphCypher::OR - 128))
      | (1ULL << (MemgraphCypher::ORDER - 128))
      | (1ULL << (MemgraphCypher::PROCEDURE - 128))
      | (1ULL << (MemgraphCypher::PROFILE - 128))
      | (1ULL << (MemgraphCypher::QUERY - 128))
      | (1ULL << (MemgraphCypher::REDUCE - 128))
      | (1ULL << (MemgraphCypher::REMOVE - 128))
      | (1ULL << (MemgraphCypher::RETURN - 128))
      | (1ULL << (MemgraphCypher::SET - 128))
      | (1ULL << (MemgraphCypher::SHOW - 128))
      | (1ULL << (MemgraphCypher::SINGLE - 128))
      | (1ULL << (MemgraphCypher::STARTS - 128))
      | (1ULL << (MemgraphCypher::STORAGE - 128))
      | (1ULL << (MemgraphCypher::THEN - 128))
      | (1ULL << (MemgraphCypher::TRUE - 128))
      | (1ULL << (MemgraphCypher::UNION - 128))
      | (1ULL << (MemgraphCypher::UNIQUE - 128))
      | (1ULL << (MemgraphCypher::UNWIND - 128))
      | (1ULL << (MemgraphCypher::WHEN - 128))
      | (1ULL << (MemgraphCypher::WHERE - 128))
      | (1ULL << (MemgraphCypher::WITH - 128)))) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & ((1ULL << (MemgraphCypher::WSHORTEST - 192))
      | (1ULL << (MemgraphCypher::XOR - 192))
      | (1ULL << (MemgraphCypher::YIELD - 192))
      | (1ULL << (MemgraphCypher::UnescapedSymbolicName - 192))
      | (1ULL << (MemgraphCypher::EscapedSymbolicName - 192)))) != 0)) {
      setState(1768);
      variable();
      setState(1769);
      match(MemgraphCypher::EQ);
    }
    setState(1773);
    relationshipsPattern();
    setState(1776);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::WHERE) {
      setState(1774);
      match(MemgraphCypher::WHERE);
      setState(1775);
      expression();
    }
    setState(1778);
    match(MemgraphCypher::PIPE);
    setState(1779);
    expression();
    setState(1780);
    match(MemgraphCypher::RBRACK);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyLookupContext ------------------------------------------------------------------

MemgraphCypher::PropertyLookupContext::PropertyLookupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::PropertyLookupContext::DOT() {
  return getToken(MemgraphCypher::DOT, 0);
}

MemgraphCypher::PropertyKeyNameContext* MemgraphCypher::PropertyLookupContext::propertyKeyName() {
  return getRuleContext<MemgraphCypher::PropertyKeyNameContext>(0);
}


size_t MemgraphCypher::PropertyLookupContext::getRuleIndex() const {
  return MemgraphCypher::RulePropertyLookup;
}

void MemgraphCypher::PropertyLookupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyLookup(this);
}

void MemgraphCypher::PropertyLookupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyLookup(this);
}


std::any MemgraphCypher::PropertyLookupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitPropertyLookup(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::PropertyLookupContext* MemgraphCypher::propertyLookup() {
  PropertyLookupContext *_localctx = _tracker.createInstance<PropertyLookupContext>(_ctx, getState());
  enterRule(_localctx, 346, MemgraphCypher::RulePropertyLookup);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1782);
    match(MemgraphCypher::DOT);

    setState(1783);
    propertyKeyName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseExpressionContext ------------------------------------------------------------------

MemgraphCypher::CaseExpressionContext::CaseExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::CaseExpressionContext::END() {
  return getToken(MemgraphCypher::END, 0);
}

tree::TerminalNode* MemgraphCypher::CaseExpressionContext::ELSE() {
  return getToken(MemgraphCypher::ELSE, 0);
}

tree::TerminalNode* MemgraphCypher::CaseExpressionContext::CASE() {
  return getToken(MemgraphCypher::CASE, 0);
}

std::vector<MemgraphCypher::ExpressionContext *> MemgraphCypher::CaseExpressionContext::expression() {
  return getRuleContexts<MemgraphCypher::ExpressionContext>();
}

MemgraphCypher::ExpressionContext* MemgraphCypher::CaseExpressionContext::expression(size_t i) {
  return getRuleContext<MemgraphCypher::ExpressionContext>(i);
}

std::vector<MemgraphCypher::CaseAlternativesContext *> MemgraphCypher::CaseExpressionContext::caseAlternatives() {
  return getRuleContexts<MemgraphCypher::CaseAlternativesContext>();
}

MemgraphCypher::CaseAlternativesContext* MemgraphCypher::CaseExpressionContext::caseAlternatives(size_t i) {
  return getRuleContext<MemgraphCypher::CaseAlternativesContext>(i);
}


size_t MemgraphCypher::CaseExpressionContext::getRuleIndex() const {
  return MemgraphCypher::RuleCaseExpression;
}

void MemgraphCypher::CaseExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseExpression(this);
}

void MemgraphCypher::CaseExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseExpression(this);
}


std::any MemgraphCypher::CaseExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitCaseExpression(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::CaseExpressionContext* MemgraphCypher::caseExpression() {
  CaseExpressionContext *_localctx = _tracker.createInstance<CaseExpressionContext>(_ctx, getState());
  enterRule(_localctx, 348, MemgraphCypher::RuleCaseExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1798);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 152, _ctx)) {
    case 1: {
      setState(1785);
      match(MemgraphCypher::CASE);
      setState(1787); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(1786);
        caseAlternatives();
        setState(1789); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == MemgraphCypher::WHEN);
      break;
    }

    case 2: {
      setState(1791);
      match(MemgraphCypher::CASE);
      setState(1792);
      antlrcpp::downCast<CaseExpressionContext *>(_localctx)->test = expression();
      setState(1794); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(1793);
        caseAlternatives();
        setState(1796); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == MemgraphCypher::WHEN);
      break;
    }

    default:
      break;
    }
    setState(1802);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::ELSE) {
      setState(1800);
      match(MemgraphCypher::ELSE);
      setState(1801);
      antlrcpp::downCast<CaseExpressionContext *>(_localctx)->else_expression = expression();
    }
    setState(1804);
    match(MemgraphCypher::END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseAlternativesContext ------------------------------------------------------------------

MemgraphCypher::CaseAlternativesContext::CaseAlternativesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::CaseAlternativesContext::WHEN() {
  return getToken(MemgraphCypher::WHEN, 0);
}

tree::TerminalNode* MemgraphCypher::CaseAlternativesContext::THEN() {
  return getToken(MemgraphCypher::THEN, 0);
}

std::vector<MemgraphCypher::ExpressionContext *> MemgraphCypher::CaseAlternativesContext::expression() {
  return getRuleContexts<MemgraphCypher::ExpressionContext>();
}

MemgraphCypher::ExpressionContext* MemgraphCypher::CaseAlternativesContext::expression(size_t i) {
  return getRuleContext<MemgraphCypher::ExpressionContext>(i);
}


size_t MemgraphCypher::CaseAlternativesContext::getRuleIndex() const {
  return MemgraphCypher::RuleCaseAlternatives;
}

void MemgraphCypher::CaseAlternativesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseAlternatives(this);
}

void MemgraphCypher::CaseAlternativesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseAlternatives(this);
}


std::any MemgraphCypher::CaseAlternativesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitCaseAlternatives(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::CaseAlternativesContext* MemgraphCypher::caseAlternatives() {
  CaseAlternativesContext *_localctx = _tracker.createInstance<CaseAlternativesContext>(_ctx, getState());
  enterRule(_localctx, 350, MemgraphCypher::RuleCaseAlternatives);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1806);
    match(MemgraphCypher::WHEN);
    setState(1807);
    antlrcpp::downCast<CaseAlternativesContext *>(_localctx)->when_expression = expression();
    setState(1808);
    match(MemgraphCypher::THEN);
    setState(1809);
    antlrcpp::downCast<CaseAlternativesContext *>(_localctx)->then_expression = expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableContext ------------------------------------------------------------------

MemgraphCypher::VariableContext::VariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::SymbolicNameContext* MemgraphCypher::VariableContext::symbolicName() {
  return getRuleContext<MemgraphCypher::SymbolicNameContext>(0);
}


size_t MemgraphCypher::VariableContext::getRuleIndex() const {
  return MemgraphCypher::RuleVariable;
}

void MemgraphCypher::VariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable(this);
}

void MemgraphCypher::VariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable(this);
}


std::any MemgraphCypher::VariableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitVariable(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::VariableContext* MemgraphCypher::variable() {
  VariableContext *_localctx = _tracker.createInstance<VariableContext>(_ctx, getState());
  enterRule(_localctx, 352, MemgraphCypher::RuleVariable);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1811);
    symbolicName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumberLiteralContext ------------------------------------------------------------------

MemgraphCypher::NumberLiteralContext::NumberLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::DoubleLiteralContext* MemgraphCypher::NumberLiteralContext::doubleLiteral() {
  return getRuleContext<MemgraphCypher::DoubleLiteralContext>(0);
}

MemgraphCypher::IntegerLiteralContext* MemgraphCypher::NumberLiteralContext::integerLiteral() {
  return getRuleContext<MemgraphCypher::IntegerLiteralContext>(0);
}


size_t MemgraphCypher::NumberLiteralContext::getRuleIndex() const {
  return MemgraphCypher::RuleNumberLiteral;
}

void MemgraphCypher::NumberLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumberLiteral(this);
}

void MemgraphCypher::NumberLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumberLiteral(this);
}


std::any MemgraphCypher::NumberLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitNumberLiteral(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::NumberLiteralContext* MemgraphCypher::numberLiteral() {
  NumberLiteralContext *_localctx = _tracker.createInstance<NumberLiteralContext>(_ctx, getState());
  enterRule(_localctx, 354, MemgraphCypher::RuleNumberLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1815);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MemgraphCypher::FloatingLiteral: {
        enterOuterAlt(_localctx, 1);
        setState(1813);
        doubleLiteral();
        break;
      }

      case MemgraphCypher::DecimalLiteral:
      case MemgraphCypher::OctalLiteral:
      case MemgraphCypher::HexadecimalLiteral: {
        enterOuterAlt(_localctx, 2);
        setState(1814);
        integerLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MapLiteralContext ------------------------------------------------------------------

MemgraphCypher::MapLiteralContext::MapLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::MapLiteralContext::LBRACE() {
  return getToken(MemgraphCypher::LBRACE, 0);
}

tree::TerminalNode* MemgraphCypher::MapLiteralContext::RBRACE() {
  return getToken(MemgraphCypher::RBRACE, 0);
}

std::vector<MemgraphCypher::PropertyKeyNameContext *> MemgraphCypher::MapLiteralContext::propertyKeyName() {
  return getRuleContexts<MemgraphCypher::PropertyKeyNameContext>();
}

MemgraphCypher::PropertyKeyNameContext* MemgraphCypher::MapLiteralContext::propertyKeyName(size_t i) {
  return getRuleContext<MemgraphCypher::PropertyKeyNameContext>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::MapLiteralContext::COLON() {
  return getTokens(MemgraphCypher::COLON);
}

tree::TerminalNode* MemgraphCypher::MapLiteralContext::COLON(size_t i) {
  return getToken(MemgraphCypher::COLON, i);
}

std::vector<MemgraphCypher::ExpressionContext *> MemgraphCypher::MapLiteralContext::expression() {
  return getRuleContexts<MemgraphCypher::ExpressionContext>();
}

MemgraphCypher::ExpressionContext* MemgraphCypher::MapLiteralContext::expression(size_t i) {
  return getRuleContext<MemgraphCypher::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> MemgraphCypher::MapLiteralContext::COMMA() {
  return getTokens(MemgraphCypher::COMMA);
}

tree::TerminalNode* MemgraphCypher::MapLiteralContext::COMMA(size_t i) {
  return getToken(MemgraphCypher::COMMA, i);
}


size_t MemgraphCypher::MapLiteralContext::getRuleIndex() const {
  return MemgraphCypher::RuleMapLiteral;
}

void MemgraphCypher::MapLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMapLiteral(this);
}

void MemgraphCypher::MapLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMapLiteral(this);
}


std::any MemgraphCypher::MapLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitMapLiteral(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::MapLiteralContext* MemgraphCypher::mapLiteral() {
  MapLiteralContext *_localctx = _tracker.createInstance<MapLiteralContext>(_ctx, getState());
  enterRule(_localctx, 356, MemgraphCypher::RuleMapLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1817);
    match(MemgraphCypher::LBRACE);
    setState(1831);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MemgraphCypher::AFTER)
      | (1ULL << MemgraphCypher::ALTER)
      | (1ULL << MemgraphCypher::ASYNC)
      | (1ULL << MemgraphCypher::AUTH)
      | (1ULL << MemgraphCypher::BAD)
      | (1ULL << MemgraphCypher::BATCH_INTERVAL)
      | (1ULL << MemgraphCypher::BATCH_LIMIT)
      | (1ULL << MemgraphCypher::BATCH_SIZE)
      | (1ULL << MemgraphCypher::BEFORE)
      | (1ULL << MemgraphCypher::BOOTSTRAP_SERVERS)
      | (1ULL << MemgraphCypher::CHECK)
      | (1ULL << MemgraphCypher::CLEAR)
      | (1ULL << MemgraphCypher::COMMIT)
      | (1ULL << MemgraphCypher::COMMITTED)
      | (1ULL << MemgraphCypher::CONFIG)
      | (1ULL << MemgraphCypher::CONFIGS)
      | (1ULL << MemgraphCypher::CONSUMER_GROUP)
      | (1ULL << MemgraphCypher::CREDENTIALS)
      | (1ULL << MemgraphCypher::CSV)
      | (1ULL << MemgraphCypher::DATA)
      | (1ULL << MemgraphCypher::DELIMITER)
      | (1ULL << MemgraphCypher::DATABASE)
      | (1ULL << MemgraphCypher::DENY)
      | (1ULL << MemgraphCypher::DROP)
      | (1ULL << MemgraphCypher::DUMP)
      | (1ULL << MemgraphCypher::EXECUTE)
      | (1ULL << MemgraphCypher::FOR)
      | (1ULL << MemgraphCypher::FOREACH)
      | (1ULL << MemgraphCypher::FREE)
      | (1ULL << MemgraphCypher::FROM)
      | (1ULL << MemgraphCypher::GLOBAL)
      | (1ULL << MemgraphCypher::GRANT)
      | (1ULL << MemgraphCypher::HEADER)
      | (1ULL << MemgraphCypher::IDENTIFIED)
      | (1ULL << MemgraphCypher::ISOLATION)
      | (1ULL << MemgraphCypher::KAFKA)
      | (1ULL << MemgraphCypher::LEVEL)
      | (1ULL << MemgraphCypher::LOAD)
      | (1ULL << MemgraphCypher::LOCK)
      | (1ULL << MemgraphCypher::MAIN)
      | (1ULL << MemgraphCypher::MODE)
      | (1ULL << MemgraphCypher::NEXT)
      | (1ULL << MemgraphCypher::NO)
      | (1ULL << MemgraphCypher::PASSWORD)
      | (1ULL << MemgraphCypher::PORT)
      | (1ULL << MemgraphCypher::PRIVILEGES)
      | (1ULL << MemgraphCypher::PULSAR)
      | (1ULL << MemgraphCypher::READ)
      | (1ULL << MemgraphCypher::REGISTER)
      | (1ULL << MemgraphCypher::REPLICA)
      | (1ULL << MemgraphCypher::REPLICAS)
      | (1ULL << MemgraphCypher::REPLICATION)
      | (1ULL << MemgraphCypher::REVOKE)
      | (1ULL << MemgraphCypher::ROLE))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (MemgraphCypher::ROLES - 64))
      | (1ULL << (MemgraphCypher::QUOTE - 64))
      | (1ULL << (MemgraphCypher::SESSION - 64))
      | (1ULL << (MemgraphCypher::SETTING - 64))
      | (1ULL << (MemgraphCypher::SETTINGS - 64))
      | (1ULL << (MemgraphCypher::SNAPSHOT - 64))
      | (1ULL << (MemgraphCypher::START - 64))
      | (1ULL << (MemgraphCypher::STATS - 64))
      | (1ULL << (MemgraphCypher::STREAM - 64))
      | (1ULL << (MemgraphCypher::STREAMS - 64))
      | (1ULL << (MemgraphCypher::SYNC - 64))
      | (1ULL << (MemgraphCypher::TIMEOUT - 64))
      | (1ULL << (MemgraphCypher::TO - 64))
      | (1ULL << (MemgraphCypher::TOPICS - 64))
      | (1ULL << (MemgraphCypher::TRANSACTION - 64))
      | (1ULL << (MemgraphCypher::TRANSFORM - 64))
      | (1ULL << (MemgraphCypher::TRIGGER - 64))
      | (1ULL << (MemgraphCypher::TRIGGERS - 64))
      | (1ULL << (MemgraphCypher::UNCOMMITTED - 64))
      | (1ULL << (MemgraphCypher::UNLOCK - 64))
      | (1ULL << (MemgraphCypher::UPDATE - 64))
      | (1ULL << (MemgraphCypher::USER - 64))
      | (1ULL << (MemgraphCypher::USERS - 64))
      | (1ULL << (MemgraphCypher::VERSION - 64))
      | (1ULL << (MemgraphCypher::ALL - 64))
      | (1ULL << (MemgraphCypher::AND - 64))
      | (1ULL << (MemgraphCypher::ANY - 64))
      | (1ULL << (MemgraphCypher::AS - 64))
      | (1ULL << (MemgraphCypher::ASC - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (MemgraphCypher::ASCENDING - 128))
      | (1ULL << (MemgraphCypher::ASSERT - 128))
      | (1ULL << (MemgraphCypher::BFS - 128))
      | (1ULL << (MemgraphCypher::BY - 128))
      | (1ULL << (MemgraphCypher::CALL - 128))
      | (1ULL << (MemgraphCypher::CASE - 128))
      | (1ULL << (MemgraphCypher::CONSTRAINT - 128))
      | (1ULL << (MemgraphCypher::CONTAINS - 128))
      | (1ULL << (MemgraphCypher::COUNT - 128))
      | (1ULL << (MemgraphCypher::CREATE - 128))
      | (1ULL << (MemgraphCypher::CYPHERNULL - 128))
      | (1ULL << (MemgraphCypher::DELETE - 128))
      | (1ULL << (MemgraphCypher::DESC - 128))
      | (1ULL << (MemgraphCypher::DESCENDING - 128))
      | (1ULL << (MemgraphCypher::DETACH - 128))
      | (1ULL << (MemgraphCypher::DISTINCT - 128))
      | (1ULL << (MemgraphCypher::ELSE - 128))
      | (1ULL << (MemgraphCypher::END - 128))
      | (1ULL << (MemgraphCypher::ENDS - 128))
      | (1ULL << (MemgraphCypher::EXISTS - 128))
      | (1ULL << (MemgraphCypher::EXPLAIN - 128))
      | (1ULL << (MemgraphCypher::EXTRACT - 128))
      | (1ULL << (MemgraphCypher::FALSE - 128))
      | (1ULL << (MemgraphCypher::FILTER - 128))
      | (1ULL << (MemgraphCypher::IN - 128))
      | (1ULL << (MemgraphCypher::INDEX - 128))
      | (1ULL << (MemgraphCypher::INFO - 128))
      | (1ULL << (MemgraphCypher::IS - 128))
      | (1ULL << (MemgraphCypher::KEY - 128))
      | (1ULL << (MemgraphCypher::LIMIT - 128))
      | (1ULL << (MemgraphCypher::L_SKIP - 128))
      | (1ULL << (MemgraphCypher::MATCH - 128))
      | (1ULL << (MemgraphCypher::MERGE - 128))
      | (1ULL << (MemgraphCypher::NODE - 128))
      | (1ULL << (MemgraphCypher::NONE - 128))
      | (1ULL << (MemgraphCypher::NOT - 128))
      | (1ULL << (MemgraphCypher::ON - 128))
      | (1ULL << (MemgraphCypher::OPTIONAL - 128))
      | (1ULL << (MemgraphCypher::OR - 128))
      | (1ULL << (MemgraphCypher::ORDER - 128))
      | (1ULL << (MemgraphCypher::PROCEDURE - 128))
      | (1ULL << (MemgraphCypher::PROFILE - 128))
      | (1ULL << (MemgraphCypher::QUERY - 128))
      | (1ULL << (MemgraphCypher::REDUCE - 128))
      | (1ULL << (MemgraphCypher::REMOVE - 128))
      | (1ULL << (MemgraphCypher::RETURN - 128))
      | (1ULL << (MemgraphCypher::SET - 128))
      | (1ULL << (MemgraphCypher::SHOW - 128))
      | (1ULL << (MemgraphCypher::SINGLE - 128))
      | (1ULL << (MemgraphCypher::STARTS - 128))
      | (1ULL << (MemgraphCypher::STORAGE - 128))
      | (1ULL << (MemgraphCypher::THEN - 128))
      | (1ULL << (MemgraphCypher::TRUE - 128))
      | (1ULL << (MemgraphCypher::UNION - 128))
      | (1ULL << (MemgraphCypher::UNIQUE - 128))
      | (1ULL << (MemgraphCypher::UNWIND - 128))
      | (1ULL << (MemgraphCypher::WHEN - 128))
      | (1ULL << (MemgraphCypher::WHERE - 128))
      | (1ULL << (MemgraphCypher::WITH - 128)))) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & ((1ULL << (MemgraphCypher::WSHORTEST - 192))
      | (1ULL << (MemgraphCypher::XOR - 192))
      | (1ULL << (MemgraphCypher::YIELD - 192))
      | (1ULL << (MemgraphCypher::UnescapedSymbolicName - 192))
      | (1ULL << (MemgraphCypher::EscapedSymbolicName - 192)))) != 0)) {
      setState(1818);
      propertyKeyName();
      setState(1819);
      match(MemgraphCypher::COLON);
      setState(1820);
      expression();
      setState(1828);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MemgraphCypher::COMMA) {
        setState(1821);
        match(MemgraphCypher::COMMA);
        setState(1822);
        propertyKeyName();
        setState(1823);
        match(MemgraphCypher::COLON);
        setState(1824);
        expression();
        setState(1830);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1833);
    match(MemgraphCypher::RBRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterContext ------------------------------------------------------------------

MemgraphCypher::ParameterContext::ParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::ParameterContext::DOLLAR() {
  return getToken(MemgraphCypher::DOLLAR, 0);
}

MemgraphCypher::SymbolicNameContext* MemgraphCypher::ParameterContext::symbolicName() {
  return getRuleContext<MemgraphCypher::SymbolicNameContext>(0);
}

tree::TerminalNode* MemgraphCypher::ParameterContext::DecimalLiteral() {
  return getToken(MemgraphCypher::DecimalLiteral, 0);
}


size_t MemgraphCypher::ParameterContext::getRuleIndex() const {
  return MemgraphCypher::RuleParameter;
}

void MemgraphCypher::ParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter(this);
}

void MemgraphCypher::ParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter(this);
}


std::any MemgraphCypher::ParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitParameter(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::ParameterContext* MemgraphCypher::parameter() {
  ParameterContext *_localctx = _tracker.createInstance<ParameterContext>(_ctx, getState());
  enterRule(_localctx, 358, MemgraphCypher::RuleParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1835);
    match(MemgraphCypher::DOLLAR);
    setState(1838);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MemgraphCypher::AFTER:
      case MemgraphCypher::ALTER:
      case MemgraphCypher::ASYNC:
      case MemgraphCypher::AUTH:
      case MemgraphCypher::BAD:
      case MemgraphCypher::BATCH_INTERVAL:
      case MemgraphCypher::BATCH_LIMIT:
      case MemgraphCypher::BATCH_SIZE:
      case MemgraphCypher::BEFORE:
      case MemgraphCypher::BOOTSTRAP_SERVERS:
      case MemgraphCypher::CHECK:
      case MemgraphCypher::CLEAR:
      case MemgraphCypher::COMMIT:
      case MemgraphCypher::COMMITTED:
      case MemgraphCypher::CONFIG:
      case MemgraphCypher::CONFIGS:
      case MemgraphCypher::CONSUMER_GROUP:
      case MemgraphCypher::CREDENTIALS:
      case MemgraphCypher::CSV:
      case MemgraphCypher::DATA:
      case MemgraphCypher::DELIMITER:
      case MemgraphCypher::DATABASE:
      case MemgraphCypher::DENY:
      case MemgraphCypher::DROP:
      case MemgraphCypher::DUMP:
      case MemgraphCypher::EXECUTE:
      case MemgraphCypher::FOR:
      case MemgraphCypher::FOREACH:
      case MemgraphCypher::FREE:
      case MemgraphCypher::FROM:
      case MemgraphCypher::GLOBAL:
      case MemgraphCypher::GRANT:
      case MemgraphCypher::HEADER:
      case MemgraphCypher::IDENTIFIED:
      case MemgraphCypher::ISOLATION:
      case MemgraphCypher::KAFKA:
      case MemgraphCypher::LEVEL:
      case MemgraphCypher::LOAD:
      case MemgraphCypher::LOCK:
      case MemgraphCypher::MAIN:
      case MemgraphCypher::MODE:
      case MemgraphCypher::NEXT:
      case MemgraphCypher::NO:
      case MemgraphCypher::PASSWORD:
      case MemgraphCypher::PORT:
      case MemgraphCypher::PRIVILEGES:
      case MemgraphCypher::PULSAR:
      case MemgraphCypher::READ:
      case MemgraphCypher::REGISTER:
      case MemgraphCypher::REPLICA:
      case MemgraphCypher::REPLICAS:
      case MemgraphCypher::REPLICATION:
      case MemgraphCypher::REVOKE:
      case MemgraphCypher::ROLE:
      case MemgraphCypher::ROLES:
      case MemgraphCypher::QUOTE:
      case MemgraphCypher::SESSION:
      case MemgraphCypher::SETTING:
      case MemgraphCypher::SETTINGS:
      case MemgraphCypher::SNAPSHOT:
      case MemgraphCypher::START:
      case MemgraphCypher::STATS:
      case MemgraphCypher::STREAM:
      case MemgraphCypher::STREAMS:
      case MemgraphCypher::SYNC:
      case MemgraphCypher::TIMEOUT:
      case MemgraphCypher::TO:
      case MemgraphCypher::TOPICS:
      case MemgraphCypher::TRANSACTION:
      case MemgraphCypher::TRANSFORM:
      case MemgraphCypher::TRIGGER:
      case MemgraphCypher::TRIGGERS:
      case MemgraphCypher::UNCOMMITTED:
      case MemgraphCypher::UNLOCK:
      case MemgraphCypher::UPDATE:
      case MemgraphCypher::USER:
      case MemgraphCypher::USERS:
      case MemgraphCypher::VERSION:
      case MemgraphCypher::ALL:
      case MemgraphCypher::AND:
      case MemgraphCypher::ANY:
      case MemgraphCypher::AS:
      case MemgraphCypher::ASC:
      case MemgraphCypher::ASCENDING:
      case MemgraphCypher::ASSERT:
      case MemgraphCypher::BFS:
      case MemgraphCypher::BY:
      case MemgraphCypher::CALL:
      case MemgraphCypher::CASE:
      case MemgraphCypher::CONSTRAINT:
      case MemgraphCypher::CONTAINS:
      case MemgraphCypher::COUNT:
      case MemgraphCypher::CREATE:
      case MemgraphCypher::CYPHERNULL:
      case MemgraphCypher::DELETE:
      case MemgraphCypher::DESC:
      case MemgraphCypher::DESCENDING:
      case MemgraphCypher::DETACH:
      case MemgraphCypher::DISTINCT:
      case MemgraphCypher::ELSE:
      case MemgraphCypher::END:
      case MemgraphCypher::ENDS:
      case MemgraphCypher::EXISTS:
      case MemgraphCypher::EXPLAIN:
      case MemgraphCypher::EXTRACT:
      case MemgraphCypher::FALSE:
      case MemgraphCypher::FILTER:
      case MemgraphCypher::IN:
      case MemgraphCypher::INDEX:
      case MemgraphCypher::INFO:
      case MemgraphCypher::IS:
      case MemgraphCypher::KEY:
      case MemgraphCypher::LIMIT:
      case MemgraphCypher::L_SKIP:
      case MemgraphCypher::MATCH:
      case MemgraphCypher::MERGE:
      case MemgraphCypher::NODE:
      case MemgraphCypher::NONE:
      case MemgraphCypher::NOT:
      case MemgraphCypher::ON:
      case MemgraphCypher::OPTIONAL:
      case MemgraphCypher::OR:
      case MemgraphCypher::ORDER:
      case MemgraphCypher::PROCEDURE:
      case MemgraphCypher::PROFILE:
      case MemgraphCypher::QUERY:
      case MemgraphCypher::REDUCE:
      case MemgraphCypher::REMOVE:
      case MemgraphCypher::RETURN:
      case MemgraphCypher::SET:
      case MemgraphCypher::SHOW:
      case MemgraphCypher::SINGLE:
      case MemgraphCypher::STARTS:
      case MemgraphCypher::STORAGE:
      case MemgraphCypher::THEN:
      case MemgraphCypher::TRUE:
      case MemgraphCypher::UNION:
      case MemgraphCypher::UNIQUE:
      case MemgraphCypher::UNWIND:
      case MemgraphCypher::WHEN:
      case MemgraphCypher::WHERE:
      case MemgraphCypher::WITH:
      case MemgraphCypher::WSHORTEST:
      case MemgraphCypher::XOR:
      case MemgraphCypher::YIELD:
      case MemgraphCypher::UnescapedSymbolicName:
      case MemgraphCypher::EscapedSymbolicName: {
        setState(1836);
        symbolicName();
        break;
      }

      case MemgraphCypher::DecimalLiteral: {
        setState(1837);
        match(MemgraphCypher::DecimalLiteral);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyExpressionContext ------------------------------------------------------------------

MemgraphCypher::PropertyExpressionContext::PropertyExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::AtomContext* MemgraphCypher::PropertyExpressionContext::atom() {
  return getRuleContext<MemgraphCypher::AtomContext>(0);
}

std::vector<MemgraphCypher::PropertyLookupContext *> MemgraphCypher::PropertyExpressionContext::propertyLookup() {
  return getRuleContexts<MemgraphCypher::PropertyLookupContext>();
}

MemgraphCypher::PropertyLookupContext* MemgraphCypher::PropertyExpressionContext::propertyLookup(size_t i) {
  return getRuleContext<MemgraphCypher::PropertyLookupContext>(i);
}


size_t MemgraphCypher::PropertyExpressionContext::getRuleIndex() const {
  return MemgraphCypher::RulePropertyExpression;
}

void MemgraphCypher::PropertyExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyExpression(this);
}

void MemgraphCypher::PropertyExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyExpression(this);
}


std::any MemgraphCypher::PropertyExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitPropertyExpression(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::PropertyExpressionContext* MemgraphCypher::propertyExpression() {
  PropertyExpressionContext *_localctx = _tracker.createInstance<PropertyExpressionContext>(_ctx, getState());
  enterRule(_localctx, 360, MemgraphCypher::RulePropertyExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1840);
    atom();
    setState(1842); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1841);
      propertyLookup();
      setState(1844); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == MemgraphCypher::DOT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyKeyNameContext ------------------------------------------------------------------

MemgraphCypher::PropertyKeyNameContext::PropertyKeyNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MemgraphCypher::SymbolicNameContext* MemgraphCypher::PropertyKeyNameContext::symbolicName() {
  return getRuleContext<MemgraphCypher::SymbolicNameContext>(0);
}


size_t MemgraphCypher::PropertyKeyNameContext::getRuleIndex() const {
  return MemgraphCypher::RulePropertyKeyName;
}

void MemgraphCypher::PropertyKeyNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyKeyName(this);
}

void MemgraphCypher::PropertyKeyNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyKeyName(this);
}


std::any MemgraphCypher::PropertyKeyNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitPropertyKeyName(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::PropertyKeyNameContext* MemgraphCypher::propertyKeyName() {
  PropertyKeyNameContext *_localctx = _tracker.createInstance<PropertyKeyNameContext>(_ctx, getState());
  enterRule(_localctx, 362, MemgraphCypher::RulePropertyKeyName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1846);
    symbolicName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntegerLiteralContext ------------------------------------------------------------------

MemgraphCypher::IntegerLiteralContext::IntegerLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::IntegerLiteralContext::DecimalLiteral() {
  return getToken(MemgraphCypher::DecimalLiteral, 0);
}

tree::TerminalNode* MemgraphCypher::IntegerLiteralContext::OctalLiteral() {
  return getToken(MemgraphCypher::OctalLiteral, 0);
}

tree::TerminalNode* MemgraphCypher::IntegerLiteralContext::HexadecimalLiteral() {
  return getToken(MemgraphCypher::HexadecimalLiteral, 0);
}


size_t MemgraphCypher::IntegerLiteralContext::getRuleIndex() const {
  return MemgraphCypher::RuleIntegerLiteral;
}

void MemgraphCypher::IntegerLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntegerLiteral(this);
}

void MemgraphCypher::IntegerLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntegerLiteral(this);
}


std::any MemgraphCypher::IntegerLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitIntegerLiteral(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::IntegerLiteralContext* MemgraphCypher::integerLiteral() {
  IntegerLiteralContext *_localctx = _tracker.createInstance<IntegerLiteralContext>(_ctx, getState());
  enterRule(_localctx, 364, MemgraphCypher::RuleIntegerLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1848);
    _la = _input->LA(1);
    if (!(((((_la - 196) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 196)) & ((1ULL << (MemgraphCypher::DecimalLiteral - 196))
      | (1ULL << (MemgraphCypher::OctalLiteral - 196))
      | (1ULL << (MemgraphCypher::HexadecimalLiteral - 196)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateIndexContext ------------------------------------------------------------------

MemgraphCypher::CreateIndexContext::CreateIndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::CreateIndexContext::CREATE() {
  return getToken(MemgraphCypher::CREATE, 0);
}

tree::TerminalNode* MemgraphCypher::CreateIndexContext::INDEX() {
  return getToken(MemgraphCypher::INDEX, 0);
}

tree::TerminalNode* MemgraphCypher::CreateIndexContext::ON() {
  return getToken(MemgraphCypher::ON, 0);
}

tree::TerminalNode* MemgraphCypher::CreateIndexContext::COLON() {
  return getToken(MemgraphCypher::COLON, 0);
}

MemgraphCypher::LabelNameContext* MemgraphCypher::CreateIndexContext::labelName() {
  return getRuleContext<MemgraphCypher::LabelNameContext>(0);
}

tree::TerminalNode* MemgraphCypher::CreateIndexContext::LPAREN() {
  return getToken(MemgraphCypher::LPAREN, 0);
}

MemgraphCypher::PropertyKeyNameContext* MemgraphCypher::CreateIndexContext::propertyKeyName() {
  return getRuleContext<MemgraphCypher::PropertyKeyNameContext>(0);
}

tree::TerminalNode* MemgraphCypher::CreateIndexContext::RPAREN() {
  return getToken(MemgraphCypher::RPAREN, 0);
}


size_t MemgraphCypher::CreateIndexContext::getRuleIndex() const {
  return MemgraphCypher::RuleCreateIndex;
}

void MemgraphCypher::CreateIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateIndex(this);
}

void MemgraphCypher::CreateIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateIndex(this);
}


std::any MemgraphCypher::CreateIndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitCreateIndex(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::CreateIndexContext* MemgraphCypher::createIndex() {
  CreateIndexContext *_localctx = _tracker.createInstance<CreateIndexContext>(_ctx, getState());
  enterRule(_localctx, 366, MemgraphCypher::RuleCreateIndex);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1850);
    match(MemgraphCypher::CREATE);
    setState(1851);
    match(MemgraphCypher::INDEX);
    setState(1852);
    match(MemgraphCypher::ON);
    setState(1853);
    match(MemgraphCypher::COLON);
    setState(1854);
    labelName();
    setState(1859);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::LPAREN) {
      setState(1855);
      match(MemgraphCypher::LPAREN);
      setState(1856);
      propertyKeyName();
      setState(1857);
      match(MemgraphCypher::RPAREN);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropIndexContext ------------------------------------------------------------------

MemgraphCypher::DropIndexContext::DropIndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::DropIndexContext::DROP() {
  return getToken(MemgraphCypher::DROP, 0);
}

tree::TerminalNode* MemgraphCypher::DropIndexContext::INDEX() {
  return getToken(MemgraphCypher::INDEX, 0);
}

tree::TerminalNode* MemgraphCypher::DropIndexContext::ON() {
  return getToken(MemgraphCypher::ON, 0);
}

tree::TerminalNode* MemgraphCypher::DropIndexContext::COLON() {
  return getToken(MemgraphCypher::COLON, 0);
}

MemgraphCypher::LabelNameContext* MemgraphCypher::DropIndexContext::labelName() {
  return getRuleContext<MemgraphCypher::LabelNameContext>(0);
}

tree::TerminalNode* MemgraphCypher::DropIndexContext::LPAREN() {
  return getToken(MemgraphCypher::LPAREN, 0);
}

MemgraphCypher::PropertyKeyNameContext* MemgraphCypher::DropIndexContext::propertyKeyName() {
  return getRuleContext<MemgraphCypher::PropertyKeyNameContext>(0);
}

tree::TerminalNode* MemgraphCypher::DropIndexContext::RPAREN() {
  return getToken(MemgraphCypher::RPAREN, 0);
}


size_t MemgraphCypher::DropIndexContext::getRuleIndex() const {
  return MemgraphCypher::RuleDropIndex;
}

void MemgraphCypher::DropIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropIndex(this);
}

void MemgraphCypher::DropIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropIndex(this);
}


std::any MemgraphCypher::DropIndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitDropIndex(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::DropIndexContext* MemgraphCypher::dropIndex() {
  DropIndexContext *_localctx = _tracker.createInstance<DropIndexContext>(_ctx, getState());
  enterRule(_localctx, 368, MemgraphCypher::RuleDropIndex);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1861);
    match(MemgraphCypher::DROP);
    setState(1862);
    match(MemgraphCypher::INDEX);
    setState(1863);
    match(MemgraphCypher::ON);
    setState(1864);
    match(MemgraphCypher::COLON);
    setState(1865);
    labelName();
    setState(1870);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MemgraphCypher::LPAREN) {
      setState(1866);
      match(MemgraphCypher::LPAREN);
      setState(1867);
      propertyKeyName();
      setState(1868);
      match(MemgraphCypher::RPAREN);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DoubleLiteralContext ------------------------------------------------------------------

MemgraphCypher::DoubleLiteralContext::DoubleLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::DoubleLiteralContext::FloatingLiteral() {
  return getToken(MemgraphCypher::FloatingLiteral, 0);
}


size_t MemgraphCypher::DoubleLiteralContext::getRuleIndex() const {
  return MemgraphCypher::RuleDoubleLiteral;
}

void MemgraphCypher::DoubleLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDoubleLiteral(this);
}

void MemgraphCypher::DoubleLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDoubleLiteral(this);
}


std::any MemgraphCypher::DoubleLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitDoubleLiteral(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::DoubleLiteralContext* MemgraphCypher::doubleLiteral() {
  DoubleLiteralContext *_localctx = _tracker.createInstance<DoubleLiteralContext>(_ctx, getState());
  enterRule(_localctx, 370, MemgraphCypher::RuleDoubleLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1872);
    match(MemgraphCypher::FloatingLiteral);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CypherKeywordContext ------------------------------------------------------------------

MemgraphCypher::CypherKeywordContext::CypherKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::ALL() {
  return getToken(MemgraphCypher::ALL, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::AND() {
  return getToken(MemgraphCypher::AND, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::ANY() {
  return getToken(MemgraphCypher::ANY, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::AS() {
  return getToken(MemgraphCypher::AS, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::ASC() {
  return getToken(MemgraphCypher::ASC, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::ASCENDING() {
  return getToken(MemgraphCypher::ASCENDING, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::ASSERT() {
  return getToken(MemgraphCypher::ASSERT, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::BFS() {
  return getToken(MemgraphCypher::BFS, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::BY() {
  return getToken(MemgraphCypher::BY, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::CALL() {
  return getToken(MemgraphCypher::CALL, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::CASE() {
  return getToken(MemgraphCypher::CASE, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::CONSTRAINT() {
  return getToken(MemgraphCypher::CONSTRAINT, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::CONTAINS() {
  return getToken(MemgraphCypher::CONTAINS, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::COUNT() {
  return getToken(MemgraphCypher::COUNT, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::CREATE() {
  return getToken(MemgraphCypher::CREATE, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::CYPHERNULL() {
  return getToken(MemgraphCypher::CYPHERNULL, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::DELETE() {
  return getToken(MemgraphCypher::DELETE, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::DESC() {
  return getToken(MemgraphCypher::DESC, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::DESCENDING() {
  return getToken(MemgraphCypher::DESCENDING, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::DETACH() {
  return getToken(MemgraphCypher::DETACH, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::DISTINCT() {
  return getToken(MemgraphCypher::DISTINCT, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::ELSE() {
  return getToken(MemgraphCypher::ELSE, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::END() {
  return getToken(MemgraphCypher::END, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::ENDS() {
  return getToken(MemgraphCypher::ENDS, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::EXISTS() {
  return getToken(MemgraphCypher::EXISTS, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::EXPLAIN() {
  return getToken(MemgraphCypher::EXPLAIN, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::EXTRACT() {
  return getToken(MemgraphCypher::EXTRACT, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::FALSE() {
  return getToken(MemgraphCypher::FALSE, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::FILTER() {
  return getToken(MemgraphCypher::FILTER, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::IN() {
  return getToken(MemgraphCypher::IN, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::INDEX() {
  return getToken(MemgraphCypher::INDEX, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::INFO() {
  return getToken(MemgraphCypher::INFO, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::IS() {
  return getToken(MemgraphCypher::IS, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::KEY() {
  return getToken(MemgraphCypher::KEY, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::LIMIT() {
  return getToken(MemgraphCypher::LIMIT, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::L_SKIP() {
  return getToken(MemgraphCypher::L_SKIP, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::MATCH() {
  return getToken(MemgraphCypher::MATCH, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::MERGE() {
  return getToken(MemgraphCypher::MERGE, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::NODE() {
  return getToken(MemgraphCypher::NODE, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::NONE() {
  return getToken(MemgraphCypher::NONE, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::NOT() {
  return getToken(MemgraphCypher::NOT, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::ON() {
  return getToken(MemgraphCypher::ON, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::OPTIONAL() {
  return getToken(MemgraphCypher::OPTIONAL, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::OR() {
  return getToken(MemgraphCypher::OR, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::ORDER() {
  return getToken(MemgraphCypher::ORDER, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::PROCEDURE() {
  return getToken(MemgraphCypher::PROCEDURE, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::PROFILE() {
  return getToken(MemgraphCypher::PROFILE, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::QUERY() {
  return getToken(MemgraphCypher::QUERY, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::REDUCE() {
  return getToken(MemgraphCypher::REDUCE, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::REMOVE() {
  return getToken(MemgraphCypher::REMOVE, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::RETURN() {
  return getToken(MemgraphCypher::RETURN, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::SET() {
  return getToken(MemgraphCypher::SET, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::SHOW() {
  return getToken(MemgraphCypher::SHOW, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::SINGLE() {
  return getToken(MemgraphCypher::SINGLE, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::STARTS() {
  return getToken(MemgraphCypher::STARTS, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::STORAGE() {
  return getToken(MemgraphCypher::STORAGE, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::THEN() {
  return getToken(MemgraphCypher::THEN, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::TRUE() {
  return getToken(MemgraphCypher::TRUE, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::UNION() {
  return getToken(MemgraphCypher::UNION, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::UNIQUE() {
  return getToken(MemgraphCypher::UNIQUE, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::UNWIND() {
  return getToken(MemgraphCypher::UNWIND, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::WHEN() {
  return getToken(MemgraphCypher::WHEN, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::WHERE() {
  return getToken(MemgraphCypher::WHERE, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::WITH() {
  return getToken(MemgraphCypher::WITH, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::WSHORTEST() {
  return getToken(MemgraphCypher::WSHORTEST, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::XOR() {
  return getToken(MemgraphCypher::XOR, 0);
}

tree::TerminalNode* MemgraphCypher::CypherKeywordContext::YIELD() {
  return getToken(MemgraphCypher::YIELD, 0);
}


size_t MemgraphCypher::CypherKeywordContext::getRuleIndex() const {
  return MemgraphCypher::RuleCypherKeyword;
}

void MemgraphCypher::CypherKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCypherKeyword(this);
}

void MemgraphCypher::CypherKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MemgraphCypherListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCypherKeyword(this);
}


std::any MemgraphCypher::CypherKeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MemgraphCypherVisitor*>(visitor))
    return parserVisitor->visitCypherKeyword(this);
  else
    return visitor->visitChildren(this);
}

MemgraphCypher::CypherKeywordContext* MemgraphCypher::cypherKeyword() {
  CypherKeywordContext *_localctx = _tracker.createInstance<CypherKeywordContext>(_ctx, getState());
  enterRule(_localctx, 372, MemgraphCypher::RuleCypherKeyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1874);
    _la = _input->LA(1);
    if (!(((((_la - 123) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 123)) & ((1ULL << (MemgraphCypher::ALL - 123))
      | (1ULL << (MemgraphCypher::AND - 123))
      | (1ULL << (MemgraphCypher::ANY - 123))
      | (1ULL << (MemgraphCypher::AS - 123))
      | (1ULL << (MemgraphCypher::ASC - 123))
      | (1ULL << (MemgraphCypher::ASCENDING - 123))
      | (1ULL << (MemgraphCypher::ASSERT - 123))
      | (1ULL << (MemgraphCypher::BFS - 123))
      | (1ULL << (MemgraphCypher::BY - 123))
      | (1ULL << (MemgraphCypher::CALL - 123))
      | (1ULL << (MemgraphCypher::CASE - 123))
      | (1ULL << (MemgraphCypher::CONSTRAINT - 123))
      | (1ULL << (MemgraphCypher::CONTAINS - 123))
      | (1ULL << (MemgraphCypher::COUNT - 123))
      | (1ULL << (MemgraphCypher::CREATE - 123))
      | (1ULL << (MemgraphCypher::CYPHERNULL - 123))
      | (1ULL << (MemgraphCypher::DELETE - 123))
      | (1ULL << (MemgraphCypher::DESC - 123))
      | (1ULL << (MemgraphCypher::DESCENDING - 123))
      | (1ULL << (MemgraphCypher::DETACH - 123))
      | (1ULL << (MemgraphCypher::DISTINCT - 123))
      | (1ULL << (MemgraphCypher::ELSE - 123))
      | (1ULL << (MemgraphCypher::END - 123))
      | (1ULL << (MemgraphCypher::ENDS - 123))
      | (1ULL << (MemgraphCypher::EXISTS - 123))
      | (1ULL << (MemgraphCypher::EXPLAIN - 123))
      | (1ULL << (MemgraphCypher::EXTRACT - 123))
      | (1ULL << (MemgraphCypher::FALSE - 123))
      | (1ULL << (MemgraphCypher::FILTER - 123))
      | (1ULL << (MemgraphCypher::IN - 123))
      | (1ULL << (MemgraphCypher::INDEX - 123))
      | (1ULL << (MemgraphCypher::INFO - 123))
      | (1ULL << (MemgraphCypher::IS - 123))
      | (1ULL << (MemgraphCypher::KEY - 123))
      | (1ULL << (MemgraphCypher::LIMIT - 123))
      | (1ULL << (MemgraphCypher::L_SKIP - 123))
      | (1ULL << (MemgraphCypher::MATCH - 123))
      | (1ULL << (MemgraphCypher::MERGE - 123))
      | (1ULL << (MemgraphCypher::NODE - 123))
      | (1ULL << (MemgraphCypher::NONE - 123))
      | (1ULL << (MemgraphCypher::NOT - 123))
      | (1ULL << (MemgraphCypher::ON - 123))
      | (1ULL << (MemgraphCypher::OPTIONAL - 123))
      | (1ULL << (MemgraphCypher::OR - 123))
      | (1ULL << (MemgraphCypher::ORDER - 123))
      | (1ULL << (MemgraphCypher::PROCEDURE - 123))
      | (1ULL << (MemgraphCypher::PROFILE - 123))
      | (1ULL << (MemgraphCypher::QUERY - 123))
      | (1ULL << (MemgraphCypher::REDUCE - 123))
      | (1ULL << (MemgraphCypher::REMOVE - 123))
      | (1ULL << (MemgraphCypher::RETURN - 123))
      | (1ULL << (MemgraphCypher::SET - 123))
      | (1ULL << (MemgraphCypher::SHOW - 123))
      | (1ULL << (MemgraphCypher::SINGLE - 123))
      | (1ULL << (MemgraphCypher::STARTS - 123))
      | (1ULL << (MemgraphCypher::STORAGE - 123))
      | (1ULL << (MemgraphCypher::THEN - 123))
      | (1ULL << (MemgraphCypher::TRUE - 123))
      | (1ULL << (MemgraphCypher::UNION - 123))
      | (1ULL << (MemgraphCypher::UNIQUE - 123)))) != 0) || ((((_la - 188) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 188)) & ((1ULL << (MemgraphCypher::UNWIND - 188))
      | (1ULL << (MemgraphCypher::WHEN - 188))
      | (1ULL << (MemgraphCypher::WHERE - 188))
      | (1ULL << (MemgraphCypher::WITH - 188))
      | (1ULL << (MemgraphCypher::WSHORTEST - 188))
      | (1ULL << (MemgraphCypher::XOR - 188))
      | (1ULL << (MemgraphCypher::YIELD - 188)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

void MemgraphCypher::initialize() {
  std::call_once(memgraphcypherParserOnceFlag, memgraphcypherParserInitialize);
}
