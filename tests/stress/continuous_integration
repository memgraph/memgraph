#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import argparse
import copy
import multiprocessing
import os
import subprocess
import time
from abc import ABC
from argparse import Namespace as Args
from subprocess import Popen
from typing import Dict, List, Optional

import yaml
from gqlalchemy import Memgraph

# paths
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
BASE_DIR = os.path.normpath(os.path.join(SCRIPT_DIR, "..", ".."))
BUILD_DIR = os.path.join(BASE_DIR, "build")
MEASUREMENTS_FILE = os.path.join(SCRIPT_DIR, ".apollo_measurements")
KEY_FILE = os.path.join(SCRIPT_DIR, ".key.pem")
CERT_FILE = os.path.join(SCRIPT_DIR, ".cert.pem")

# long running stats file
STATS_FILE = os.path.join(SCRIPT_DIR, ".long_running_stats")

# get number of threads
THREADS = os.environ["THREADS"] if "THREADS" in os.environ else multiprocessing.cpu_count()


class Config:
    def __init__(self, config):
        self._verbose = config.get("general", {}).get("verbose", False)
        self._use_ssl = config.get("general", {}).get("use_ssl", False)

        # Memgraph configuration
        memgraph = config.get("memgraph", {})
        deployment = memgraph.get("deployment", {})
        self._deployment_type = deployment.get("type", "default")
        self._memgraph_args = memgraph.get("args", [])

        # Dataset tests
        dataset = config.get("dataset", {})
        self._tests = dataset.get("tests", [])

        if self._deployment_type == "docker":
            self._image = deployment.get("options", {}).get("image")
            self._tag = deployment.get("options", {}).get("tag")

    @property
    def uses_ssl(self):
        return self._use_ssl

    @property
    def is_verbose(self):
        return self._verbose

    @property
    def deployment_type(self):
        return self._deployment_type

    @property
    def docker_image(self):
        return self._image

    @property
    def docker_tag(self):
        return self._tag

    @property
    def tests(self):
        return self._tests

    @property
    def memgraph_args(self):
        return self._memgraph_args


class Deployment(ABC):
    def start_memgraph(self, flags: List[str]):
        pass

    def stop_memgraph(self) -> None:
        pass

    def cleanup(self) -> None:
        pass

    def wait_for_server(self, port) -> None:
        pass


class DefaultDeployment(Deployment):
    def __init__(self, memgraph: str):
        super().__init__()
        self.memgraph = memgraph

    def start_memgraph(self, flags: List[str]):
        """Starts Memgraph and return the process"""
        cwd = os.path.dirname(self.memgraph)

        cmd = [self.memgraph] + flags
        memgraph_proc = subprocess.Popen(cmd, cwd=cwd)
        self.wait_for_server(7687)

        assert memgraph_proc.poll() is None, "The database binary died prematurely!"

        self.memgraph_proc = memgraph_proc

    def stop_memgraph(self) -> None:
        self.memgraph_proc.terminate()
        ret_mg = self.memgraph_proc.wait()
        if ret_mg != 0:
            raise Exception("Memgraph binary returned non-zero ({})!".format(ret_mg))

    def cleanup(self):
        if self.memgraph_proc.poll() != None:
            return
        self.memgraph_proc.kill()
        self.memgraph_proc.wait()

    def wait_for_server(self, port) -> None:
        cmd = ["nc", "-z", "-w", "1", "127.0.0.1", str(port)]
        while subprocess.call(cmd) != 0:
            time.sleep(0.5)
        time.sleep(2)


class DockerDeployment(Deployment):
    def __init__(self, image: str, tag: str):
        super().__init__()
        self._image = image
        self._tag = tag
        self._container_name = "mg_stress"

    def start_memgraph(self, flags: List[str]) -> None:
        """Starts Memgraph in a Docker container and returns the process."""
        # Construct the docker run command
        cmd = (
            [
                "docker",
                "run",
                "--rm",
                "-d",
                "--name",
                self._container_name,
                "-p",
                "7687:7687",
            ]
            + [f"{self._image}:{self._tag}"]
            + flags
        )

        # Start the Docker container
        subprocess.run(cmd, check=True)
        self.wait_for_server(7687)

        # Check if the container is running
        status_cmd = ["docker", "ps", "--filter", f"name={self._container_name}", "--format", "{{.ID}}"]
        container_id = subprocess.check_output(status_cmd).decode("utf-8").strip()

        assert container_id, "The Memgraph Docker container failed to start!"

        self._container_id = container_id

    def stop_memgraph(self) -> None:
        """Stops and removes the Memgraph Docker container."""
        # Stop the Docker container
        cmd = ["docker", "stop", self._container_id]
        ret = subprocess.run(cmd)
        if ret.returncode != 0:
            raise Exception(f"Failed to stop Docker container ({self._container_id})!")

    def cleanup(self) -> None:
        """Cleans up the Docker container if it is still running."""
        try:
            # Check if the container is running
            status_cmd = ["docker", "ps", "--filter", f"name={self._container_name}", "--format", "{{.ID}}"]
            container_id = subprocess.check_output(status_cmd).decode("utf-8").strip()

            if container_id:
                # Stop and remove the container
                self.stop_memgraph(container_id)
        except subprocess.CalledProcessError:
            # Ignore errors if the container is already stopped or does not exist
            pass

    def wait_for_server(self, port) -> None:
        cmd = ["nc", "-z", "-w", "1", "127.0.0.1", str(port)]
        while subprocess.call(cmd) != 0:
            print(f"Waiting for server on host port {port}...")
            time.sleep(0.5)
        time.sleep(2)
        print(f"Server is now accessible on host port {port}.")


def deployment_factory(args: Args, config: Config):
    deployment_type = config.deployment_type
    if deployment_type == "default":
        return DefaultDeployment(args.memgraph)

    if deployment_type == "docker":
        return DockerDeployment(config.docker_image, config.docker_tag)


def generate_temporary_ssl_certs():
    # https://unix.stackexchange.com/questions/104171/create-ssl-certificate-non-interactively
    subj = "/C=HR/ST=Zagreb/L=Zagreb/O=Memgraph/CN=db.memgraph.com"
    subprocess.run(
        [
            "openssl",
            "req",
            "-new",
            "-newkey",
            "rsa:4096",
            "-days",
            "365",
            "-nodes",
            "-x509",
            "-subj",
            subj,
            "-keyout",
            KEY_FILE,
            "-out",
            CERT_FILE,
        ],
        check=True,
    )


def remove_certificates() -> None:
    os.remove(KEY_FILE)
    os.remove(CERT_FILE)


def parse_arguments() -> Args:
    # parse arguments
    parser = argparse.ArgumentParser(description="Run stress tests on Memgraph.")
    parser.add_argument("--memgraph", default=os.path.join(BUILD_DIR, "memgraph"))
    parser.add_argument("--config_file", default=os.path.join(SCRIPT_DIR, "config_small.yaml"))
    parser.add_argument("--python", default=os.path.join(SCRIPT_DIR, "ve3", "bin", "python3"), type=str)
    return parser.parse_args()


def run_test(args: Args, config: Config, test: str, options: List[str], timeout: int) -> float:
    """Runs tests for a set of specific database configuration.

    Args:
        args: Arguments passed to the test
        test: Test name
        options: List of options specific for each test
        timeout: Timeout in minutes
    """
    print("Running test '{}'".format(test))

    binary = _find_test_binary(args, config, test)

    # start test
    cmd = binary + ["--worker-count", str(THREADS)] + options
    start = time.time()
    ret_test = subprocess.run(cmd, cwd=SCRIPT_DIR, timeout=timeout * 60)

    if ret_test.returncode != 0:
        raise Exception("Test '{}' binary returned non-zero ({})!".format(test, ret_test.returncode))

    runtime = time.time() - start
    print("    Done after {:.3f} seconds".format(runtime))

    return runtime


def _find_test_binary(args: Args, config: Config, test: str) -> List[str]:
    if test.endswith(".py"):
        logging = "DEBUG" if config.is_verbose else "WARNING"
        return [args.python, "-u", os.path.join(SCRIPT_DIR, test), "--logging", logging]

    if test.endswith(".cpp"):
        exe = os.path.join(BUILD_DIR, "tests", "stress", test[:-4])
        return [exe]

    raise Exception("Test '{}' binary not supported!".format(test))


def run_stress_test_suite(args: Args, config: Config) -> Optional[Dict[str, float]]:
    runtimes = {}

    deployment = deployment_factory(args, config)

    for test in config.tests:
        test_name = test["name"]
        test_flags = test["test_args"]
        timeout = test["timeout_min"]
        memgraph_flags = test["memgraph_args"] if "memgraph_args" in test else []
        memgraph_flags += config.memgraph_args
        if config.uses_ssl:
            test_flags += ["--use-ssl"]
            memgraph_flags += [f"--bolt-cert-file={CERT_FILE}", f"--bolt-key-file={KEY_FILE}"]

        try:
            deployment.start_memgraph(memgraph_flags)
        except Exception as ex:
            print("Exception occured while starting memgraph", ex)
            return None
        err = False
        try:
            runtime = run_test(args, config, test_name, test_flags, timeout)
            runtimes[os.path.splitext(test_name)[0]] = runtime
        except Exception as ex:
            print(f"Failed to execute {test_name} with following exception:", ex)
            err = True
        finally:
            deployment.stop_memgraph()
            deployment.cleanup()
        if err:
            return None

    return runtimes


def write_stats(runtimes: Dict[str, float]) -> None:
    measurements = ""
    for key, value in runtimes.items():
        measurements += "{}.runtime {}\n".format(key, value)
    if "long_running" in runtimes:
        with open(STATS_FILE) as f:
            stats = f.read().split("\n")
        measurements += "long_running.queries.executed {}\n".format(stats[0])
        measurements += "long_running.queries.failed {}\n".format(stats[1])
    with open(MEASUREMENTS_FILE, "w") as f:
        f.write(measurements)


if __name__ == "__main__":
    args = parse_arguments()
    config = Config(yaml.safe_load(open(args.config_file)))

    if config.uses_ssl:
        generate_temporary_ssl_certs()

    runtimes = run_stress_test_suite(args, config)

    if runtimes is None:
        print("Some stress tests have failed")
        exit(1)
    assert runtimes is not None

    if config.uses_ssl:
        remove_certificates()
    write_stats(runtimes)

    print("Successfully ran stress tests!")
