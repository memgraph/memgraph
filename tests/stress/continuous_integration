#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import argparse
import copy
import multiprocessing
import os
import subprocess
import time
from abc import ABC
from argparse import Namespace as Args
from subprocess import Popen
from typing import Dict, List, Optional

import yaml

# paths
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
BASE_DIR = os.path.normpath(os.path.join(SCRIPT_DIR, "..", ".."))
BUILD_DIR = os.path.join(BASE_DIR, "build")
MEASUREMENTS_FILE = os.path.join(SCRIPT_DIR, ".apollo_measurements")
KEY_FILE = os.path.join(SCRIPT_DIR, ".key.pem")
CERT_FILE = os.path.join(SCRIPT_DIR, ".cert.pem")

# long running stats file
STATS_FILE = os.path.join(SCRIPT_DIR, ".long_running_stats")

# get number of threads
THREADS = os.environ["THREADS"] if "THREADS" in os.environ else multiprocessing.cpu_count()


def wait_for_server(port, delay=0.5) -> None:
    cmd = ["nc", "-z", "-w", "1", "127.0.0.1", str(port)]
    while subprocess.call(cmd) != 0:
        time.sleep(delay)
    time.sleep(delay)


class Deployment(ABC):
    def start_memgraph(self, flags: List[str]):
        pass

    def stop_memgraph(self) -> None:
        pass

    def cleanup(self) -> None:
        pass


class DefaultDeployment(Deployment):
    def __init__(self, memgraph: str):
        super().__init__()
        self.memgraph = memgraph

    def start_memgraph(self, flags: List[str]):
        """Starts Memgraph and return the process"""
        cwd = os.path.dirname(self.memgraph)

        cmd = [self.memgraph] + flags
        memgraph_proc = subprocess.Popen(cmd, cwd=cwd)
        wait_for_server(7687)

        assert memgraph_proc.poll() is None, "The database binary died prematurely!"

        self.memgraph_proc = memgraph_proc

    def stop_memgraph(self) -> None:
        self.memgraph_proc.terminate()
        ret_mg = self.memgraph_proc.wait()
        if ret_mg != 0:
            raise Exception("Memgraph binary returned non-zero ({})!".format(ret_mg))

    def cleanup(self):
        if self.memgraph_proc.poll() != None:
            return
        self.memgraph_proc.kill()
        self.memgraph_proc.wait()


class DockerDeployment(Deployment):
    def __init__(self, image: str, tag: str):
        super().__init__()
        self.image = image
        self.tag = tag
        self.container_name = "mg_stress"

    def start_memgraph(self, flags: List[str]) -> None:
        """Starts Memgraph in a Docker container and returns the process."""
        # Construct the docker run command
        cmd = (
            [
                "docker",
                "run",
                "--rm",
                "-d",
                "--name",
                self.container_name,
                "-p",
                "7687:7687",
            ]
            + [f"{self.image}:{self.tag}"]
            + flags
        )

        # Start the Docker container
        subprocess.run(cmd, check=True)
        wait_for_server(7687)

        # Check if the container is running
        status_cmd = ["docker", "ps", "--filter", f"name={self.container_name}", "--format", "{{.ID}}"]
        container_id = subprocess.check_output(status_cmd).decode("utf-8").strip()

        assert container_id, "The Memgraph Docker container failed to start!"

        self.container_id = container_id

    def stop_memgraph(self) -> None:
        """Stops and removes the Memgraph Docker container."""
        # Stop the Docker container
        cmd = ["docker", "stop", self.container_id]
        ret = subprocess.run(cmd)
        if ret.returncode != 0:
            raise Exception(f"Failed to stop Docker container ({self.container_id})!")

        # try:
        #     # Ensure container is removed
        #     rm_cmd = ["docker", "rm", self.container_id]
        #     subprocess.run(rm_cmd, check=True)
        # except subprocess.CalledProcessError as e:
        #     # Handle "removal already in progress" error
        #     if "removal of container" in str(e) and "is already in progress" in str(e):
        #         print(f"Container {self.container_id} is already being removed, skipping.")
        #     else:
        #         raise

    def cleanup(self) -> None:
        """Cleans up the Docker container if it is still running."""
        try:
            # Check if the container is running
            status_cmd = ["docker", "ps", "--filter", f"name={self.container_name}", "--format", "{{.ID}}"]
            container_id = subprocess.check_output(status_cmd).decode("utf-8").strip()

            if container_id:
                # Stop and remove the container
                self.stop_memgraph(container_id)
        except subprocess.CalledProcessError:
            # Ignore errors if the container is already stopped or does not exist
            pass


def deployment_factory(args, config):
    deployment = config.get("memgraph").get("deployment")
    deployment_type = deployment.get("type")
    if deployment_type == "default":
        return DefaultDeployment(args.memgraph)

    if deployment_type == "docker":
        return DockerDeployment(deployment.get("image"), deployment.get("tag"))


def generate_temporary_ssl_certs():
    # https://unix.stackexchange.com/questions/104171/create-ssl-certificate-non-interactively
    subj = "/C=HR/ST=Zagreb/L=Zagreb/O=Memgraph/CN=db.memgraph.com"
    subprocess.run(
        [
            "openssl",
            "req",
            "-new",
            "-newkey",
            "rsa:4096",
            "-days",
            "365",
            "-nodes",
            "-x509",
            "-subj",
            subj,
            "-keyout",
            KEY_FILE,
            "-out",
            CERT_FILE,
        ],
        check=True,
    )


def remove_certificates() -> None:
    os.remove(KEY_FILE)
    os.remove(CERT_FILE)


def parse_arguments() -> Args:
    # parse arguments
    parser = argparse.ArgumentParser(description="Run stress tests on Memgraph.")
    parser.add_argument("--memgraph", default=os.path.join(BUILD_DIR, "memgraph"))
    parser.add_argument("--config_file", default=os.path.join(SCRIPT_DIR, "config_docker.yaml"))
    parser.add_argument("--python", default=os.path.join(SCRIPT_DIR, "ve3", "bin", "python3"), type=str)
    parser.add_argument("--verbose", action="store_const", const=True, default=False)
    return parser.parse_args()


def uses_ssl(config):
    return "dataset" in config and "use_ssl" in config["dataset"] and config["dataset"]["use_ssl"]


def run_test(args: Args, test: str, options: List[str], timeout: int) -> float:
    """Runs tests for a set of specific database configuration.

    Args:
        args: Arguments passed to the test
        test: Test name
        options: List of options specific for each test
        timeout: Timeout in minutes
    """
    print("Running test '{}'".format(test))

    binary = _find_test_binary(args, test)

    # start test
    cmd = binary + ["--worker-count", str(THREADS)] + options
    start = time.time()
    ret_test = subprocess.run(cmd, cwd=SCRIPT_DIR, timeout=timeout * 60)

    if ret_test.returncode != 0:
        raise Exception("Test '{}' binary returned non-zero ({})!".format(test, ret_test.returncode))

    runtime = time.time() - start
    print("    Done after {:.3f} seconds".format(runtime))

    return runtime


def _find_test_binary(args: Args, test: str) -> List[str]:
    if test.endswith(".py"):
        logging = "DEBUG" if args.verbose else "WARNING"
        return [args.python, "-u", os.path.join(SCRIPT_DIR, test), "--logging", logging]

    if test.endswith(".cpp"):
        exe = os.path.join(BUILD_DIR, "tests", "stress", test[:-4])
        return [exe]

    raise Exception("Test '{}' binary not supported!".format(test))


def run_stress_test_suite(args: Args, config) -> Optional[Dict[str, float]]:
    runtimes = {}

    dataset = config["dataset"]["tests"]
    deployment = deployment_factory(args, config)

    for test in dataset:
        test_name = test["name"]
        test_flags = test["test_args"]
        timeout = test["timeout_min"]
        memgraph_flags = test["memgraph_args"] if "memgraph_args" in test else []
        memgraph_flags += config["memgraph"]["args"]
        if "use_ssl" in config["dataset"] and config["dataset"]["use_ssl"] is True:
            test_flags += ["--use-ssl"]
            memgraph_flags += [f"--bolt-cert-file={CERT_FILE}", f"--bolt-key-file={KEY_FILE}"]

        try:
            deployment.start_memgraph(memgraph_flags)
        except Exception as ex:
            print("Exception occured while starting memgraph", ex)
            return None
        err = False
        try:
            runtime = run_test(args, test_name, test_flags, timeout)
            runtimes[os.path.splitext(test_name)[0]] = runtime
        except Exception as ex:
            print(f"Failed to execute {test_name} with following exception:", ex)
            err = True
        finally:
            deployment.stop_memgraph()
            deployment.cleanup()
        if err:
            return None

    return runtimes


def write_stats(runtimes: Dict[str, float]) -> None:
    measurements = ""
    for key, value in runtimes.items():
        measurements += "{}.runtime {}\n".format(key, value)
    if "long_running" in runtimes:
        with open(STATS_FILE) as f:
            stats = f.read().split("\n")
        measurements += "long_running.queries.executed {}\n".format(stats[0])
        measurements += "long_running.queries.failed {}\n".format(stats[1])
    with open(MEASUREMENTS_FILE, "w") as f:
        f.write(measurements)


if __name__ == "__main__":
    args = parse_arguments()
    config = yaml.safe_load(open(args.config_file))

    if uses_ssl(config):
        generate_temporary_ssl_certs()

    runtimes = run_stress_test_suite(args, config)
    if runtimes is None:
        print("Some stress tests have failed")
        exit(1)
    assert runtimes is not None
    if uses_ssl(config):
        remove_certificates()
    write_stats(runtimes)

    print("Successfully ran stress tests!")
